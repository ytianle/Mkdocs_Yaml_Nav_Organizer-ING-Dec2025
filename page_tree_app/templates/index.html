<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>MkDocs Nav Manager</title>
  <link rel="stylesheet" href="/static/style.css">
</head>

<body>
  <div class="shell">
	    <header class="toolbar">
	      <div class="title">
	        <h1>MkDocs Nav Manager</h1>
	        <div id="meta" class="muted">Loading...</div>
	      </div>
	      <div class="inline-actions">
	        <button id="toggle-tools" type="button" class="ghost" data-help="Toggle Tools panel">ğŸ› </button>
	        <button id="toggle-source" type="button" class="ghost" data-help="Toggle Source panel">ğŸ—‚</button>
	        <button id="toggle-tree" type="button" class="ghost" data-help="Toggle Doc Tree panel">ğŸ“š</button>
	        <button id="toggle-info" type="button" class="ghost" data-help="Toggle Info panel">â„¹ï¸</button>
	      </div>
	    </header>

    <div id="tool-tooltip" class="tool-tooltip" hidden></div>

    <div id="workspace" class="workspace">
      <section class="card panel dock-tools" id="panel-tools">
        <div class="card-head">
          <h2>ğŸ›  Tools</h2>
          <span class="muted">Hover for hints</span>
        </div>
        <div class="list-shell tools-body tools-dock-body">
          <div class="tools-group">
            <div class="tools-title">ğŸ§© Draft & History</div>
            <div class="tools-buttons">
              <button id="tool-undo" type="button" class="ghost" data-help="Undo last change">âª Undo</button>
              <button id="tool-redo" type="button" class="ghost" data-help="Redo last undone change">â© Redo</button>
              <button id="tool-save" type="button" class="ghost"
                data-help="Save draft to .page_tree_state.json (does not change mkdocs.yml)">ğŸ“ Save Draft</button>
              <button id="tool-reload" type="button" class="ghost"
                data-help="Reload Doc Tree from .page_tree_state.json (may discard edits)">ğŸ”„ Reload Draft</button>
            </div>
          </div>

          <div class="splitter splitter-v splitter-tools" id="split-tools" title="Drag to resize tools"></div>

          <div class="tools-group">
            <div class="tools-title">ğŸš€ Main</div>
            <div class="tools-buttons">
              <button id="tool-import" type="button" class="ghost"
                data-help="Rebuild Doc Tree from mkdocs.yml nav (overwrites current draft)">ğŸ“¥ Load mkdocs.yml</button>
              <button id="tool-sync-nav" type="button" class="ghost"
                data-help="Write mkdocs.yml nav only (no file moves)">ğŸ§­ Sync Nav Only</button>
              <button id="tool-sync-files" type="button" class="ghost"
                data-help="Write mkdocs.yml and move files to match Doc Tree">ğŸ“¦ Sync Files</button>
              <button id="tool-debug" type="button" class="ghost" data-help="Toggle debug window (DnD logs)">ğŸ§ª
                Debug</button>
            </div>
          </div>
        </div>
      </section>

      <div class="main-grid">
        <section class="card panel" id="panel-source">
          <div class="card-head">
            <h2>Source</h2>
            <div class="inline-actions">
              <span class="muted">Click to locate in tree</span>
              <button id="source-view-btn" type="button" class="ghost"
                data-help="Toggle source view (Explorer / ASCII)">ğŸ§¾ ASCII</button>
            </div>
          </div>
          <div id="source" class="list-shell">Loading...</div>
        </section>

        <div class="splitter splitter-v" id="split-main-left" title="Drag to resize"></div>

        <section class="card panel" id="panel-tree">
          <div class="card-head">
            <h2>ğŸ“š Doc Tree</h2>
            <div class="inline-actions">
              <div class="segmented" role="group" aria-label="Depth limit">
                <button type="button" class="ghost depth-btn" data-depth="1" data-help="Show 1 level">1</button>
                <button type="button" class="ghost depth-btn" data-depth="2" data-help="Show 2 levels">2</button>
                <button type="button" class="ghost depth-btn" data-depth="3" data-help="Show 3 levels">3</button>
                <button type="button" class="ghost depth-btn" data-depth="4" data-help="Show 4 levels">4</button>
                <button type="button" class="ghost depth-btn" data-depth="5" data-help="Show 5 levels">5</button>
                <button type="button" class="ghost depth-btn" data-depth="n" data-help="Show all levels">âˆ</button>
              </div>
              <button id="new-folder-btn" type="button" data-help="Create a new section under selection">â•ğŸ“ New
                Section</button>
              <button id="new-page-btn" type="button" data-help="Create a new page under selection">â•ğŸ“„ New
                Page</button>
              <button id="delete-btn" type="button" data-help="Delete selected node (tree only)">ğŸ—‘ï¸ Delete</button>
            </div>
          </div>
          <div id="tree" class="list-shell">Loading...</div>
        </section>
      </div>

      <div class="splitter splitter-h" id="split-bottom" title="Drag to resize"></div>

      <div class="bottom-stack debug-hidden" id="bottom-stack">
        <section class="card panel" id="panel-info">
          <div class="card-head">
            <h2>â„¹ï¸ Info</h2>
            <span class="muted">Hover tools for hints</span>
          </div>
          <div class="list-shell info-body">
            <div id="status" class="status-box" data-type="info"></div>
            <div class="info-pills">
              <div id="info-meta-pill" class="info-pill" title=""></div>
              <div id="info-selection-pill" class="info-pill" title=""></div>
            </div>
            <details id="info-details" class="info-details">
              <summary class="info-summary">More</summary>
              <div id="info-meta" class="info-line"></div>
              <div id="info-selection" class="info-line"></div>
            </details>
            <div id="info-hover" class="info-hint" hidden></div>
          </div>
        </section>

        <div class="splitter splitter-h" id="split-info-debug" title="Drag to resize debug height"></div>

        <section id="debug-panel" class="card panel debug-panel" hidden>
          <div class="debug-head">
            <div class="debug-title">DnD Debug</div>
            <div class="debug-actions">
              <button id="debug-clear" type="button" class="ghost">Clear</button>
              <button id="debug-copy" type="button" class="ghost">Copy</button>
            </div>
          </div>
          <pre id="debug-log" class="debug-log"></pre>
        </section>
      </div>
    </div>
  </div>

  <script>
    let els = {};
    let stateTree = [];
    let sourceTree = [];
    let sourceView = 'list';
    let sourceCollapsed = new Set();
    let selectedId = '';
    let selectedIds = new Set();
    let selectionAnchorId = '';
    let selectionParentKey = '';
    let draggedId = '';
    let draggedIds = [];
    let dropHint = { mode: null, targetId: null };
    let dropLineEl = null;
    let debugEnabled = false;
    let debugLog = [];
    let lastDropHintSignature = '';
    let lastDragoverLogAt = 0;
    let historyPast = [];
    let historyFuture = [];
    let lastPersistedSignature = '';
    let treeCollapsed = new Set();
	    let treeMaxLevel = 'n';
	    let toolTipEl = null;
	    let activeInlineEdit = null;
	    let showTools = false;
	    let showSource = false;
	    let showTree = true;
	    let showInfo = false;

    document.addEventListener('DOMContentLoaded', () => {
	      els = {
	        meta: document.getElementById('meta'),
	        status: document.getElementById('status'),
	        source: document.getElementById('source'),
	        tree: document.getElementById('tree'),
	        workspace: document.getElementById('workspace'),
	        panelTools: document.getElementById('panel-tools'),
	        panelSource: document.getElementById('panel-source'),
	        panelTree: document.getElementById('panel-tree'),
	        panelInfo: document.getElementById('panel-info'),
	        bottomStack: document.getElementById('bottom-stack'),
        infoMeta: document.getElementById('info-meta'),
        infoMetaPill: document.getElementById('info-meta-pill'),
        infoHover: document.getElementById('info-hover'),
        infoSelection: document.getElementById('info-selection'),
        infoSelectionPill: document.getElementById('info-selection-pill'),
        infoDetails: document.getElementById('info-details'),
        sourceViewBtn: document.getElementById('source-view-btn'),
        newFolderBtn: document.getElementById('new-folder-btn'),
        newPageBtn: document.getElementById('new-page-btn'),
        deleteBtn: document.getElementById('delete-btn'),
        toolUndoBtn: document.getElementById('tool-undo'),
        toolRedoBtn: document.getElementById('tool-redo'),
        toolReloadBtn: document.getElementById('tool-reload'),
        toolImportBtn: document.getElementById('tool-import'),
        toolSaveBtn: document.getElementById('tool-save'),
        toolSyncNavBtn: document.getElementById('tool-sync-nav'),
        toolSyncFilesBtn: document.getElementById('tool-sync-files'),
        toolDebugBtn: document.getElementById('tool-debug'),
        debugPanel: document.getElementById('debug-panel'),
        debugLog: document.getElementById('debug-log'),
        debugClear: document.getElementById('debug-clear'),
        debugCopy: document.getElementById('debug-copy'),
	        splitMainLeft: document.getElementById('split-main-left'),
	        splitBottom: document.getElementById('split-bottom'),
	        splitInfoDebug: document.getElementById('split-info-debug'),
	        splitTools: document.getElementById('split-tools'),
	        toggleTools: document.getElementById('toggle-tools'),
	        toggleSource: document.getElementById('toggle-source'),
	        toggleTree: document.getElementById('toggle-tree'),
	        toggleInfo: document.getElementById('toggle-info'),
	      };

      els.toolImportBtn.addEventListener('click', importFromMkdocs);
      els.toolSaveBtn.addEventListener('click', saveTreeOnly);
      els.toolSyncNavBtn.addEventListener('click', () => sync('nav_only'));
      els.toolSyncFilesBtn.addEventListener('click', () => sync('sync_files'));

      els.newFolderBtn.addEventListener('click', () => createNode('folder'));
      els.newPageBtn.addEventListener('click', () => createNode('page'));
      els.deleteBtn.addEventListener('click', deleteSelected);
      els.toolUndoBtn.addEventListener('click', undo);
      els.toolRedoBtn.addEventListener('click', redo);
      els.toolReloadBtn.addEventListener('click', reloadFromDisk);

      els.toolDebugBtn.addEventListener('click', toggleDebug);
      els.debugClear.addEventListener('click', () => {
        debugLog = [];
        renderDebug();
      });
      els.debugCopy.addEventListener('click', () => {
        const text = (debugLog || []).join('\n');
        copyToClipboard(text);
        setStatus('Debug log copied.', 'info');
      });

      sourceView = localStorage.getItem('page_tree_source_view') || 'list';
      sourceCollapsed = new Set(JSON.parse(localStorage.getItem('page_tree_source_collapsed') || '[]'));
      els.sourceViewBtn.addEventListener('click', toggleSourceView);
      updateSourceViewButton();
      treeCollapsed = new Set(JSON.parse(localStorage.getItem('page_tree_tree_collapsed') || '[]'));
      treeMaxLevel = localStorage.getItem('page_tree_tree_max_level') || 'n';
      bindDepthButtons();
      updateDepthButtons();

      // Unified DnD handlers on the tree container (mouse-position detector).
      els.tree.addEventListener('dragover', onTreeDragOver);
      els.tree.addEventListener('drop', onTreeDrop);
      els.tree.addEventListener('dragleave', onTreeDragLeave);
      dropLineEl = document.createElement('div');
      dropLineEl.className = 'drop-line';
      els.tree.appendChild(dropLineEl);
      hideDropLine();

      // Default: hidden each session.
      debugEnabled = false;
      debugLog = [];
      if (els.debugPanel) els.debugPanel.hidden = true;
      updateDebugVisibility();

	      initSplitters();
	      bindToolHoverHints();

	      // Default hidden: Tools/Source/Info (user can toggle).
	      showTools = localStorage.getItem('page_tree_show_tools') === 'true';
	      showSource = localStorage.getItem('page_tree_show_source') === 'true';
	      showTree = localStorage.getItem('page_tree_show_tree') !== 'false';
	      showInfo = localStorage.getItem('page_tree_show_info') === 'true';
	      applyPanelVisibility();

	      if (els.toggleTools) els.toggleTools.addEventListener('click', () => {
	        showTools = !showTools;
	        localStorage.setItem('page_tree_show_tools', String(showTools));
	        applyPanelVisibility();
	      });
	      if (els.toggleSource) els.toggleSource.addEventListener('click', () => {
	        showSource = !showSource;
	        localStorage.setItem('page_tree_show_source', String(showSource));
	        applyPanelVisibility();
	      });
	      if (els.toggleTree) els.toggleTree.addEventListener('click', () => {
	        showTree = !showTree;
	        localStorage.setItem('page_tree_show_tree', String(showTree));
	        applyPanelVisibility();
	      });
	      if (els.toggleInfo) els.toggleInfo.addEventListener('click', () => {
	        showInfo = !showInfo;
	        localStorage.setItem('page_tree_show_info', String(showInfo));
	        applyPanelVisibility();
	      });

	      window.addEventListener('keydown', (e) => {
	        if (activeInlineEdit) return;
	        if (e.key === 'Escape') {
          clearSelection();
        }
      });

      loadMeta();
      loadState();
	      loadSource();
	    });

	    function applyPanelVisibility() {
	      if (els.panelTools) els.panelTools.hidden = !showTools;
	      if (els.panelSource) els.panelSource.hidden = !showSource;
	      if (els.panelTree) els.panelTree.hidden = !showTree;
	      if (els.panelInfo) els.panelInfo.hidden = !showInfo;
	      if (els.splitMainLeft) els.splitMainLeft.style.display = (showSource && showTree) ? '' : 'none';
	      if (els.splitBottom) els.splitBottom.style.display = showInfo ? '' : 'none';
	      if (els.bottomStack) els.bottomStack.hidden = !showInfo;

	      if (els.workspace) {
	        els.workspace.classList.toggle('no-tools', !showTools);
	        els.workspace.classList.toggle('no-source', !showSource);
	        els.workspace.classList.toggle('no-tree', !showTree);
	        els.workspace.classList.toggle('no-bottom', !showInfo);
	        const singleMain = (showSource ? 1 : 0) + (showTree ? 1 : 0) === 1;
	        els.workspace.classList.toggle('single-main', singleMain);
	      }

	      if (els.toggleTools) els.toggleTools.classList.toggle('active', showTools);
	      if (els.toggleSource) els.toggleSource.classList.toggle('active', showSource);
	      if (els.toggleTree) els.toggleTree.classList.toggle('active', showTree);
	      if (els.toggleInfo) els.toggleInfo.classList.toggle('active', showInfo);
	    }

    function bindToolHoverHints() {
      toolTipEl = document.getElementById('tool-tooltip');
      const buttons = document.querySelectorAll('[data-help]');
      buttons.forEach(btn => {
        btn.addEventListener('mouseenter', (e) => {
          const text = btn.dataset.help || '';
          setInfoHover(text);
          showToolTip(text, e);
        });
        btn.addEventListener('mousemove', (e) => {
          moveToolTip(e);
        });
        btn.addEventListener('mouseleave', () => {
          setInfoHover('');
          hideToolTip();
        });
      });
    }

    function showToolTip(text, e) {
      if (!toolTipEl) return;
      const value = (text || '').trim();
      if (!value) return;
      toolTipEl.textContent = value;
      toolTipEl.hidden = false;
      moveToolTip(e);
    }

    function moveToolTip(e) {
      if (!toolTipEl || toolTipEl.hidden) return;
      const pad = 12;
      const maxLeft = window.innerWidth - toolTipEl.offsetWidth - pad;
      const maxTop = window.innerHeight - toolTipEl.offsetHeight - pad;
      const left = Math.min(e.clientX + pad, Math.max(pad, maxLeft));
      const top = Math.min(e.clientY + pad, Math.max(pad, maxTop));
      toolTipEl.style.left = `${left}px`;
      toolTipEl.style.top = `${top}px`;
    }

    function hideToolTip() {
      if (!toolTipEl) return;
      toolTipEl.hidden = true;
      toolTipEl.textContent = '';
    }

    function toggleSourceView() {
      sourceView = sourceView === 'ascii' ? 'list' : 'ascii';
      localStorage.setItem('page_tree_source_view', sourceView);
      updateSourceViewButton();
      renderSource();
    }

    function bindDepthButtons() {
      const buttons = document.querySelectorAll('.depth-btn');
      buttons.forEach(btn => {
        btn.addEventListener('click', () => {
          treeMaxLevel = btn.dataset.depth || 'n';
          localStorage.setItem('page_tree_tree_max_level', treeMaxLevel);
          updateDepthButtons();
          renderTree();
        });
      });
    }

    function updateDepthButtons() {
      const buttons = document.querySelectorAll('.depth-btn');
      buttons.forEach(btn => {
        btn.classList.toggle('active', (btn.dataset.depth || '') === String(treeMaxLevel));
      });
    }

    function maxLevelValue() {
      if (treeMaxLevel === 'n') return Number.POSITIVE_INFINITY;
      const n = parseInt(String(treeMaxLevel), 10);
      return Number.isFinite(n) && n > 0 ? n : Number.POSITIVE_INFINITY;
    }

    function updateSourceViewButton() {
      if (!els.sourceViewBtn) return;
      els.sourceViewBtn.classList.toggle('active', sourceView === 'ascii');
      // Show the view you can switch to.
      els.sourceViewBtn.textContent = sourceView === 'ascii' ? 'ğŸ—‚ Explorer' : 'ğŸ§¾ ASCII';
    }

    function deepClone(value) {
      return JSON.parse(JSON.stringify(value));
    }

    function treeSignature(tree) {
      try {
        return JSON.stringify(tree || []);
      } catch (e) {
        return String(Date.now());
      }
    }

    function isDirty() {
      return treeSignature(stateTree) !== lastPersistedSignature;
    }

    function updateHistoryButtons() {
      if (els.toolUndoBtn) els.toolUndoBtn.disabled = historyPast.length === 0;
      if (els.toolRedoBtn) els.toolRedoBtn.disabled = historyFuture.length === 0;
    }

    function resetHistory() {
      historyPast = [];
      historyFuture = [];
      updateHistoryButtons();
    }

    function pushHistorySnapshot(snapshot) {
      historyPast.push(snapshot);
      if (historyPast.length > 60) historyPast.shift();
      historyFuture = [];
      updateHistoryButtons();
    }

    function withHistory(label, mutator) {
      const before = deepClone(stateTree);
      pushHistorySnapshot(before);
      mutator();
      pushDebug('history.commit', { label });
    }

    function undo() {
      if (!historyPast.length) {
        setStatus('Nothing to undo.', 'info');
        return;
      }
      const current = deepClone(stateTree);
      const previous = historyPast.pop();
      historyFuture.push(current);
      stateTree = deepClone(previous);
      ensureSelectedValid();
      renderTree();
      updateHistoryButtons();
      pushDebug('history.undo', {});
      setStatus('Undid last action.', 'success');
    }

    function redo() {
      if (!historyFuture.length) {
        setStatus('Nothing to redo.', 'info');
        return;
      }
      const current = deepClone(stateTree);
      const next = historyFuture.pop();
      historyPast.push(current);
      stateTree = deepClone(next);
      ensureSelectedValid();
      renderTree();
      updateHistoryButtons();
      pushDebug('history.redo', {});
      setStatus('Redid last action.', 'success');
    }

    async function reloadFromDisk() {
      if (isDirty()) {
        const ok = confirm('You have unsaved changes in the editor. Reload anyway?');
        if (!ok) return;
      }
      setStatus('Reloading...', 'info');
      pushDebug('reload.click', {});
      await loadState({ reset: true });
      await loadSource();
      setStatus('Reloaded.', 'success');
    }

    function toggleDebug() {
      debugEnabled = !debugEnabled;
      updateDebugVisibility();
      pushDebug('debug.toggle', { enabled: debugEnabled });
    }

    function updateDebugVisibility() {
      if (!els.debugPanel) return;
      els.debugPanel.hidden = !debugEnabled;
      if (els.splitInfoDebug) els.splitInfoDebug.style.display = debugEnabled ? '' : 'none';
      if (els.bottomStack) els.bottomStack.classList.toggle('debug-hidden', !debugEnabled);
      if (els.toolDebugBtn) els.toolDebugBtn.classList.toggle('active', debugEnabled);
      renderDebug();
    }

    function renderDebug() {
      if (!debugEnabled) return;
      const lines = (debugLog || []).slice(-300);
      els.debugLog.textContent = lines.join('\n');
      // Always keep the latest line visible.
      requestAnimationFrame(() => {
        els.debugLog.scrollTop = els.debugLog.scrollHeight;
      });
    }

    function pushDebug(tag, payload) {
      if (!debugEnabled) return;
      const ts = new Date().toISOString().slice(11, 23);
      let detail = '';
      try {
        detail = payload === undefined ? '' : ' ' + JSON.stringify(payload);
      } catch (e) {
        detail = ' ' + String(payload);
      }
      debugLog.push(`[${ts}] ${tag}${detail}`);
      if (debugLog.length > 800) debugLog = debugLog.slice(-800);
      renderDebug();
    }

    async function copyToClipboard(text) {
      try {
        await navigator.clipboard.writeText(text);
      } catch (e) {
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position = 'fixed';
        ta.style.left = '-9999px';
        document.body.appendChild(ta);
        ta.focus();
        ta.select();
        document.execCommand('copy');
        ta.remove();
      }
    }

    function initSplitters() {
      if (!els.workspace) return;

      const defaults = {
        left: 360,
        bottom: 180,
        debug: 180,
        toolsLeft: 520,
      };

      const readNum = (key, fallback) => {
        const raw = localStorage.getItem(key);
        const n = raw ? parseFloat(raw) : NaN;
        return Number.isFinite(n) ? n : fallback;
      };

      const clampNum = (v, min, max) => Math.min(Math.max(v, min), max);
      const left = clampNum(readNum('page_tree_layout_left', defaults.left), 240, 820);
      const bottom = clampNum(readNum('page_tree_layout_bottom', defaults.bottom), 120, 360);
      const debugHeight = clampNum(readNum('page_tree_layout_debug', defaults.debug), 120, 360);
      const toolsLeft = clampNum(readNum('page_tree_layout_tools_left', defaults.toolsLeft), 320, 920);

      els.workspace.style.setProperty('--left-width', `${left}px`);
      els.workspace.style.setProperty('--bottom-height', `${bottom}px`);
      els.workspace.style.setProperty('--debug-height', `${debugHeight}px`);
      els.workspace.style.setProperty('--tools-left-width', `${toolsLeft}px`);

      const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
      let drag = null;

      const onMove = (e) => {
        if (!drag) return;
        const x = e.clientX;
        const y = e.clientY;

        if (drag.kind === 'left') {
          const width = clamp(x - drag.rect.left, 240, drag.max);
          els.workspace.style.setProperty('--left-width', `${width}px`);
          return;
        }
        if (drag.kind === 'bottom') {
          const height = clamp(drag.bottom - y, 120, drag.max);
          els.workspace.style.setProperty('--bottom-height', `${height}px`);
          return;
        }
        if (drag.kind === 'debug') {
          const height = clamp(drag.bottom - y, 120, drag.max);
          els.workspace.style.setProperty('--debug-height', `${height}px`);
          return;
        }
        if (drag.kind === 'tools') {
          const width = clamp(x - drag.left, 320, drag.max);
          els.workspace.style.setProperty('--tools-left-width', `${width}px`);
        }
      };

      const onUp = () => {
        if (!drag) return;
        const style = getComputedStyle(els.workspace);
        localStorage.setItem('page_tree_layout_left', parseFloat(style.getPropertyValue('--left-width')) || defaults.left);
        localStorage.setItem('page_tree_layout_bottom', parseFloat(style.getPropertyValue('--bottom-height')) || defaults.bottom);
        localStorage.setItem('page_tree_layout_debug', parseFloat(style.getPropertyValue('--debug-height')) || defaults.debug);
        localStorage.setItem('page_tree_layout_tools_left', parseFloat(style.getPropertyValue('--tools-left-width')) || defaults.toolsLeft);
        drag = null;
        document.body.classList.remove('is-resizing');
        window.removeEventListener('pointermove', onMove);
        window.removeEventListener('pointerup', onUp);
      };

      const start = (kind) => (e) => {
        e.preventDefault();
        if (kind === 'left') {
          const rect = els.workspace.querySelector('.main-grid').getBoundingClientRect();
          drag = { kind, rect, max: Math.max(240, rect.width - 520) };
        } else if (kind === 'bottom') {
          const rect = els.workspace.getBoundingClientRect();
          drag = { kind, bottom: rect.bottom, max: Math.max(120, rect.height - 320) };
        } else if (kind === 'debug') {
          const rect = els.bottomStack.getBoundingClientRect();
          drag = { kind, bottom: rect.bottom, max: Math.max(120, rect.height - 120) };
        } else if (kind === 'tools') {
          const panel = document.getElementById('panel-tools');
          const rect = panel ? panel.getBoundingClientRect() : els.workspace.getBoundingClientRect();
          drag = { kind, left: rect.left, max: Math.max(320, rect.width - 360) };
        } else {
          drag = { kind };
        }
        document.body.classList.add('is-resizing');
        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onUp);
      };

      if (els.splitMainLeft) els.splitMainLeft.addEventListener('pointerdown', start('left'));
      if (els.splitBottom) els.splitBottom.addEventListener('pointerdown', start('bottom'));
      if (els.splitInfoDebug) els.splitInfoDebug.addEventListener('pointerdown', start('debug'));
      if (els.splitTools) els.splitTools.addEventListener('pointerdown', start('tools'));
    }

    async function fetchJson(url, options) {
      const response = await fetch(url, options);
      const text = await response.text();
      let data = null;
      try { data = text ? JSON.parse(text) : null; } catch (e) { data = null; }
      if (!response.ok) {
        const msg = data && typeof data.error === 'string' ? data.error : 'Request failed.';
        throw new Error(msg);
      }
      return data;
    }

    function setStatus(message, type) {
      els.status.textContent = message || '';
      els.status.dataset.type = type || 'info';
    }

    function setInfoMeta(text) {
      const value = (text || '').trim();
      if (els.infoMeta) els.infoMeta.textContent = value;
      if (els.infoMetaPill) {
        els.infoMetaPill.textContent = shortenPathLine(value);
        els.infoMetaPill.title = value;
      }
    }

    function setInfoSelection(text) {
      const value = (text || '').trim();
      if (els.infoSelection) els.infoSelection.textContent = value;
      if (els.infoSelectionPill) {
        const short = value.replace(/^Selection:\\s*/i, '') || 'Selection: (none)';
        els.infoSelectionPill.textContent = short;
        els.infoSelectionPill.title = value;
      }
    }

    function setInfoHover(text) {
      if (!els.infoHover) return;
      const value = (text || '').trim();
      if (!value) {
        els.infoHover.hidden = true;
        els.infoHover.textContent = '';
        return;
      }
      els.infoHover.hidden = false;
      els.infoHover.textContent = value;
    }

    function shortenPathLine(line) {
      if (!line) return '';
      const parts = line.split('|').map(s => s.trim()).filter(Boolean);
      if (parts.length < 2) return line;
      const mk = parts[0].replace(/\\\\/g, '/').split('/').pop() || parts[0];
      const docs = parts[1].replace(/\\\\/g, '/').split('/').pop() || parts[1];
      return `${mk} â€¢ ${docs}`;
    }

    function findNode(nodes, id, parent = null) {
      for (const node of (nodes || [])) {
        if (node.id === id) return { node, parent, siblings: nodes };
        if (node.type === 'folder' && Array.isArray(node.children)) {
          const found = findNode(node.children, id, node);
          if (found) return found;
        }
      }
      return null;
    }

    function ensureSelectedValid() {
      if (selectedIds && selectedIds.size) {
        const next = new Set();
        for (const id of selectedIds) {
          if (findNode(stateTree, id)) next.add(id);
        }
        selectedIds = next;
      }
      if (selectedId && !findNode(stateTree, selectedId)) selectedId = '';
      if (selectedId && selectedIds && selectedIds.size && !selectedIds.has(selectedId)) {
        selectedId = Array.from(selectedIds)[0] || '';
      }
      if (!selectedId && selectedIds && selectedIds.size) selectedId = Array.from(selectedIds)[0] || '';
    }

    async function loadMeta() {
      try {
        const data = await fetchJson('/api/meta');
        const text = `${data.mkdocs_path} | ${data.docs_root}`;
        els.meta.textContent = shortenPathLine(text);
        els.meta.title = text;
        setInfoMeta(text);
      } catch (e) {
        els.meta.textContent = '(meta unavailable)';
        setInfoMeta('(meta unavailable)');
      }
    }

    async function loadState(options) {
      const reset = options && options.reset;
      setStatus('Loading tree...', 'info');
      try {
        const data = await fetchJson('/api/state');
        stateTree = Array.isArray(data.tree) ? data.tree : [];
        lastPersistedSignature = treeSignature(stateTree);
        if (reset) resetHistory();
        ensureSelectedValid();
        renderTree();
        updateHistoryButtons();
        setStatus('Tree loaded.', 'success');
      } catch (e) {
        els.tree.textContent = 'Failed to load tree.';
        setStatus(e.message || 'Failed to load tree.', 'error');
      }
    }

    async function loadSource() {
      try {
        const data = await fetchJson('/api/source');
        sourceTree = Array.isArray(data) ? data : [];
        renderSource();
      } catch (e) {
        els.source.textContent = 'Failed to load source.';
      }
    }

    async function importFromMkdocs() {
      if (!confirm('Import will overwrite current tree state. Continue?')) return;
      setStatus('Importing...', 'info');
      try {
        const data = await fetchJson('/api/import', { method: 'POST' });
        stateTree = Array.isArray(data.tree) ? data.tree : [];
        lastPersistedSignature = treeSignature(stateTree);
        resetHistory();
        selectedId = '';
        renderTree();
        updateHistoryButtons();
        setStatus('Imported from mkdocs.yml.', 'success');
      } catch (e) {
        setStatus(e.message || 'Import failed.', 'error');
      }
    }

    async function saveTreeOnly() {
      setStatus('Saving tree...', 'info');
      try {
        await fetchJson('/api/state', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ tree: stateTree })
        });
        lastPersistedSignature = treeSignature(stateTree);
        setStatus('Draft saved.', 'success');
      } catch (e) {
        setStatus(e.message || 'Save failed.', 'error');
      }
    }

    async function sync(mode) {
      const msg = mode === 'sync_files'
        ? 'This will move .md files (and sibling asset folders) on disk. Continue?'
        : 'This will write mkdocs.yml nav. Continue?';
      if (!confirm(msg)) return;
      setStatus('Syncing...', 'info');
      try {
        const data = await fetchJson('/api/sync', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ mode, tree: stateTree })
        });
        const moves = Array.isArray(data.moves) ? data.moves : [];
        const warnings = Array.isArray(data.warnings) ? data.warnings : [];
        const extra = moves.length ? ` moved:${moves.length}` : '';
        const warn = warnings.length ? ` warnings:${warnings.length}` : '';
        setStatus(`Sync ok.${extra}${warn}`, warnings.length ? 'info' : 'success');
        await loadState({ reset: true });
        await loadSource();
        lastPersistedSignature = treeSignature(stateTree);
      } catch (e) {
        setStatus(e.message || 'Sync failed.', 'error');
      }
    }

    function renderSource() {
      els.source.innerHTML = '';
      if (!Array.isArray(sourceTree) || !sourceTree.length) {
        els.source.textContent = '(no markdown files found)';
        return;
      }
      els.source.appendChild(sourceView === 'ascii' ? buildSourceAscii(sourceTree) : buildSourceList(sourceTree));
    }

    function persistSourceCollapsed() {
      localStorage.setItem('page_tree_source_collapsed', JSON.stringify(Array.from(sourceCollapsed)));
    }

    function toggleSourceDir(path) {
      if (!path) return;
      if (sourceCollapsed.has(path)) sourceCollapsed.delete(path);
      else sourceCollapsed.add(path);
      persistSourceCollapsed();
      renderSource();
    }

    function buildSourceList(nodes, depth = 0) {
      const ul = document.createElement('ul');
      ul.className = depth === 0 ? 'source-explorer' : 'source-children';
      for (const node of (nodes || [])) {
        const li = document.createElement('li');
        li.className = 'source-item';
        li.dataset.kind = node.kind || '';
        li.dataset.path = node.path || '';

	        const row = document.createElement('div');
	        row.className = 'source-row ' + (node.kind === 'dir' ? 'kind-dir' : 'kind-file');
	        row.style.paddingLeft = `${8 + depth * 10}px`;
        row.title = node.path ? `./${node.path}` : '';

        const twist = document.createElement('span');
        twist.className = 'source-twist';
        const isDir = node.kind === 'dir';
        const isCollapsed = isDir && node.path && sourceCollapsed.has(node.path);
        twist.textContent = isDir ? (isCollapsed ? 'â–¸' : 'â–¾') : '';
        row.appendChild(twist);

        const icon = document.createElement('span');
        icon.className = 'source-icon';
        icon.textContent = isDir ? 'ğŸ“' : 'ğŸ“„';
        row.appendChild(icon);

        const name = document.createElement('span');
        name.className = 'source-name';
        name.textContent = node.name || '(unnamed)';
        row.appendChild(name);

        li.appendChild(row);

        if (node.kind === 'file') {
          row.classList.add('clickable');
          row.addEventListener('click', (e) => {
            e.stopPropagation();
            locateByFile(node.path || '');
          });
        } else if (node.kind === 'dir') {
          row.classList.add('clickable');
          row.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleSourceDir(node.path || '');
          });
        }

        if (node.kind === 'dir' && Array.isArray(node.children) && node.children.length) {
          const collapsed = node.path && sourceCollapsed.has(node.path);
          if (!collapsed) {
            li.appendChild(buildSourceList(node.children, depth + 1));
          }
        }
        ul.appendChild(li);
      }
      return ul;
    }

    function buildSourceAscii(nodes) {
      const container = document.createElement('div');
      container.className = 'source-ascii';
      const lines = [];

      function walk(items, prefixParts) {
        (items || []).forEach((node, index) => {
          const isLast = index === items.length - 1;
          const branch = isLast ? 'â””â”€â”€ ' : 'â”œâ”€â”€ ';
          const prefix = (prefixParts || []).join('') + branch;

          const line = document.createElement('div');
          line.className = 'source-line';

          const pre = document.createElement('span');
          pre.className = 'source-prefix';
          pre.textContent = prefix;
          line.appendChild(pre);

          const name = document.createElement('span');
          name.className = 'source-name ' + (node.kind === 'dir' ? 'kind-dir' : 'kind-file');
          const ext = node.kind === 'file' ? (String(node.name || '').split('.').pop() || '').toLowerCase() : '';
          if (ext) name.dataset.ext = ext;
          name.textContent = node.name || '(unnamed)';
          line.appendChild(name);

          if (node.kind === 'file' && node.path) {
            line.classList.add('clickable');
            line.addEventListener('click', (e) => {
              e.stopPropagation();
              locateByFile(node.path || '');
            });
          }

          lines.push(line);

          const nextPrefixParts = (prefixParts || []).slice();
          nextPrefixParts.push(isLast ? '    ' : 'â”‚   ');
          if (Array.isArray(node.children) && node.children.length) {
            walk(node.children, nextPrefixParts);
          }
        });
      }

      walk(nodes || [], []);
      lines.forEach(l => container.appendChild(l));
      return container;
    }

    function locateByFile(file) {
      const normalized = normalizePath(file);
      if (!normalized) return;
      const all = Array.from(document.querySelectorAll('#tree li[data-file]'));
      all.forEach(el => el.classList.remove('flash'));
      const hit = all.find(el => normalizePath(el.dataset.file || '') === normalized);
      if (!hit) {
        setStatus('Not found in tree.', 'info');
        return;
      }
      hit.classList.add('flash');
      hit.scrollIntoView({ behavior: 'smooth', block: 'center' });
      setTimeout(() => hit.classList.remove('flash'), 900);
    }

    function normalizePath(path) {
      return (path || '').trim().replace(/^\.\//, '').replace(/\\/g, '/').replace(/\/+/g, '/').toLowerCase();
    }

    function renderTree() {
      els.tree.innerHTML = '';
      dropLineEl = dropLineEl || document.createElement('div');
      dropLineEl.className = 'drop-line';
      const list = buildTreeList(Array.isArray(stateTree) ? stateTree : [], true, 0);
      els.tree.appendChild(list);
      els.tree.appendChild(dropLineEl);
      hideDropLine();
      updateSelectionInfo();
      if (!stateTree.length) {
        const hint = document.createElement('div');
        hint.className = 'empty-hint';
        hint.textContent = '(empty)';
        els.tree.appendChild(hint);
      }
    }

    function updateSelectionInfo() {
      if (selectedIds && selectedIds.size > 1) {
        setInfoSelection(`Selection: ${selectedIds.size} items`);
        return;
      }
      if (!selectedId) {
        setInfoSelection('Selection: (none)');
        return;
      }
      const found = findNode(stateTree, selectedId);
      if (!found) {
        setInfoSelection('Selection: (none)');
        return;
      }
      const kind = found.node.type === 'folder' ? 'section' : 'page';
      const file = found.node.file ? ` | file: ./${found.node.file}` : '';
      const segment = found.node.segment ? ` | dir: ${found.node.segment}` : '';
      setInfoSelection(`Selection: ${kind} | ${found.node.title}${segment}${file}`);
    }

    function selectNode(id) {
      selectedId = id || '';
      selectedIds = new Set(selectedId ? [selectedId] : []);
      selectionAnchorId = selectedId;
      selectionParentKey = selectionKeyForId(selectedId);
      syncSelectionClasses();
    }

    function clearSelection() {
      selectedId = '';
      selectedIds = new Set();
      selectionAnchorId = '';
      selectionParentKey = '';
      syncSelectionClasses();
    }

    function selectionKeyForId(id) {
      if (!id) return '';
      const info = findNode(stateTree, id);
      if (!info) return '';
      return info.parent ? `p:${info.parent.id}` : 'root';
    }

    function syncSelectionClasses() {
      document.querySelectorAll('#tree li.node.selected').forEach(el => el.classList.remove('selected'));
      for (const id of (selectedIds || [])) {
        const el = document.querySelector(`#tree li.node[data-id="${CSS.escape(id)}"]`);
        if (el) el.classList.add('selected');
      }
      updateSelectionInfo();
    }

    function selectWithModifiers(id, e) {
      const isMeta = !!(e && (e.metaKey || e.ctrlKey));
      const isShift = !!(e && e.shiftKey);
      const key = selectionKeyForId(id);
      if (!id) return;

      // First selection.
      if (!selectedIds || selectedIds.size === 0) {
        selectedId = id;
        selectedIds = new Set([id]);
        selectionAnchorId = id;
        selectionParentKey = key;
        syncSelectionClasses();
        return;
      }

      // Restrict multi-select to the same parent (same siblings list).
      if (selectionParentKey && key && selectionParentKey !== key) {
        selectedId = id;
        selectedIds = new Set([id]);
        selectionAnchorId = id;
        selectionParentKey = key;
        syncSelectionClasses();
        return;
      }

      if (isShift && selectionAnchorId) {
        const anchorInfo = findNode(stateTree, selectionAnchorId);
        const targetInfo = findNode(stateTree, id);
        if (!anchorInfo || !targetInfo) return;
        const sameParent = (anchorInfo.parent ? anchorInfo.parent.id : 'root') === (targetInfo.parent ? targetInfo.parent.id : 'root');
        if (!sameParent) {
          selectedId = id;
          selectedIds = new Set([id]);
          selectionAnchorId = id;
          selectionParentKey = key;
          syncSelectionClasses();
          return;
        }
        const siblings = anchorInfo.siblings || [];
        const a = siblings.findIndex(n => n.id === selectionAnchorId);
        const b = siblings.findIndex(n => n.id === id);
        if (a < 0 || b < 0) return;
        const lo = Math.min(a, b);
        const hi = Math.max(a, b);
        const next = new Set();
        for (let i = lo; i <= hi; i++) next.add(siblings[i].id);
        selectedIds = next;
        selectedId = id;
        selectionParentKey = key;
        syncSelectionClasses();
        return;
      }

      if (isMeta) {
        const next = new Set(selectedIds || []);
        if (next.has(id)) next.delete(id);
        else next.add(id);
        selectedIds = next;
        selectedId = id;
        selectionAnchorId = id;
        selectionParentKey = key;
        if (!selectedIds.size) {
          selectedId = '';
          selectionAnchorId = '';
          selectionParentKey = '';
        }
        syncSelectionClasses();
        return;
      }

      // Plain click: single select.
      selectedId = id;
      selectedIds = new Set([id]);
      selectionAnchorId = id;
      selectionParentKey = key;
      syncSelectionClasses();
    }

    function persistTreeCollapsed() {
      localStorage.setItem('page_tree_tree_collapsed', JSON.stringify(Array.from(treeCollapsed)));
    }

    function toggleTreeDir(id) {
      if (!id) return;
      if (treeCollapsed.has(id)) treeCollapsed.delete(id);
      else treeCollapsed.add(id);
      persistTreeCollapsed();
      renderTree();
    }

    function displayTitleForNode(node) {
      const title = String((node && node.title) || '').trim();
      if (!title) return '(untitled)';
      if (title.includes('/') || title.includes('\\')) {
        const parts = title.replace(/\\/g, '/').split('/');
        return parts[parts.length - 1] || title;
      }
      return title;
    }

    function buildTreeList(nodes, isRoot = false, depth = 0) {
      const ul = document.createElement('ul');
      ul.className = isRoot ? 'tree-root tree-explorer' : 'tree-children tree-explorer';
      for (const node of (nodes || [])) {
        const li = document.createElement('li');
        li.className = 'node tree-item ' + (node.type === 'folder' ? 'dir' : 'page');
        li.draggable = true;
        li.dataset.id = node.id || '';
        li.dataset.type = node.type || 'page';
        li.dataset.title = node.title || '';
        li.dataset.segment = node.segment || '';
        li.dataset.file = node.file || '';

        if ((selectedIds && selectedIds.has(li.dataset.id)) || li.dataset.id === selectedId) li.classList.add('selected');

		        const row = document.createElement('div');
		        row.className = 'row tree-row ' + (node.type === 'folder' ? 'kind-dir' : 'kind-file');
		        row.style.paddingLeft = `${10 + depth * 10}px`;
		        row.addEventListener('click', (e) => {
		          e.stopPropagation();
		          if (activeInlineEdit) return;
		          selectWithModifiers(li.dataset.id, e);
		        });

        const twist = document.createElement('span');
        twist.className = 'tree-twist';
        const isFolder = node.type === 'folder';
        const collapsed = isFolder && treeCollapsed.has(li.dataset.id);
        const allowedByDepth = (depth + 2) <= maxLevelValue();
        const canExpand = isFolder && allowedByDepth;
        twist.textContent = isFolder ? (collapsed ? 'â–¸' : 'â–¾') : '';
        twist.addEventListener('click', (e) => {
          e.stopPropagation();
          if (!isFolder) return;
          if (!canExpand) {
            setStatus(`Depth limited to ${treeMaxLevel === 'n' ? 'âˆ' : treeMaxLevel} levels.`, 'info');
            return;
          }
          toggleTreeDir(li.dataset.id);
        });
        row.appendChild(twist);

        const icon = document.createElement('span');
        icon.className = 'tree-icon';
        icon.textContent = isFolder ? 'ğŸ“š' : 'ğŸ“';
        row.appendChild(icon);

        const title = document.createElement('span');
        title.className = 'node-title';
        title.textContent = displayTitleForNode(node);
        title.addEventListener('dblclick', (e) => {
          e.stopPropagation();
          selectedId = li.dataset.id;
          beginInlineEdit(li.dataset.id, 'title', title);
        });
        row.appendChild(title);

        // Pages show file location; folders don't need to show "path/meta".
        const meta = document.createElement('span');
        meta.className = 'node-meta';
        if (isFolder) {
          meta.textContent = folderDirForId(li.dataset.id) || (node.segment ? `${node.segment}` : '');
          meta.addEventListener('dblclick', (e) => {
            e.stopPropagation();
            selectedId = li.dataset.id;
            beginInlineEdit(li.dataset.id, 'segment', meta);
          });
          row.appendChild(meta);
        } else {
          meta.textContent = node.file ? `./${node.file}` : '';
          meta.addEventListener('dblclick', (e) => {
            e.stopPropagation();
            selectedId = li.dataset.id;
            beginInlineEdit(li.dataset.id, 'file', meta);
          });
          row.appendChild(meta);
        }

        li.appendChild(row);

        li.addEventListener('dragstart', onDragStart);
        li.addEventListener('dragend', onDragEnd);

        if (node.type === 'folder') {
          const children = Array.isArray(node.children) ? node.children : [];
          const collapsed = treeCollapsed.has(li.dataset.id);
          if (!collapsed && canExpand) {
            li.appendChild(buildTreeList(children, false, depth + 1));
          } else {
            // Keep an empty children container so folder still shows as a folder
            // but without large nested blocks.
            const emptyUl = document.createElement('ul');
            emptyUl.className = 'tree-children tree-explorer is-collapsed';
            li.appendChild(emptyUl);
          }
        }
        ul.appendChild(li);
      }
      return ul;
    }

    function onDragStart(e) {
      // dragstart bubbles: prevent parent <li> handlers from overwriting draggedId
      e.stopPropagation();
      if (activeInlineEdit) {
        e.preventDefault();
        return;
      }
      if (e.currentTarget && e.currentTarget.classList && e.currentTarget.classList.contains('is-editing')) {
        e.preventDefault();
        return;
      }
      const id = e.currentTarget.dataset.id || '';
      if (selectedIds && selectedIds.size > 1 && selectedIds.has(id)) {
        draggedIds = Array.from(selectedIds);
      } else {
        draggedIds = id ? [id] : [];
        if (id && (!selectedIds || !selectedIds.has(id))) selectNode(id);
      }
      draggedId = draggedIds[0] || id || '';
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', draggedId);
      e.currentTarget.classList.add('dragging');
      pushDebug('drag.start', { draggedId, draggedIds, type: e.currentTarget.dataset.type || '', title: e.currentTarget.dataset.title || '' });
    }

    function onDragEnd(e) {
      // dragend bubbles too; keep state consistent
      e.stopPropagation();
      if (e && e.currentTarget) e.currentTarget.classList.remove('dragging');
      draggedId = '';
      draggedIds = [];
      clearDropVisual();
      pushDebug('drag.end', {});
    }

    function onTreeDragLeave(e) {
      if (!e) return;
      const related = e.relatedTarget;
      if (related && els.tree.contains(related)) {
        return;
      }
      clearDropVisual();
    }

    function onTreeDragOver(e) {
      if (!draggedId) return;
      e.preventDefault();
      updateDropHintFromPointer(e.clientX, e.clientY);
    }

    function onTreeDrop(e) {
      if (!draggedId) return;
      e.preventDefault();
      pushDebug('drop.before', { draggedId, dropHint });
      applyDrop();
      clearDropVisual();
      renderTree();
    }

    function updateDropHintFromPointer(clientX, clientY) {
      const el = document.elementFromPoint(clientX, clientY);
      if (!el) {
        dropHint = { mode: 'root', targetId: '' };
        showRootDrop();
        logDropHint('root', '');
        return;
      }

      const li = el.closest('#tree li.node');
      if (!li) {
        // Over whitespace: if inside a folder's children box, treat as inside; otherwise root.
        const ul = el.closest('#tree ul');
        const parentFolder = ul ? ul.closest('li[data-type="folder"]') : null;
        if (parentFolder) {
          const folderId = parentFolder.dataset.id || '';
          dropHint = { mode: 'inside', targetId: folderId };
          showInside(parentFolder);
          logDropHint('inside', folderId);
        } else {
          dropHint = { mode: 'root', targetId: '' };
          showRootDrop();
          logDropHint('root', '');
        }
        return;
      }

      const targetId = li.dataset.id || '';
      const type = li.dataset.type || 'page';
      const row = li.querySelector(':scope > .row') || li;
      const rowRect = row.getBoundingClientRect();
      const ratio = rowRect.height ? ((clientY - rowRect.top) / rowRect.height) : 0.5;

      const inChildrenBox = type === 'folder' && (() => {
        const childUl = li.querySelector(':scope > ul');
        return childUl && childUl.contains(el) && !row.contains(el);
      })();

      if (inChildrenBox) {
        dropHint = { mode: 'inside', targetId };
        showInside(li);
        logDropHint('inside', targetId);
        return;
      }

      let mode = 'inside';
      if (ratio <= 0.25) mode = 'before';
      else if (ratio >= 0.75) mode = 'after';
      if (type === 'page' && mode === 'inside') mode = ratio < 0.5 ? 'before' : 'after';

      dropHint = { mode, targetId };
      if (mode === 'inside') showInside(li);
      else showLineAt(rowRect, mode === 'after');
      logDropHint(mode, targetId);
    }

    function logDropHint(mode, targetId) {
      const sig = `${mode}::${targetId}::${draggedId}::${(draggedIds || []).join(',')}`;
      const now = Date.now();
      if (sig === lastDropHintSignature && now - lastDragoverLogAt < 120) return;
      lastDropHintSignature = sig;
      lastDragoverLogAt = now;
      const target = targetId ? findNode(stateTree, targetId) : null;
      pushDebug('drag.over', {
        draggedId,
        draggedIds,
        mode,
        targetId,
        targetTitle: target ? target.node.title : null,
        targetType: target ? target.node.type : null
      });
    }

    function applyDrop() {
      const { mode, targetId } = dropHint || {};
      if (!mode) return;

      // Never allow moving into/self/descendant; treat as no-op (keeps detector free).
      const ids = (draggedIds && draggedIds.length) ? draggedIds : (draggedId ? [draggedId] : []);
      const descendant = targetId ? ids.some(id => isDescendant(id, targetId)) : false;
      const selfHit = targetId ? ids.includes(targetId) : false;
      if (targetId && (selfHit || descendant)) {
        const dragged = findNode(stateTree, draggedId);
        const target = findNode(stateTree, targetId);
        pushDebug('drop.noop', {
          reason: selfHit ? 'self_or_group' : 'target_is_descendant',
          mode,
          draggedId,
          draggedIds: ids,
          draggedTitle: dragged ? dragged.node.title : null,
          draggedPath: nodePath(draggedId),
          targetId,
          targetTitle: target ? target.node.title : null,
          targetPath: nodePath(targetId),
        });
        setStatus(targetId === draggedId ? 'Invalid: dropped on itself.' : 'Invalid: cannot drop a parent into its child.', 'info');
        return;
      }

      if (mode === 'root') {
        pushDebug('drop.apply', { mode, targetId: '' });
        withHistory('drop.root', () => moveNodes(ids, '', 'root'));
        setStatus('Moved.', 'success');
        return;
      }
      if (mode === 'inside') {
        pushDebug('drop.apply', { mode, targetId });
        withHistory('drop.inside', () => moveNodes(ids, targetId, 'inside'));
        setStatus('Moved.', 'success');
        return;
      }
      if (mode === 'before' || mode === 'after') {
        pushDebug('drop.apply', { mode, targetId });
        withHistory(`drop.${mode}`, () => moveNodes(ids, targetId, mode));
        setStatus('Moved.', 'success');
      }
    }

    function moveNodes(ids, targetId, mode) {
      const list = Array.from(new Set((ids || []).filter(Boolean)));
      if (!list.length) return;

      if (mode === 'root') {
        const ctxs = detachManyWithContext(list);
        for (const ctx of ctxs) stateTree.push(ctx.node);
        return;
      }

      if (mode === 'inside') {
        const targetInfo = findNode(stateTree, targetId);
        if (!targetInfo || targetInfo.node.type !== 'folder') return;
        targetInfo.node.children = Array.isArray(targetInfo.node.children) ? targetInfo.node.children : [];
        const ctxs = detachManyWithContext(list);
        for (const ctx of ctxs) targetInfo.node.children.push(ctx.node);
        return;
      }

      if (mode === 'before' || mode === 'after') {
        // Detach first, then re-find target to get correct index after removal.
        const ctxs = detachManyWithContext(list);
        const targetInfo = findNode(stateTree, targetId);
        if (!targetInfo) return;
        const siblings = targetInfo.siblings;
        const idx = siblings.findIndex(n => n.id === targetId);
        if (idx < 0) return;
        let insertAt = mode === 'before' ? idx : idx + 1;
        for (const ctx of ctxs) {
          siblings.splice(insertAt, 0, ctx.node);
          insertAt += 1;
        }
      }
    }

    function isDescendant(dragId, targetId) {
      const drag = findNode(stateTree, dragId);
      const target = findNode(stateTree, targetId);
      if (!drag || !target) return false;
      let p = target.parent;
      while (p) {
        if (p.id === drag.node.id) return true;
        const parentInfo = findNode(stateTree, p.id);
        p = parentInfo ? parentInfo.parent : null;
      }
      return false;
    }

    function detachNode(id) {
      const found = findNode(stateTree, id);
      if (!found) return null;
      const idx = found.siblings.findIndex(n => n.id === id);
      if (idx < 0) return null;
      return found.siblings.splice(idx, 1)[0];
    }

    function detachNodeWithContext(id) {
      const found = findNode(stateTree, id);
      if (!found) return null;
      const idx = found.siblings.findIndex(n => n.id === id);
      if (idx < 0) return null;
      const node = found.siblings.splice(idx, 1)[0];
      return { node, siblings: found.siblings, index: idx };
    }

    function detachManyWithContext(ids) {
      const contexts = [];
      const byParent = new Map();
      for (const id of (ids || [])) {
        const found = findNode(stateTree, id);
        if (!found) continue;
        const idx = found.siblings.findIndex(n => n.id === id);
        if (idx < 0) continue;
        const parentKey = found.parent ? found.parent.id : 'root';
        if (!byParent.has(parentKey)) byParent.set(parentKey, []);
        byParent.get(parentKey).push({ id, siblings: found.siblings, index: idx });
      }

      // Detach in descending index per parent to keep indices valid.
      for (const group of byParent.values()) {
        group.sort((a, b) => b.index - a.index);
        for (const item of group) {
          const node = item.siblings.splice(item.index, 1)[0];
          contexts.push({ id: item.id, node, fromIndex: item.index });
        }
      }

      // Return in ascending original index order (stable visual order within parent).
      contexts.sort((a, b) => a.fromIndex - b.fromIndex);
      return contexts;
    }

    function nodePath(id) {
      if (!id) return [];
      const found = findNode(stateTree, id);
      if (!found) return [];
      const parts = [found.node.title || found.node.id];
      let p = found.parent;
      while (p) {
        parts.push(p.title || p.id);
        const parentInfo = findNode(stateTree, p.id);
        p = parentInfo ? parentInfo.parent : null;
      }
      return parts.reverse();
    }

    function restoreDetached(ctx) {
      if (!ctx || !ctx.node || !ctx.siblings) return;
      const idx = typeof ctx.index === 'number' ? ctx.index : ctx.siblings.length;
      ctx.siblings.splice(Math.min(Math.max(idx, 0), ctx.siblings.length), 0, ctx.node);
    }

    function moveNodeToRoot(id) {
      const ctx = detachNodeWithContext(id);
      if (!ctx) return;
      pushDebug('move.root', { id, title: ctx.node.title, fromIndex: ctx.index, fromPath: nodePath(id) });
      stateTree.push(ctx.node);
      pushDebug('move.root.done', { rootCount: stateTree.length });
    }

    function moveIntoFolder(dragId, folderId) {
      const folder = findNode(stateTree, folderId);
      if (!folder || folder.node.type !== 'folder') return;
      const ctx = detachNodeWithContext(dragId);
      if (!ctx) return;
      folder.node.children = Array.isArray(folder.node.children) ? folder.node.children : [];
      pushDebug('move.inside', {
        dragId,
        folderId,
        fromPath: nodePath(dragId),
        toPath: nodePath(folderId),
        insertIndex: folder.node.children.length
      });
      folder.node.children.push(ctx.node);
    }

    function moveNode(dragId, targetId, mode) {
      const targetInfo = findNode(stateTree, targetId);
      if (!targetInfo) return;
      const ctx = detachNodeWithContext(dragId);
      if (!ctx) return;

      if (mode === 'inside' && targetInfo.node.type === 'folder') {
        targetInfo.node.children = Array.isArray(targetInfo.node.children) ? targetInfo.node.children : [];
        targetInfo.node.children.push(ctx.node);
        return;
      }
      const siblings = targetInfo.siblings;
      const idx = siblings.findIndex(n => n.id === targetId);
      if (idx < 0) {
        pushDebug('move.restore', { reason: 'target_missing', dragId, targetId });
        restoreDetached(ctx);
        return;
      }
      pushDebug('move.sibling', {
        dragId,
        targetId,
        mode,
        targetIndex: idx,
        insertIndex: mode === 'before' ? idx : idx + 1,
        toParent: targetInfo.parent ? (targetInfo.parent.title || targetInfo.parent.id) : null
      });
      siblings.splice(mode === 'before' ? idx : idx + 1, 0, ctx.node);
    }

    function clearDropVisual() {
      dropHint = { mode: null, targetId: null };
      els.tree.classList.remove('drop-root');
      hideDropLine();
      document.querySelectorAll('#tree .drop-before, #tree .drop-after, #tree .drop-inside')
        .forEach(el => el.classList.remove('drop-before', 'drop-after', 'drop-inside'));
    }

    function hideDropLine() {
      if (!dropLineEl) return;
      dropLineEl.style.display = 'none';
    }

    function showRootDrop() {
      els.tree.classList.add('drop-root');
      hideDropLine();
      document.querySelectorAll('#tree .drop-inside').forEach(el => el.classList.remove('drop-inside'));
    }

    function showInside(li) {
      els.tree.classList.remove('drop-root');
      hideDropLine();
      document.querySelectorAll('#tree .drop-inside').forEach(el => el.classList.remove('drop-inside'));
      if (li) li.classList.add('drop-inside');
    }

    function showLineAt(targetRect, placeAfter) {
      els.tree.classList.remove('drop-root');
      document.querySelectorAll('#tree .drop-inside').forEach(el => el.classList.remove('drop-inside'));
      if (!dropLineEl) return;
      const containerRect = els.tree.getBoundingClientRect();
      const y = (placeAfter ? targetRect.bottom : targetRect.top) - containerRect.top + els.tree.scrollTop;
      dropLineEl.style.top = (y - 1) + 'px';
      dropLineEl.style.display = 'block';
    }

    async function createNode(type) {
      const title = prompt(type === 'folder' ? 'Section title:' : 'Page title:');
      if (!title || !title.trim()) return;

      const parentDir = (() => {
        if (!selectedId) return '';
        const info = findNode(stateTree, selectedId);
        if (!info) return '';
        if (info.node.type === 'folder') return folderDirForId(info.node.id);
        if (info.parent && info.parent.type === 'folder') return folderDirForId(info.parent.id);
        return '';
      })();

      let newId = '';
      withHistory('create', () => {
        const parentInfo = selectedId ? findNode(stateTree, selectedId) : null;
        let container = stateTree;
        if (parentInfo) {
          if (parentInfo.node.type === 'folder') {
            parentInfo.node.children = Array.isArray(parentInfo.node.children) ? parentInfo.node.children : [];
            container = parentInfo.node.children;
          } else if (parentInfo.parent && parentInfo.parent.type === 'folder') {
            parentInfo.parent.children = Array.isArray(parentInfo.parent.children) ? parentInfo.parent.children : [];
            container = parentInfo.parent.children;
          }
        }

        const id = crypto && crypto.randomUUID ? crypto.randomUUID().replace(/-/g, '') : String(Date.now());
        newId = id;
        if (type === 'folder') {
          container.push({ id, type: 'folder', title: title.trim(), segment: '', file: null, children: [] });
        } else {
          container.push({ id, type: 'page', title: title.trim(), file: null, file_prev: null, segment: null, children: [] });
        }
      });
      renderTree();
      updateHistoryButtons();

      // Create on disk immediately (no Sync Files required for filesystem presence).
      if (type === 'folder') {
        try {
          const data = await fetchJson('/api/create_section', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ title: title.trim(), parent_dir: parentDir })
          });
          const found = findNode(stateTree, newId);
          if (found && found.node && found.node.type === 'folder') {
            found.node.segment = data.segment || found.node.segment || '';
          }
          renderTree();
          await loadSource();
          setStatus('Section created on disk.', 'success');
        } catch (e) {
          setStatus(e.message || 'Create section failed.', 'error');
        }
        return;
      }

      try {
        const data = await fetchJson('/api/create_page', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title: title.trim(), parent_dir: parentDir })
        });
        const found = findNode(stateTree, newId);
        if (found && found.node && found.node.type === 'page') {
          found.node.file = data.file || found.node.file;
          found.node.file_prev = null;
        }
        renderTree();
        await loadSource();
        setStatus('Page created on disk.', 'success');
      } catch (e) {
        setStatus(e.message || 'Create page failed.', 'error');
      }
    }

    function renameSelected() {
      if (!selectedId) return setStatus('Select a node first.', 'info');
      const rowTitle = document.querySelector(`#tree li[data-id="${selectedId}"] .node-title`);
      if (!rowTitle) return setStatus('Selected node not visible (expand parent folders).', 'info');
      beginInlineEdit(selectedId, 'title', rowTitle);
    }

    function beginInlineEdit(id, field, hostEl) {
      if (!id || !hostEl) return;
      const info = findNode(stateTree, id);
      if (!info) return setStatus('Node not found.', 'error');

      if (activeInlineEdit && activeInlineEdit.id === id && activeInlineEdit.field === field) return;
      if (activeInlineEdit) cancelInlineEdit();

      const li = hostEl.closest('li.node');
      if (!li) return;

      const originalValue =
        field === 'file' ? (info.node.file || '') :
          field === 'segment' ? (info.node.segment || '') :
            (info.node.title || '');
      const originalDir = (() => {
        if (field !== 'file') return '';
        const p = String(originalValue || '').replace(/^\.\//, '');
        const idx = p.lastIndexOf('/');
        return idx >= 0 ? p.slice(0, idx + 1) : '';
      })();
      const startValue =
        field === 'file' ? (() => {
          const p = String(originalValue || '').replace(/^\.\//, '');
          const idx = p.lastIndexOf('/');
          return idx >= 0 ? p.slice(idx + 1) : p;
        })() :
          field === 'segment' ? originalValue :
            displayTitleForNode(info.node);

      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'inline-edit';
      input.value = startValue;
      input.spellcheck = false;
      input.draggable = false;

      const prevText = hostEl.textContent || '';
      hostEl.textContent = '';
      hostEl.appendChild(input);

      const prevDraggable = li.draggable;
      li.draggable = false;
      li.classList.add('is-editing');

      activeInlineEdit = { id, field, hostEl, input, prevText, prevDraggable, originalValue, originalDir };

      const finish = (mode) => {
        if (!activeInlineEdit) return;
        const current = activeInlineEdit;
        if (current.input) current.input.removeEventListener('keydown', onKeyDown);
        if (current.input) current.input.removeEventListener('blur', onBlur);
        li.draggable = current.prevDraggable;
        li.classList.remove('is-editing');
        const value = (current.input && current.input.value ? current.input.value : '').trim();
        activeInlineEdit = null;

        if (mode === 'cancel') {
          current.hostEl.textContent = current.prevText;
          return;
        }

        if (current.field === 'title') {
          if (!value) {
            current.hostEl.textContent = current.prevText;
            return;
          }
          withHistory('edit.title', () => {
            const nodeInfo = findNode(stateTree, current.id);
            if (nodeInfo) nodeInfo.node.title = value;
          });
          renderTree();
          updateHistoryButtons();
          setStatus('Renamed.', 'success');
          return;
        }

        if (current.field === 'segment') {
          if (value.includes('/') || value.includes('\\')) {
            setStatus('Folder name cannot contain slashes.', 'error');
            current.hostEl.textContent = current.prevText;
            return;
          }
          withHistory('edit.segment', () => {
            const nodeInfo = findNode(stateTree, current.id);
            if (!nodeInfo) return;
            nodeInfo.node.segment = value;
          });
          renderTree();
          updateHistoryButtons();
          setStatus('Updated folder name.', 'success');
          return;
        }

        if (current.field === 'file') {
          if (value.includes('/') || value.includes('\\')) {
            setStatus('Filename only (no directories).', 'error');
            current.hostEl.textContent = current.prevText;
            return;
          }
          withHistory('edit.file', () => {
            const nodeInfo = findNode(stateTree, current.id);
            if (!nodeInfo) return;
            const before = (current.originalValue || '').trim();
            if (before && !nodeInfo.node.file_prev) nodeInfo.node.file_prev = before;
            const base = value ? value.replace(/^\.\//, '') : '';
            nodeInfo.node.file = base ? `${current.originalDir}${base}` : null;
          });
          renderTree();
          updateHistoryButtons();
          setStatus('Updated file path.', 'success');
          return;
        }
      };

      const onKeyDown = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          finish('commit');
        } else if (e.key === 'Escape') {
          e.preventDefault();
          finish('cancel');
        }
      };
      const onBlur = () => finish('commit');

      input.addEventListener('keydown', onKeyDown);
      input.addEventListener('blur', onBlur);

      requestAnimationFrame(() => {
        input.focus();
        input.select();
      });
    }

    function cancelInlineEdit() {
      if (!activeInlineEdit) return;
      const current = activeInlineEdit;
      const li = current.hostEl.closest('li.node');
      if (current.input) current.input.remove();
      if (li) {
        li.draggable = current.prevDraggable;
        li.classList.remove('is-editing');
      }
      current.hostEl.textContent = current.prevText;
      activeInlineEdit = null;
    }

    async function deleteSelected() {
      if ((!selectedId || !findNode(stateTree, selectedId)) && (!selectedIds || !selectedIds.size)) {
        return setStatus('Select a node first.', 'info');
      }
      const ids = selectedIds && selectedIds.size ? Array.from(selectedIds) : [selectedId];
      const folderCheck = classifyFoldersForDelete(ids);
      if (folderCheck.blocking.length) {
        const first = folderCheck.blocking[0];
        return setStatus(`Cannot delete non-empty folder "${first.title}". Move its pages first.`, 'info');
      }

      const filesToDelete = collectFilesForIds(ids);
      const dirsToDelete = folderCheck.emptyDirs;
      const hasFiles = filesToDelete.length > 0;

      const ok = confirm(hasFiles
        ? `Delete ${ids.length} selected item(s) from the tree. You can also delete ${filesToDelete.length} file(s) on disk afterwards. Continue?`
        : `Delete ${ids.length} selected item(s) from the tree only. Continue?`);
      if (!ok) return;
      let removed = null;
      withHistory('delete', () => {
        const ctxs = detachManyWithContext(ids);
        removed = ctxs.length ? { count: ctxs.length } : null;
      });
      clearSelection();
      renderTree();
      updateHistoryButtons();
      setStatus(removed ? `Deleted ${removed.count || 1}.` : 'Not found.', removed ? 'success' : 'info');

      if (dirsToDelete.length) {
        await deleteDirsOnDisk(dirsToDelete);
      }

      if (hasFiles) {
        const del = confirm(`Also delete the selected page file(s) from disk? (This cannot be undone)`);
        if (del) {
          await deleteFilesOnDisk(filesToDelete);
        }
      }
    }

    function classifyFoldersForDelete(ids) {
      const blocking = [];
      const emptyDirs = [];
      const seenDirs = new Set();

      function hasAnyPage(node) {
        if (!node) return false;
        if (node.type === 'page') return true;
        for (const c of (node.children || [])) {
          if (hasAnyPage(c)) return true;
        }
        return false;
      }

      for (const id of (ids || [])) {
        const found = findNode(stateTree, id);
        if (!found || !found.node) continue;
        if (found.node.type !== 'folder') continue;
        if (hasAnyPage(found.node)) {
          blocking.push({ id, title: found.node.title || id });
          continue;
        }
        const dir = folderDirForId(id);
        if (dir && !seenDirs.has(dir)) {
          seenDirs.add(dir);
          emptyDirs.push(dir);
        }
      }
      return { blocking, emptyDirs };
    }

    function folderDirForId(id) {
      if (!id) return '';
      const info = findNode(stateTree, id);
      if (!info || !info.node || info.node.type !== 'folder') return '';
      const segs = [];
      const selfSeg = (info.node.segment || '').trim();
      if (selfSeg) segs.push(selfSeg);
      let p = info.parent;
      while (p) {
        if (p.type === 'folder' && p.segment) segs.push(String(p.segment).trim());
        const parentInfo = findNode(stateTree, p.id);
        p = parentInfo ? parentInfo.parent : null;
      }
      return segs.reverse().filter(Boolean).join('/');
    }

    function collectFilesForIds(ids) {
      const out = [];
      const seen = new Set();
      function walk(node) {
        if (!node) return;
        if (node.type === 'page') {
          if (node.file) {
            const rel = String(node.file).replace(/^\.\//, '').trim();
            if (rel && !seen.has(rel)) {
              seen.add(rel);
              out.push(rel);
            }
          }
          return;
        }
        for (const c of (node.children || [])) walk(c);
      }
      for (const id of (ids || [])) {
        const found = findNode(stateTree, id);
        if (!found) continue;
        walk(found.node);
      }
      return out;
    }

    async function deleteFilesOnDisk(files) {
      setStatus('Deleting files...', 'info');
      try {
        const data = await fetchJson('/api/delete_files', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ files, delete_assets: false })
        });
        const deleted = Array.isArray(data.deleted) ? data.deleted : [];
        const errors = Array.isArray(data.errors) ? data.errors : [];
        const msg = `Deleted ${deleted.length} item(s) from disk.${errors.length ? ` errors:${errors.length}` : ''}`;
        setStatus(msg, errors.length ? 'error' : 'success');
        await loadSource();
      } catch (e) {
        setStatus(e.message || 'Delete files failed.', 'error');
      }
    }

    async function deleteDirsOnDisk(dirs) {
      if (!Array.isArray(dirs) || !dirs.length) return;
      setStatus('Deleting empty folders...', 'info');
      try {
        const data = await fetchJson('/api/delete_dirs', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ dirs })
        });
        const deleted = Array.isArray(data.deleted) ? data.deleted : [];
        const errors = Array.isArray(data.errors) ? data.errors : [];
        const msg = `Deleted ${deleted.length} empty folder(s).${errors.length ? ` errors:${errors.length}` : ''}`;
        setStatus(msg, errors.length ? 'error' : 'success');
        await loadSource();
      } catch (e) {
        setStatus(e.message || 'Delete folders failed.', 'error');
      }
    }
  </script>
</body>

</html>
