<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>MkDocs Nav Manager</title>
  <link rel="stylesheet" href="/static/style.css">
</head>

<body>
  <div class="shell">
    <header class="toolbar">
      <div class="title">
        <h1>MkDocs Nav Manager</h1>
        <div id="meta" class="muted">Loading...</div>
      </div>
      <div class="inline-actions">
        <button id="toggle-tools" type="button" class="ghost" data-help="Toggle Tools panel">ğŸ› </button>
        <button id="toggle-source" type="button" class="ghost" data-help="Toggle Source panel">ğŸ—‚</button>
        <button id="toggle-tree" type="button" class="ghost" data-help="Toggle Doc Tree panel">ğŸ“š</button>
        <button id="toggle-info" type="button" class="ghost" data-help="Toggle Info panel">â„¹ï¸</button>
        <button id="toggle-theme" type="button" class="ghost" data-help="Toggle theme (Day/Night)">ğŸŒ™</button>
      </div>
    </header>

    <div id="tool-tooltip" class="tool-tooltip" hidden></div>

    <div id="workspace" class="workspace">
      <section class="card panel dock-tools" id="panel-tools">
        <div class="card-head">
          <h2>ğŸ›  Tools</h2>
          <span class="muted">Hover for hints</span>
        </div>
        <div class="list-shell tools-body tools-dock-body">
          <div class="tools-group">
            <div class="tools-title">ğŸ§© Draft & History</div>
            <div class="tools-buttons">
              <button id="tool-undo" type="button" class="ghost" data-help="Undo last change">âª Undo</button>
              <button id="tool-redo" type="button" class="ghost" data-help="Redo last undone change">â© Redo</button>
            </div>
          </div>

          <div class="splitter splitter-v splitter-tools" id="split-tools" title="Drag to resize tools"></div>

	          <div class="tools-group">
	            <div class="tools-title">ğŸš€ Main</div>
	            <div class="tools-buttons">
	              <button id="tool-import" type="button" class="ghost"
	                data-help="Rebuild Doc Tree from mkdocs.yml nav (overwrites current draft)">ğŸ“¥ Load mkdocs.yml</button>
	              <button id="tool-beautify-nav" type="button" class="ghost"
	                data-help="Beautify mkdocs.yml nav formatting (nav block only; no file moves)">ğŸ§¼ Beautify nav</button>
	              <span class="sr-only" data-help="All edits auto-sync mkdocs.yml + files"></span>
	              <button id="tool-debug" type="button" class="ghost" data-help="Toggle debug window (DnD logs)">ğŸ§ª
	                Debug</button>
	            </div>
	          </div>
        </div>
      </section>

      <div class="main-grid">
        <section class="card panel" id="panel-source">
          <div class="card-head">
            <h2>Source</h2>
            <div class="inline-actions">
              <span class="muted">Click to locate in tree</span>
              <button id="source-view-btn" type="button" class="ghost"
                data-help="Toggle source view (Explorer / ASCII)">ğŸ§¾ ASCII</button>
            </div>
          </div>
          <div id="source" class="list-shell">Loading...</div>
        </section>

        <div class="splitter splitter-v" id="split-main-left" title="Drag to resize"></div>

	        <section class="card panel" id="panel-tree">
	          <div class="card-head">
	            <h2>ğŸ“š Doc Tree</h2>
	            <div class="inline-actions">
	              <label class="switch" title="" data-help="" id="drag-mode-switch">
	                <input id="drag-mode-toggle" type="checkbox" aria-label="Drag mode toggle">
	                <span class="switch-track"></span>
	                <span class="switch-text" id="drag-mode-text">Drag: Files</span>
	              </label>
	              <div class="segmented" role="group" aria-label="Depth limit">
	                <button type="button" class="ghost depth-btn" data-depth="1" data-help="Show 1 level">1</button>
	                <button type="button" class="ghost depth-btn" data-depth="2" data-help="Show 2 levels">2</button>
	                <button type="button" class="ghost depth-btn" data-depth="3" data-help="Show 3 levels">3</button>
                <button type="button" class="ghost depth-btn" data-depth="4" data-help="Show 4 levels">4</button>
                <button type="button" class="ghost depth-btn" data-depth="5" data-help="Show 5 levels">5</button>
                <button type="button" class="ghost depth-btn" data-depth="n" data-help="Show all levels">âˆ</button>
              </div>
              <button id="new-folder-btn" type="button" data-help="Create a new section under selection">â•ğŸ“ New
                Section</button>
              <button id="new-page-btn" type="button" data-help="Create a new page under selection">â•ğŸ“„ New
                Page</button>
              <button id="delete-btn" type="button" data-help="Delete selected node (tree only)">ğŸ—‘ï¸ Delete</button>
            </div>
          </div>
          <div id="tree" class="list-shell">Loading...</div>
        </section>
      </div>

      <div class="splitter splitter-h" id="split-bottom" title="Drag to resize"></div>

      <div class="bottom-stack debug-hidden" id="bottom-stack">
        <section class="card panel" id="panel-info">
          <div class="card-head">
            <h2>â„¹ï¸ Info</h2>
            <span class="muted">Hover tools for hints</span>
          </div>
          <div class="list-shell info-body">
            <div id="status" class="status-box" data-type="info"></div>
            <div class="info-pills">
              <div id="info-meta-pill" class="info-pill" title=""></div>
              <div id="info-selection-pill" class="info-pill" title=""></div>
            </div>
            <details id="info-details" class="info-details">
              <summary class="info-summary">More</summary>
              <div id="info-meta" class="info-line"></div>
              <div id="info-selection" class="info-line"></div>
              <div id="info-errors" class="info-errors" hidden></div>
            </details>
            <div id="info-hover" class="info-hint" hidden></div>
          </div>
        </section>

        <div class="splitter splitter-h" id="split-info-debug" title="Drag to resize debug height"></div>

        <section id="debug-panel" class="card panel debug-panel" hidden>
          <div class="debug-head">
            <div class="debug-title">DnD Debug</div>
            <div class="debug-actions">
              <button id="debug-clear" type="button" class="ghost">Clear</button>
              <button id="debug-copy" type="button" class="ghost">Copy</button>
            </div>
          </div>
          <pre id="debug-log" class="debug-log"></pre>
        </section>
      </div>
    </div>
  </div>

  <script>
    let els = {};
    let stateTree = [];
    let sourceTree = [];
    let sourceView = 'list';
    let sourceCollapsed = new Set();
    let selectedId = '';
    let selectedIds = new Set();
    let selectionAnchorId = '';
    let selectionParentKey = '';
    let draggedId = '';
		    let draggedIds = [];
		    let dropHint = { mode: null, targetId: null };
		    let dropLineEl = null;
    let debugEnabled = false;
    let debugLog = [];
    let lastDropHintSignature = '';
    let lastDragoverLogAt = 0;
    let historyPast = [];
    let historyFuture = [];
    let lastPersistedSignature = '';
    let treeCollapsed = new Set();
    let treeMaxLevel = 'n';
    let toolTipEl = null;
		    let activeInlineEdit = null;
		    let autoSyncTimer = null;
		    let dragMode = 'sync_files'; // sync_files | nav_only
		    let selectedDisplaySlotFolderId = '';
		    let showTools = false;
    let showSource = false;
    let showTree = true;
    let showInfo = false;
    let theme = 'dark';

	    document.addEventListener('DOMContentLoaded', () => {
      els = {
        meta: document.getElementById('meta'),
        status: document.getElementById('status'),
        source: document.getElementById('source'),
        tree: document.getElementById('tree'),
        workspace: document.getElementById('workspace'),
        panelTools: document.getElementById('panel-tools'),
        panelSource: document.getElementById('panel-source'),
        panelTree: document.getElementById('panel-tree'),
        panelInfo: document.getElementById('panel-info'),
        bottomStack: document.getElementById('bottom-stack'),
        infoMeta: document.getElementById('info-meta'),
	        infoMetaPill: document.getElementById('info-meta-pill'),
        infoHover: document.getElementById('info-hover'),
        infoSelection: document.getElementById('info-selection'),
	        infoSelectionPill: document.getElementById('info-selection-pill'),
	        infoDetails: document.getElementById('info-details'),
	        infoErrors: document.getElementById('info-errors'),
        sourceViewBtn: document.getElementById('source-view-btn'),
        newFolderBtn: document.getElementById('new-folder-btn'),
        newPageBtn: document.getElementById('new-page-btn'),
        deleteBtn: document.getElementById('delete-btn'),
        toolUndoBtn: document.getElementById('tool-undo'),
	        toolRedoBtn: document.getElementById('tool-redo'),
		        toolImportBtn: document.getElementById('tool-import'),
		        toolBeautifyNavBtn: document.getElementById('tool-beautify-nav'),
		        dragModeToggle: document.getElementById('drag-mode-toggle'),
		        dragModeSwitch: document.getElementById('drag-mode-switch'),
		        dragModeText: document.getElementById('drag-mode-text'),
		        toolDebugBtn: document.getElementById('tool-debug'),
        debugPanel: document.getElementById('debug-panel'),
        debugLog: document.getElementById('debug-log'),
        debugClear: document.getElementById('debug-clear'),
        debugCopy: document.getElementById('debug-copy'),
        splitMainLeft: document.getElementById('split-main-left'),
        splitBottom: document.getElementById('split-bottom'),
        splitInfoDebug: document.getElementById('split-info-debug'),
        splitTools: document.getElementById('split-tools'),
        toggleTools: document.getElementById('toggle-tools'),
        toggleSource: document.getElementById('toggle-source'),
        toggleTree: document.getElementById('toggle-tree'),
        toggleInfo: document.getElementById('toggle-info'),
        toggleTheme: document.getElementById('toggle-theme'),
      };

		      els.toolImportBtn.addEventListener('click', () => importFromMkdocs({ confirm: true }));
		      if (els.toolBeautifyNavBtn) els.toolBeautifyNavBtn.addEventListener('click', beautifyNav);

      els.newFolderBtn.addEventListener('click', () => createNode('folder'));
      els.newPageBtn.addEventListener('click', () => createNode('page'));
      els.deleteBtn.addEventListener('click', deleteSelected);
	      els.toolUndoBtn.addEventListener('click', undo);
	      els.toolRedoBtn.addEventListener('click', redo);
	      if (els.dragModeToggle) els.dragModeToggle.addEventListener('change', onDragModeToggle);

      els.toolDebugBtn.addEventListener('click', toggleDebug);
      els.debugClear.addEventListener('click', () => {
        debugLog = [];
        renderDebug();
      });
      els.debugCopy.addEventListener('click', () => {
        const text = (debugLog || []).join('\n');
        copyToClipboard(text);
        setStatus('Debug log copied.', 'info');
      });

      sourceView = localStorage.getItem('page_tree_source_view') || 'list';
      sourceCollapsed = new Set(JSON.parse(localStorage.getItem('page_tree_source_collapsed') || '[]'));
      els.sourceViewBtn.addEventListener('click', toggleSourceView);
      updateSourceViewButton();
      treeCollapsed = new Set(JSON.parse(localStorage.getItem('page_tree_tree_collapsed') || '[]'));
      treeMaxLevel = localStorage.getItem('page_tree_tree_max_level') || 'n';
      bindDepthButtons();
      updateDepthButtons();

      // Unified DnD handlers on the tree container (mouse-position detector).
      els.tree.addEventListener('dragover', onTreeDragOver);
      els.tree.addEventListener('drop', onTreeDrop);
      els.tree.addEventListener('dragleave', onTreeDragLeave);
      dropLineEl = document.createElement('div');
      dropLineEl.className = 'drop-line';
      els.tree.appendChild(dropLineEl);
      hideDropLine();

      // Default: hidden each session.
      debugEnabled = false;
      debugLog = [];
      if (els.debugPanel) els.debugPanel.hidden = true;
      updateDebugVisibility();

		      initSplitters();
		      bindToolHoverHints();

      // Default visible: Tools/Source/Doc Tree/Info (user can toggle).
      showTools = localStorage.getItem('page_tree_show_tools') !== 'false';
      showSource = localStorage.getItem('page_tree_show_source') !== 'false';
      showTree = localStorage.getItem('page_tree_show_tree') !== 'false';
      showInfo = localStorage.getItem('page_tree_show_info') !== 'false';
      initTheme();
      applyPanelVisibility();

      if (els.toggleTools) els.toggleTools.addEventListener('click', () => {
        showTools = !showTools;
        localStorage.setItem('page_tree_show_tools', String(showTools));
        applyPanelVisibility();
      });
      if (els.toggleSource) els.toggleSource.addEventListener('click', () => {
        showSource = !showSource;
        localStorage.setItem('page_tree_show_source', String(showSource));
        applyPanelVisibility();
      });
      if (els.toggleTree) els.toggleTree.addEventListener('click', () => {
        showTree = !showTree;
        localStorage.setItem('page_tree_show_tree', String(showTree));
        applyPanelVisibility();
      });
      if (els.toggleInfo) els.toggleInfo.addEventListener('click', () => {
        showInfo = !showInfo;
        localStorage.setItem('page_tree_show_info', String(showInfo));
        applyPanelVisibility();
      });
      if (els.toggleTheme) els.toggleTheme.addEventListener('click', toggleTheme);

      window.addEventListener('keydown', (e) => {
        if (activeInlineEdit) return;
        if (e.key === 'Escape') {
          clearSelection();
        }
      });

	      dragMode = localStorage.getItem('page_tree_drag_mode') || 'sync_files';
	      updateDragModeSwitch();
	      loadMeta();
	      // Default: auto-load mkdocs.yml on entry. If invalid, block rendering.
	      bootstrap();
		    });

		    function onDragModeToggle() {
		      if (!els.dragModeToggle) return;
		      dragMode = els.dragModeToggle.checked ? 'sync_files' : 'nav_only';
		      localStorage.setItem('page_tree_drag_mode', dragMode);
		      updateDragModeSwitch();
		      setStatus(dragMode === 'nav_only' ? 'Drag: Nav only' : 'Drag: Nav + Files', 'info');
		    }

		    function updateDragModeSwitch() {
		      const isFiles = dragMode === 'sync_files';
		      if (els.dragModeToggle) els.dragModeToggle.checked = isFiles;
		      if (els.dragModeText) els.dragModeText.textContent = isFiles ? 'Drag: Files' : 'Drag: Nav';
		      if (els.dragModeSwitch) {
		        els.dragModeSwitch.dataset.help = isFiles
		          ? 'Drag & drop updates mkdocs.yml and moves files on disk'
		          : 'Drag & drop updates mkdocs.yml nav only (no file moves)';
		        els.dragModeSwitch.title = els.dragModeSwitch.dataset.help;
		      }
		    }

		    async function bootstrap() {
		      setStatus('Loading mkdocs.yml...', 'info');
		      try {
		        const data = await fetchJson('/api/import', { method: 'POST' });
		        stateTree = Array.isArray(data.tree) ? data.tree : [];
		        const warnings = Array.isArray(data.warnings) ? data.warnings : [];
		        lastPersistedSignature = treeSignature(stateTree);
		        resetHistory();
		        renderTree();
		        updateHistoryButtons();
		        await loadSource();
		        setStatus(warnings.length ? `Loaded with warnings (${warnings.length}).` : 'Loaded from mkdocs.yml.', warnings.length ? 'info' : 'success');
		      } catch (e) {
		        const data = e && e.data ? e.data : null;
		        if (data && Array.isArray(data.errors)) {
		          const count = data.errors.length;
		          setStatus(`Import blocked: ${count} invalid/missing doc path(s).`, 'error');
		          pushDebug('import.blocked', { errors: data.errors });
		          showImportErrors(data);
		          if (els.tree) els.tree.textContent = 'Blocked: invalid mkdocs.yml paths.';
		          if (els.source) els.source.textContent = 'Blocked.';
		          clearSelection();
		          return;
		        }
		        setStatus(e.message || 'Import failed.', 'error');
		        if (els.tree) els.tree.textContent = 'Failed to load tree.';
		      }
		    }

    function initTheme() {
      theme = localStorage.getItem('page_tree_theme') || 'dark';
      applyTheme();
    }

    function toggleTheme() {
      theme = theme === 'light' ? 'dark' : 'light';
      localStorage.setItem('page_tree_theme', theme);
      applyTheme();
    }

    function applyTheme() {
      document.body.classList.toggle('theme-light', theme === 'light');
      if (els.toggleTheme) els.toggleTheme.textContent = theme === 'light' ? 'â˜€ï¸' : 'ğŸŒ™';
      pushDebug('theme.set', { theme });
    }

    function applyPanelVisibility() {
      if (els.panelTools) els.panelTools.hidden = !showTools;
      if (els.panelSource) els.panelSource.hidden = !showSource;
      if (els.panelTree) els.panelTree.hidden = !showTree;
      if (els.panelInfo) els.panelInfo.hidden = !showInfo;
      if (els.splitMainLeft) els.splitMainLeft.style.display = (showSource && showTree) ? '' : 'none';
      if (els.splitBottom) els.splitBottom.style.display = showInfo ? '' : 'none';
      if (els.bottomStack) els.bottomStack.hidden = !showInfo;

      if (els.workspace) {
        els.workspace.classList.toggle('no-tools', !showTools);
        els.workspace.classList.toggle('no-source', !showSource);
        els.workspace.classList.toggle('no-tree', !showTree);
        els.workspace.classList.toggle('no-bottom', !showInfo);
        const singleMain = (showSource ? 1 : 0) + (showTree ? 1 : 0) === 1;
        els.workspace.classList.toggle('single-main', singleMain);
      }

      if (els.toggleTools) els.toggleTools.classList.toggle('active', showTools);
      if (els.toggleSource) els.toggleSource.classList.toggle('active', showSource);
      if (els.toggleTree) els.toggleTree.classList.toggle('active', showTree);
      if (els.toggleInfo) els.toggleInfo.classList.toggle('active', showInfo);
    }

    function bindToolHoverHints() {
      toolTipEl = document.getElementById('tool-tooltip');
      const buttons = document.querySelectorAll('[data-help]');
      buttons.forEach(btn => {
        btn.addEventListener('mouseenter', (e) => {
          const text = btn.dataset.help || '';
          setInfoHover(text);
          showToolTip(text, e);
        });
        btn.addEventListener('mousemove', (e) => {
          moveToolTip(e);
        });
        btn.addEventListener('mouseleave', () => {
          setInfoHover('');
          hideToolTip();
        });
      });
    }

	    function scheduleAutoSync(reason, modeOverride) {
	      if (autoSyncTimer) clearTimeout(autoSyncTimer);
	      const mode = modeOverride || 'sync_files';
	      autoSyncTimer = setTimeout(async () => {
	        autoSyncTimer = null;
	        pushDebug('auto_sync.run', { mode, reason });
	        await sync(mode, { confirm: false, silent: true });
	      }, 250);
	    }

	    function scheduleNavOnly(reason) {
	      return scheduleAutoSync(reason, 'nav_only');
	    }

    function showToolTip(text, e) {
      if (!toolTipEl) return;
      const value = (text || '').trim();
      if (!value) return;
      toolTipEl.textContent = value;
      toolTipEl.hidden = false;
      moveToolTip(e);
    }

    function moveToolTip(e) {
      if (!toolTipEl || toolTipEl.hidden) return;
      const pad = 12;
      const maxLeft = window.innerWidth - toolTipEl.offsetWidth - pad;
      const maxTop = window.innerHeight - toolTipEl.offsetHeight - pad;
      const left = Math.min(e.clientX + pad, Math.max(pad, maxLeft));
      const top = Math.min(e.clientY + pad, Math.max(pad, maxTop));
      toolTipEl.style.left = `${left}px`;
      toolTipEl.style.top = `${top}px`;
    }

    function hideToolTip() {
      if (!toolTipEl) return;
      toolTipEl.hidden = true;
      toolTipEl.textContent = '';
    }

    function toggleSourceView() {
      sourceView = sourceView === 'ascii' ? 'list' : 'ascii';
      localStorage.setItem('page_tree_source_view', sourceView);
      updateSourceViewButton();
      renderSource();
    }

    function bindDepthButtons() {
      const buttons = document.querySelectorAll('.depth-btn');
      buttons.forEach(btn => {
        btn.addEventListener('click', () => {
          treeMaxLevel = btn.dataset.depth || 'n';
          localStorage.setItem('page_tree_tree_max_level', treeMaxLevel);
          updateDepthButtons();
          renderTree();
        });
      });
    }

    function updateDepthButtons() {
      const buttons = document.querySelectorAll('.depth-btn');
      buttons.forEach(btn => {
        btn.classList.toggle('active', (btn.dataset.depth || '') === String(treeMaxLevel));
      });
    }

    function maxLevelValue() {
      if (treeMaxLevel === 'n') return Number.POSITIVE_INFINITY;
      const n = parseInt(String(treeMaxLevel), 10);
      return Number.isFinite(n) && n > 0 ? n : Number.POSITIVE_INFINITY;
    }

    function updateSourceViewButton() {
      if (!els.sourceViewBtn) return;
      els.sourceViewBtn.classList.toggle('active', sourceView === 'ascii');
      // Show the view you can switch to.
      els.sourceViewBtn.textContent = sourceView === 'ascii' ? 'ğŸ—‚ Explorer' : 'ğŸ§¾ ASCII';
    }

    function deepClone(value) {
      return JSON.parse(JSON.stringify(value));
    }

    function treeSignature(tree) {
      try {
        return JSON.stringify(tree || []);
      } catch (e) {
        return String(Date.now());
      }
    }

    function isDirty() {
      return treeSignature(stateTree) !== lastPersistedSignature;
    }

    function updateHistoryButtons() {
      if (els.toolUndoBtn) els.toolUndoBtn.disabled = historyPast.length === 0;
      if (els.toolRedoBtn) els.toolRedoBtn.disabled = historyFuture.length === 0;
    }

    function resetHistory() {
      historyPast = [];
      historyFuture = [];
      updateHistoryButtons();
    }

    function makeSnapshot(tree, mode) {
      return { tree: deepClone(tree), dragMode: mode || dragMode || 'sync_files' };
    }

    function snapshotTree(snapshot) {
      // Back-compat: older history entries stored the tree array directly.
      if (Array.isArray(snapshot)) return snapshot;
      if (snapshot && Array.isArray(snapshot.tree)) return snapshot.tree;
      return [];
    }

    function snapshotDragMode(snapshot) {
      if (snapshot && typeof snapshot === 'object' && typeof snapshot.dragMode === 'string') return snapshot.dragMode;
      return null;
    }

    function applySnapshot(snapshot) {
      stateTree = deepClone(snapshotTree(snapshot));
      const mode = snapshotDragMode(snapshot);
      if (mode === 'nav_only' || mode === 'sync_files') {
        dragMode = mode;
        localStorage.setItem('page_tree_drag_mode', dragMode);
        updateDragModeSwitch();
      }
    }

    function pushHistorySnapshot(snapshot) {
      historyPast.push(snapshot);
      if (historyPast.length > 5) historyPast.shift();
      historyFuture = [];
      updateHistoryButtons();
      persistHistory();
    }

    function withHistory(label, mutator) {
      const before = makeSnapshot(stateTree, dragMode);
      pushHistorySnapshot(before);
      mutator();
      pushDebug('history.commit', { label });
      persistHistory();
    }

    function buildFileMap(tree) {
      const map = new Map();
      const walk = (nodes) => {
        for (const n of (nodes || [])) {
          if (!n) continue;
          if (n.type === 'page') {
            if (n.id) map.set(n.id, n.file || '');
          } else if (n.type === 'folder') {
            walk(n.children || []);
          }
        }
      };
      walk(tree || []);
      return map;
    }

    function applyFilePrevFromCurrent(targetTree, currentFileMap) {
      const walk = (nodes) => {
        for (const n of (nodes || [])) {
          if (!n) continue;
          if (n.type === 'page') {
            const cur = currentFileMap.get(n.id) || '';
            const next = n.file || '';
            if (cur && next && cur !== next) {
              n.file_prev = cur;
            } else {
              n.file_prev = null;
            }
          } else if (n.type === 'folder') {
            walk(n.children || []);
          }
        }
      };
      walk(targetTree || []);
    }

    async function undo() {
      if (!historyPast.length) {
        setStatus('Nothing to undo.', 'info');
        return;
      }
      const beforeTree = deepClone(stateTree);
      const beforePast = historyPast.slice();
      const beforeFuture = historyFuture.slice();

      const current = makeSnapshot(stateTree, dragMode);
      const previous = historyPast.pop();
      historyFuture.push(current);
      applySnapshot(previous);
      applyFilePrevFromCurrent(stateTree, buildFileMap(beforeTree));
      ensureSelectedValid();
      renderTree();
      updateHistoryButtons();
      pushDebug('history.undo', {});
      setStatus('Undoing...', 'info');
      const res = await fetchJson('/api/apply_history_step', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ before_tree: beforeTree, after_tree: stateTree }),
      });
      if (res && res.error) {
        setStatus(res.error, 'error');
      } else {
        setStatus('Undid last action.', 'success');
      }

      // If blocked, keep history consistent by rolling back.
      if (els.status && els.status.dataset.type === 'error' && String(els.status.textContent || '').includes('Sync blocked')) {
        stateTree = beforeTree;
        historyPast = beforePast;
        historyFuture = beforeFuture;
        ensureSelectedValid();
        renderTree();
        updateHistoryButtons();
        setStatus('Undo blocked by file conflict.', 'error');
        return;
      }
      persistHistory();
    }

    async function redo() {
      if (!historyFuture.length) {
        setStatus('Nothing to redo.', 'info');
        return;
      }
      const beforeTree = deepClone(stateTree);
      const beforePast = historyPast.slice();
      const beforeFuture = historyFuture.slice();

      const current = makeSnapshot(stateTree, dragMode);
      const next = historyFuture.pop();
      historyPast.push(current);
      applySnapshot(next);
      applyFilePrevFromCurrent(stateTree, buildFileMap(beforeTree));
      ensureSelectedValid();
      renderTree();
      updateHistoryButtons();
      pushDebug('history.redo', {});
      setStatus('Redoing...', 'info');
      const res = await fetchJson('/api/apply_history_step', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ before_tree: beforeTree, after_tree: stateTree }),
      });
      if (res && res.error) {
        setStatus(res.error, 'error');
      } else {
        setStatus('Redid last action.', 'success');
      }

      if (els.status && els.status.dataset.type === 'error' && String(els.status.textContent || '').includes('Sync blocked')) {
        stateTree = beforeTree;
        historyPast = beforePast;
        historyFuture = beforeFuture;
        ensureSelectedValid();
        renderTree();
        updateHistoryButtons();
        setStatus('Redo blocked by file conflict.', 'error');
        return;
      }
      persistHistory();
    }

    function persistHistory() {
      try {
        const payload = {
          version: 1,
          at: Date.now(),
          currentSig: treeSignature(stateTree),
          past: historyPast.slice(-5),
          future: historyFuture.slice(-5),
        };
        localStorage.setItem('page_tree_history', JSON.stringify(payload));
      } catch {
        // ignore
      }
    }

    function restoreHistoryIfMatching() {
      try {
        const raw = localStorage.getItem('page_tree_history');
        if (!raw) return;
        const data = JSON.parse(raw);
        if (!data || data.version !== 1) return;
        if (data.currentSig && data.currentSig === treeSignature(stateTree) && Array.isArray(data.past)) {
          historyPast = data.past.slice(-5);
          historyFuture = Array.isArray(data.future) ? data.future.slice(-5) : [];
        }
      } catch {
        // ignore
      }
    }

    function toggleDebug() {
      debugEnabled = !debugEnabled;
      updateDebugVisibility();
      pushDebug('debug.toggle', { enabled: debugEnabled });
    }

    function updateDebugVisibility() {
      if (!els.debugPanel) return;
      els.debugPanel.hidden = !debugEnabled;
      if (els.splitInfoDebug) els.splitInfoDebug.style.display = debugEnabled ? '' : 'none';
      if (els.bottomStack) els.bottomStack.classList.toggle('debug-hidden', !debugEnabled);
      if (els.toolDebugBtn) els.toolDebugBtn.classList.toggle('active', debugEnabled);
      renderDebug();
    }

    function renderDebug() {
      if (!debugEnabled) return;
      const lines = (debugLog || []).slice(-300);
      els.debugLog.textContent = lines.join('\n');
      // Always keep the latest line visible.
      requestAnimationFrame(() => {
        els.debugLog.scrollTop = els.debugLog.scrollHeight;
      });
    }

    function pushDebug(tag, payload) {
      if (!debugEnabled) return;
      const ts = new Date().toISOString().slice(11, 23);
      let detail = '';
      try {
        detail = payload === undefined ? '' : ' ' + JSON.stringify(payload);
      } catch (e) {
        detail = ' ' + String(payload);
      }
      debugLog.push(`[${ts}] ${tag}${detail}`);
      if (debugLog.length > 800) debugLog = debugLog.slice(-800);
      renderDebug();
    }

    async function copyToClipboard(text) {
      try {
        await navigator.clipboard.writeText(text);
      } catch (e) {
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position = 'fixed';
        ta.style.left = '-9999px';
        document.body.appendChild(ta);
        ta.focus();
        ta.select();
        document.execCommand('copy');
        ta.remove();
      }
    }

    function initSplitters() {
      if (!els.workspace) return;

      const defaults = {
        left: 360,
        bottom: 180,
        debug: 180,
        toolsLeft: 520,
      };

      const readNum = (key, fallback) => {
        const raw = localStorage.getItem(key);
        const n = raw ? parseFloat(raw) : NaN;
        return Number.isFinite(n) ? n : fallback;
      };

      const clampNum = (v, min, max) => Math.min(Math.max(v, min), max);
      const left = clampNum(readNum('page_tree_layout_left', defaults.left), 240, 820);
      const bottom = clampNum(readNum('page_tree_layout_bottom', defaults.bottom), 120, 360);
      const debugHeight = clampNum(readNum('page_tree_layout_debug', defaults.debug), 120, 360);
      const toolsLeft = clampNum(readNum('page_tree_layout_tools_left', defaults.toolsLeft), 320, 920);

      els.workspace.style.setProperty('--left-width', `${left}px`);
      els.workspace.style.setProperty('--bottom-height', `${bottom}px`);
      els.workspace.style.setProperty('--debug-height', `${debugHeight}px`);
      els.workspace.style.setProperty('--tools-left-width', `${toolsLeft}px`);

      const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
      let drag = null;

      const onMove = (e) => {
        if (!drag) return;
        const x = e.clientX;
        const y = e.clientY;

        if (drag.kind === 'left') {
          const width = clamp(x - drag.rect.left, 240, drag.max);
          els.workspace.style.setProperty('--left-width', `${width}px`);
          return;
        }
        if (drag.kind === 'bottom') {
          const height = clamp(drag.bottom - y, 120, drag.max);
          els.workspace.style.setProperty('--bottom-height', `${height}px`);
          return;
        }
        if (drag.kind === 'debug') {
          const height = clamp(drag.bottom - y, 120, drag.max);
          els.workspace.style.setProperty('--debug-height', `${height}px`);
          return;
        }
        if (drag.kind === 'tools') {
          const width = clamp(x - drag.left, 320, drag.max);
          els.workspace.style.setProperty('--tools-left-width', `${width}px`);
        }
      };

      const onUp = () => {
        if (!drag) return;
        const style = getComputedStyle(els.workspace);
        localStorage.setItem('page_tree_layout_left', parseFloat(style.getPropertyValue('--left-width')) || defaults.left);
        localStorage.setItem('page_tree_layout_bottom', parseFloat(style.getPropertyValue('--bottom-height')) || defaults.bottom);
        localStorage.setItem('page_tree_layout_debug', parseFloat(style.getPropertyValue('--debug-height')) || defaults.debug);
        localStorage.setItem('page_tree_layout_tools_left', parseFloat(style.getPropertyValue('--tools-left-width')) || defaults.toolsLeft);
        drag = null;
        document.body.classList.remove('is-resizing');
        window.removeEventListener('pointermove', onMove);
        window.removeEventListener('pointerup', onUp);
      };

      const start = (kind) => (e) => {
        e.preventDefault();
        if (kind === 'left') {
          const rect = els.workspace.querySelector('.main-grid').getBoundingClientRect();
          drag = { kind, rect, max: Math.max(240, rect.width - 520) };
        } else if (kind === 'bottom') {
          const rect = els.workspace.getBoundingClientRect();
          drag = { kind, bottom: rect.bottom, max: Math.max(120, rect.height - 320) };
        } else if (kind === 'debug') {
          const rect = els.bottomStack.getBoundingClientRect();
          drag = { kind, bottom: rect.bottom, max: Math.max(120, rect.height - 120) };
        } else if (kind === 'tools') {
          const panel = document.getElementById('panel-tools');
          const rect = panel ? panel.getBoundingClientRect() : els.workspace.getBoundingClientRect();
          drag = { kind, left: rect.left, max: Math.max(320, rect.width - 360) };
        } else {
          drag = { kind };
        }
        document.body.classList.add('is-resizing');
        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onUp);
      };

      if (els.splitMainLeft) els.splitMainLeft.addEventListener('pointerdown', start('left'));
      if (els.splitBottom) els.splitBottom.addEventListener('pointerdown', start('bottom'));
      if (els.splitInfoDebug) els.splitInfoDebug.addEventListener('pointerdown', start('debug'));
      if (els.splitTools) els.splitTools.addEventListener('pointerdown', start('tools'));
    }

    async function fetchJson(url, options) {
      const response = await fetch(url, options);
      const text = await response.text();
      let data = null;
      try { data = text ? JSON.parse(text) : null; } catch (e) { data = null; }
      if (!response.ok) {
        const msg = data && typeof data.error === 'string' ? data.error : 'Request failed.';
        const err = new Error(msg);
        err.data = data;
        err.status = response.status;
        throw err;
      }
      return data;
    }

    function setStatus(message, type) {
      els.status.textContent = message || '';
      els.status.dataset.type = type || 'info';
    }

    function setInfoMeta(text) {
      const value = (text || '').trim();
      if (els.infoMeta) els.infoMeta.textContent = value;
      if (els.infoMetaPill) {
        els.infoMetaPill.textContent = shortenPathLine(value);
        els.infoMetaPill.title = value;
      }
    }

    function setInfoSelection(text) {
      const value = (text || '').trim();
      if (els.infoSelection) els.infoSelection.textContent = value;
      if (els.infoSelectionPill) {
        const short = value.replace(/^Selection:\\s*/i, '') || 'Selection: (none)';
        els.infoSelectionPill.textContent = short;
        els.infoSelectionPill.title = value;
      }
    }

    function setInfoHover(text) {
      if (!els.infoHover) return;
      const value = (text || '').trim();
      if (!value) {
        els.infoHover.hidden = true;
        els.infoHover.textContent = '';
        return;
      }
      els.infoHover.hidden = false;
      els.infoHover.textContent = value;
    }

    function shortenPathLine(line) {
      if (!line) return '';
      const parts = line.split('|').map(s => s.trim()).filter(Boolean);
      if (parts.length < 2) return line;
      const mk = parts[0].replace(/\\\\/g, '/').split('/').pop() || parts[0];
      const docs = parts[1].replace(/\\\\/g, '/').split('/').pop() || parts[1];
      return `${mk} â€¢ ${docs}`;
    }

    function findNode(nodes, id, parent = null) {
      for (const node of (nodes || [])) {
        if (node.id === id) return { node, parent, siblings: nodes };
        if (node.type === 'folder' && Array.isArray(node.children)) {
          const found = findNode(node.children, id, node);
          if (found) return found;
        }
      }
      return null;
    }

    function ensureSelectedValid() {
      if (selectedIds && selectedIds.size) {
        const next = new Set();
        for (const id of selectedIds) {
          if (findNode(stateTree, id)) next.add(id);
        }
        selectedIds = next;
      }
      if (selectedId && !findNode(stateTree, selectedId)) selectedId = '';
      if (selectedId && selectedIds && selectedIds.size && !selectedIds.has(selectedId)) {
        selectedId = Array.from(selectedIds)[0] || '';
      }
      if (!selectedId && selectedIds && selectedIds.size) selectedId = Array.from(selectedIds)[0] || '';
    }

    async function loadMeta() {
      try {
        const data = await fetchJson('/api/meta');
        const text = `${data.mkdocs_path} | ${data.docs_root}`;
        els.meta.textContent = shortenPathLine(text);
        els.meta.title = text;
        setInfoMeta(text);
      } catch (e) {
        els.meta.textContent = '(meta unavailable)';
        setInfoMeta('(meta unavailable)');
      }
    }

    async function loadState(options) {
      const reset = options && options.reset;
      setStatus('Loading tree...', 'info');
      try {
        const data = await fetchJson('/api/state');
        stateTree = Array.isArray(data.tree) ? data.tree : [];
        lastPersistedSignature = treeSignature(stateTree);
        if (reset) resetHistory();
        else restoreHistoryIfMatching();
        ensureSelectedValid();
        renderTree();
        updateHistoryButtons();
        setStatus('Tree loaded.', 'success');
      } catch (e) {
        els.tree.textContent = 'Failed to load tree.';
        setStatus(e.message || 'Failed to load tree.', 'error');
      }
    }

    async function loadSource() {
      try {
        const data = await fetchJson('/api/source');
        sourceTree = Array.isArray(data) ? data : [];
        renderSource();
      } catch (e) {
        els.source.textContent = 'Failed to load source.';
      }
    }

	    async function importFromMkdocs(options) {
	      const opts = options || {};
	      const shouldConfirm = opts.confirm !== false;
	      if (shouldConfirm) {
	        if (!confirm('Import will overwrite current tree state. Continue?')) return;
	      }
	      setStatus('Importing...', 'info');
	      try {
	        const data = await fetchJson('/api/import', { method: 'POST' });
	        stateTree = Array.isArray(data.tree) ? data.tree : [];
	        const warnings = Array.isArray(data.warnings) ? data.warnings : [];
	        lastPersistedSignature = treeSignature(stateTree);
	        resetHistory();
	        selectedId = '';
	        renderTree();
	        updateHistoryButtons();
	        setStatus(warnings.length ? `Imported with warnings (${warnings.length}).` : 'Imported from mkdocs.yml.', warnings.length ? 'info' : 'success');
	        await loadSource();
	      } catch (e) {
	        const data = e && e.data ? e.data : null;
	        if (data && Array.isArray(data.errors)) {
	          setStatus(`Import blocked: ${data.errors.length} invalid/missing doc path(s).`, 'error');
	          pushDebug('import.blocked', { errors: data.errors });
	          showImportErrors(data);
	          return;
	        }
	        setStatus(e.message || 'Import failed.', 'error');
	      }
	    }

	    async function beautifyNav() {
	      setStatus('Beautifying nav...', 'info');
	      pushDebug('beautify.nav', {});
	      await sync('nav_only', { confirm: false, silent: false });
	    }

	    function showImportErrors(payload) {
	      if (!els.infoErrors || !els.infoDetails) return;
	      const lines = Array.isArray(payload && payload.lines) ? payload.lines : [];
	      const errors = Array.isArray(payload && payload.errors) ? payload.errors : [];
	      const parts = [];
	      parts.push(`mkdocs.yml import blocked (${errors.length})`);
	      for (const err of errors) {
	        if (!err) continue;
	        const kind = err.type || 'error';
	        const file = err.file ? ` file=${err.file}` : '';
	        const path = err.path ? ` path=${err.path}` : '';
	        const msg = err.error ? ` error=${err.error}` : '';
	        parts.push(`- ${kind}${file}${path}${msg}`);
	      }
	      if (lines.length) {
	        parts.push('');
	        parts.push('Matched mkdocs.yml lines:');
	        for (const l of lines) {
	          if (!l) continue;
	          const no = (l.no != null) ? String(l.no) : '';
	          const text = (l.text || '').trimEnd();
	          parts.push(`${no.padStart(4, ' ')} | ${text}`);
	        }
	      }
	      els.infoErrors.hidden = false;
	      els.infoErrors.textContent = parts.join('\n');
	      els.infoDetails.open = true;
	    }

    async function sync(mode, options) {
      const opts = options || {};
      const shouldConfirm = opts.confirm !== false;
      const silent = !!opts.silent;

      if (shouldConfirm) {
        const msg = mode === 'sync_files'
          ? 'This will move .md files (and sibling asset folders) on disk. Continue?'
          : 'This will write mkdocs.yml nav. Continue?';
        if (!confirm(msg)) return;
      }
      if (!silent) setStatus('Syncing...', 'info');
      try {
        const data = await fetchJson('/api/sync', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ mode, tree: stateTree })
        });
        const moves = Array.isArray(data.moves) ? data.moves : [];
        const warnings = Array.isArray(data.warnings) ? data.warnings : [];
        const extra = moves.length ? ` moved:${moves.length}` : '';
        const warn = warnings.length ? ` warnings:${warnings.length}` : '';
        if (!silent) setStatus(`Sync ok.${extra}${warn}`, warnings.length ? 'info' : 'success');
        await loadState({ reset: false });
        await loadSource();
        lastPersistedSignature = treeSignature(stateTree);
      } catch (e) {
        const data = e && e.data ? e.data : null;
        if (data && Array.isArray(data.collisions) && data.collisions.length) {
          setStatus(`Sync blocked: file name conflict (${data.collisions.length}). No changes applied.`, 'error');
          pushDebug('sync.blocked', { collisions: data.collisions });
          await loadState({ reset: true });
          await loadSource();
          return;
        }
        setStatus(e.message || 'Sync failed.', 'error');
      }
    }

    function renderSource() {
      els.source.innerHTML = '';
      if (!Array.isArray(sourceTree) || !sourceTree.length) {
        els.source.textContent = '(no markdown files found)';
        return;
      }
      els.source.appendChild(sourceView === 'ascii' ? buildSourceAscii(sourceTree) : buildSourceList(sourceTree));
    }

    function persistSourceCollapsed() {
      localStorage.setItem('page_tree_source_collapsed', JSON.stringify(Array.from(sourceCollapsed)));
    }

    function toggleSourceDir(path) {
      if (!path) return;
      if (sourceCollapsed.has(path)) sourceCollapsed.delete(path);
      else sourceCollapsed.add(path);
      persistSourceCollapsed();
      renderSource();
    }

    function buildSourceList(nodes, depth = 0) {
      const ul = document.createElement('ul');
      ul.className = depth === 0 ? 'source-explorer' : 'source-children';
      for (const node of (nodes || [])) {
        const li = document.createElement('li');
        li.className = 'source-item';
        li.dataset.kind = node.kind || '';
        li.dataset.path = node.path || '';

        const row = document.createElement('div');
        row.className = 'source-row ' + (node.kind === 'dir' ? 'kind-dir' : 'kind-file');
        row.style.paddingLeft = `${6 + depth * 8}px`;
        row.title = node.path ? `./${node.path}` : '';

        const twist = document.createElement('span');
        twist.className = 'source-twist';
        const isDir = node.kind === 'dir';
        const isCollapsed = isDir && node.path && sourceCollapsed.has(node.path);
        twist.textContent = isDir ? (isCollapsed ? 'â–¸' : 'â–¾') : '';
        row.appendChild(twist);

        const icon = document.createElement('span');
        icon.className = 'source-icon';
        icon.textContent = isDir ? 'ğŸ“' : 'ğŸ“„';
        row.appendChild(icon);

        const name = document.createElement('span');
        name.className = 'source-name';
        name.textContent = node.name || '(unnamed)';
        row.appendChild(name);

        li.appendChild(row);

        if (node.kind === 'file') {
          row.classList.add('clickable');
          row.addEventListener('click', (e) => {
            e.stopPropagation();
            locateByFile(node.path || '');
          });
        } else if (node.kind === 'dir') {
          row.classList.add('clickable');
          row.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleSourceDir(node.path || '');
          });
        }

        if (node.kind === 'dir' && Array.isArray(node.children) && node.children.length) {
          const collapsed = node.path && sourceCollapsed.has(node.path);
          if (!collapsed) {
            li.appendChild(buildSourceList(node.children, depth + 1));
          }
        }
        ul.appendChild(li);
      }
      return ul;
    }

    function buildSourceAscii(nodes) {
      const container = document.createElement('div');
      container.className = 'source-ascii';
      const lines = [];

      function walk(items, prefixParts) {
        (items || []).forEach((node, index) => {
          const isLast = index === items.length - 1;
          const branch = isLast ? 'â””â”€â”€ ' : 'â”œâ”€â”€ ';
          const prefix = (prefixParts || []).join('') + branch;

          const line = document.createElement('div');
          line.className = 'source-line';

          const pre = document.createElement('span');
          pre.className = 'source-prefix';
          pre.textContent = prefix;
          line.appendChild(pre);

          const name = document.createElement('span');
          name.className = 'source-name ' + (node.kind === 'dir' ? 'kind-dir' : 'kind-file');
          const ext = node.kind === 'file' ? (String(node.name || '').split('.').pop() || '').toLowerCase() : '';
          if (ext) name.dataset.ext = ext;
          name.textContent = node.name || '(unnamed)';
          line.appendChild(name);

          if (node.kind === 'file' && node.path) {
            line.classList.add('clickable');
            line.addEventListener('click', (e) => {
              e.stopPropagation();
              locateByFile(node.path || '');
            });
          }

          lines.push(line);

          const nextPrefixParts = (prefixParts || []).slice();
          nextPrefixParts.push(isLast ? '    ' : 'â”‚   ');
          if (Array.isArray(node.children) && node.children.length) {
            walk(node.children, nextPrefixParts);
          }
        });
      }

      walk(nodes || [], []);
      lines.forEach(l => container.appendChild(l));
      return container;
    }

    function locateByFile(file) {
      const normalized = normalizePath(file);
      if (!normalized) return;
      const all = Array.from(document.querySelectorAll('#tree li[data-file]'));
      all.forEach(el => el.classList.remove('flash'));
      const hit = all.find(el => normalizePath(el.dataset.file || '') === normalized);
      if (!hit) {
        setStatus('Not found in tree.', 'info');
        return;
      }
      hit.classList.add('flash');
      hit.scrollIntoView({ behavior: 'smooth', block: 'center' });
      setTimeout(() => hit.classList.remove('flash'), 900);
    }

    function normalizePath(path) {
      return (path || '').trim().replace(/^\.\//, '').replace(/\\/g, '/').replace(/\/+/g, '/').toLowerCase();
    }

    function renderTree() {
      els.tree.innerHTML = '';
      dropLineEl = dropLineEl || document.createElement('div');
      dropLineEl.className = 'drop-line';
      const list = buildTreeList(Array.isArray(stateTree) ? stateTree : [], true, 0);
      els.tree.appendChild(list);
      els.tree.appendChild(dropLineEl);
      hideDropLine();
      updateSelectionInfo();
      if (!stateTree.length) {
        const hint = document.createElement('div');
        hint.className = 'empty-hint';
        hint.textContent = '(empty)';
        els.tree.appendChild(hint);
      }
    }

    function updateSelectionInfo() {
      if (selectedIds && selectedIds.size > 1) {
        setInfoSelection(`Selection: ${selectedIds.size} items`);
        return;
      }
      if (!selectedId && selectedDisplaySlotFolderId) {
        const found = findNode(stateTree, selectedDisplaySlotFolderId);
        const title = found && found.node ? found.node.title : '(section)';
        setInfoSelection(`Selection: display | ${title}`);
        return;
      }
      if (!selectedId) {
        setInfoSelection('Selection: (none)');
        return;
      }
      const found = findNode(stateTree, selectedId);
      if (!found) {
        setInfoSelection('Selection: (none)');
        return;
      }
      const kind = found.node.type === 'folder' ? 'section' : 'page';
      const file = found.node.file ? ` | file: ./${found.node.file}` : '';
      const segment = found.node.segment ? ` | dir: ${found.node.segment}` : '';
      setInfoSelection(`Selection: ${kind} | ${found.node.title}${segment}${file}`);
    }

	    function selectNode(id) {
	      selectedId = id || '';
	      selectedIds = new Set(selectedId ? [selectedId] : []);
	      selectionAnchorId = selectedId;
	      selectionParentKey = selectionKeyForId(selectedId);
	      selectedDisplaySlotFolderId = '';
	      syncSelectionClasses();
	    }

	    function clearSelection() {
	      selectedId = '';
	      selectedIds = new Set();
	      selectionAnchorId = '';
	      selectionParentKey = '';
	      selectedDisplaySlotFolderId = '';
	      syncSelectionClasses();
	    }

    function selectionKeyForId(id) {
      if (!id) return '';
      const info = findNode(stateTree, id);
      if (!info) return '';
      return info.parent ? `p:${info.parent.id}` : 'root';
    }

	    function syncSelectionClasses() {
	      document.querySelectorAll('#tree li.node.selected').forEach(el => el.classList.remove('selected'));
	      document.querySelectorAll('#tree .overview-inline.selected').forEach(el => el.classList.remove('selected'));
	      for (const id of (selectedIds || [])) {
	        const el = document.querySelector(`#tree li.node[data-id="${CSS.escape(id)}"]`);
	        if (el) el.classList.add('selected');
	        const ov = document.querySelector(`#tree .overview-inline[data-overview-id="${CSS.escape(id)}"]`);
	        if (ov) ov.classList.add('selected');
	      }
	      if (selectedDisplaySlotFolderId) {
	        const slot = document.querySelector(`#tree .overview-inline[data-folder-id="${CSS.escape(selectedDisplaySlotFolderId)}"]`);
	        if (slot) slot.classList.add('selected');
	      }
	      updateSelectionInfo();
	    }

    function selectWithModifiers(id, e) {
      const isMeta = !!(e && (e.metaKey || e.ctrlKey));
      const isShift = !!(e && e.shiftKey);
      const key = selectionKeyForId(id);
      if (!id) return;

      // First selection.
      if (!selectedIds || selectedIds.size === 0) {
        selectedId = id;
        selectedIds = new Set([id]);
        selectionAnchorId = id;
        selectionParentKey = key;
        syncSelectionClasses();
        return;
      }

      // Restrict multi-select to the same parent (same siblings list).
      if (selectionParentKey && key && selectionParentKey !== key) {
        selectedId = id;
        selectedIds = new Set([id]);
        selectionAnchorId = id;
        selectionParentKey = key;
        syncSelectionClasses();
        return;
      }

      if (isShift && selectionAnchorId) {
        const anchorInfo = findNode(stateTree, selectionAnchorId);
        const targetInfo = findNode(stateTree, id);
        if (!anchorInfo || !targetInfo) return;
        const sameParent = (anchorInfo.parent ? anchorInfo.parent.id : 'root') === (targetInfo.parent ? targetInfo.parent.id : 'root');
        if (!sameParent) {
          selectedId = id;
          selectedIds = new Set([id]);
          selectionAnchorId = id;
          selectionParentKey = key;
          syncSelectionClasses();
          return;
        }
        const siblings = anchorInfo.siblings || [];
        const a = siblings.findIndex(n => n.id === selectionAnchorId);
        const b = siblings.findIndex(n => n.id === id);
        if (a < 0 || b < 0) return;
        const lo = Math.min(a, b);
        const hi = Math.max(a, b);
        const next = new Set();
        for (let i = lo; i <= hi; i++) next.add(siblings[i].id);
        selectedIds = next;
        selectedId = id;
        selectionParentKey = key;
        syncSelectionClasses();
        return;
      }

      if (isMeta) {
        const next = new Set(selectedIds || []);
        if (next.has(id)) next.delete(id);
        else next.add(id);
        selectedIds = next;
        selectedId = id;
        selectionAnchorId = id;
        selectionParentKey = key;
        if (!selectedIds.size) {
          selectedId = '';
          selectionAnchorId = '';
          selectionParentKey = '';
        }
        syncSelectionClasses();
        return;
      }

      // Plain click: single select.
      selectedId = id;
      selectedIds = new Set([id]);
      selectionAnchorId = id;
      selectionParentKey = key;
      syncSelectionClasses();
    }

    function persistTreeCollapsed() {
      localStorage.setItem('page_tree_tree_collapsed', JSON.stringify(Array.from(treeCollapsed)));
    }

    function toggleTreeDir(id) {
      if (!id) return;
      if (treeCollapsed.has(id)) treeCollapsed.delete(id);
      else treeCollapsed.add(id);
      persistTreeCollapsed();
      renderTree();
    }

    function displayTitleForNode(node) {
      const title = String((node && node.title) || '').trim();
      if (!title) return '(untitled)';
      if (title.includes('/') || title.includes('\\')) {
        const parts = title.replace(/\\/g, '/').split('/');
        return parts[parts.length - 1] || title;
      }
      return title;
    }

	    function buildTreeList(nodes, isRoot = false, depth = 0) {
	      const ul = document.createElement('ul');
	      ul.className = isRoot ? 'tree-root tree-explorer' : 'tree-children tree-explorer';
	      for (const node of (nodes || [])) {
        const li = document.createElement('li');
        li.className = 'node tree-item ' + (node.type === 'folder' ? 'dir' : 'page');
        li.draggable = true;
        li.dataset.id = node.id || '';
        li.dataset.type = node.type || 'page';
        li.dataset.title = node.title || '';
        li.dataset.segment = node.segment || '';
        li.dataset.file = node.file || '';

        if ((selectedIds && selectedIds.has(li.dataset.id)) || li.dataset.id === selectedId) li.classList.add('selected');

	        const row = document.createElement('div');
	        row.className = 'row tree-row ' + (node.type === 'folder' ? 'kind-dir' : 'kind-file');
	        row.style.paddingLeft = `${8 + depth * 8}px`;
        row.addEventListener('click', (e) => {
          e.stopPropagation();
          if (activeInlineEdit) return;
          selectWithModifiers(li.dataset.id, e);
        });

	        const left = document.createElement('div');
	        left.className = 'row-left';

	        const twist = document.createElement('span');
	        twist.className = 'tree-twist';
	        const isFolder = node.type === 'folder';
	        const collapsed = isFolder && treeCollapsed.has(li.dataset.id);
	        const allowedByDepth = (depth + 2) <= maxLevelValue();
	        const canExpand = isFolder && allowedByDepth;
	        twist.textContent = isFolder ? (collapsed ? 'â–¸' : 'â–¾') : '';
        twist.addEventListener('click', (e) => {
          e.stopPropagation();
          if (!isFolder) return;
          if (!canExpand) {
            setStatus(`Depth limited to ${treeMaxLevel === 'n' ? 'âˆ' : treeMaxLevel} levels.`, 'info');
            return;
          }
          toggleTreeDir(li.dataset.id);
        });
	        left.appendChild(twist);

	        const icon = document.createElement('span');
	        icon.className = 'tree-icon';
	        icon.textContent = isFolder ? 'ğŸ“š' : 'ğŸ“';
	        left.appendChild(icon);

		        const title = document.createElement('span');
		        title.className = 'node-title';
		        title.textContent = node && node.is_overview ? '' : displayTitleForNode(node);
	        title.addEventListener('dblclick', (e) => {
	          e.stopPropagation();
	          selectedId = li.dataset.id;
	          if (node && node.is_overview) return;
	          beginInlineEdit(li.dataset.id, 'title', title);
	        });
		        left.appendChild(title);

	        row.appendChild(left);

	        // Section overview slot (title-less): inline with section header.
	        if (isFolder) {
	          const children = Array.isArray(node.children) ? node.children : [];
	          const overview = children.find(c => c && c.type === 'page' && c.is_overview) || null;
	          const slot = document.createElement('div');
	          slot.className = 'overview-inline';
	          slot.dataset.overviewId = overview && overview.id ? String(overview.id) : '';
	          slot.dataset.folderId = li.dataset.id || '';
	          // Prevent row click/drag handlers from swallowing slot interactions.
	          slot.addEventListener('pointerdown', (e) => e.stopPropagation());
	          const label = document.createElement('span');
	          label.className = 'overview-label';
	          label.textContent = 'Display';
	          slot.appendChild(label);

	          const value = document.createElement('span');
	          value.className = 'overview-value';
	          slot.appendChild(value);

	          if (overview && overview.file) {
	            slot.classList.add('has-overview');
	            if ((selectedIds && selectedIds.has(overview.id)) || selectedId === overview.id) slot.classList.add('selected');
	            value.textContent = `./${String(overview.file).replace(/^\.\//, '')}`;
	            slot.title = value.textContent;
	            slot.addEventListener('click', (e) => {
	              e.stopPropagation();
	              if (activeInlineEdit) return;
	              selectedDisplaySlotFolderId = '';
	              selectNode(overview.id);
	            });
	            slot.addEventListener('dblclick', (e) => {
	              e.stopPropagation();
	              if (activeInlineEdit) return;
	              selectedId = overview.id;
	              beginInlineEdit(overview.id, 'file', value);
	            });
		          } else {
		            slot.classList.add('empty');
		            value.textContent = '(none)';
		            slot.addEventListener('click', (e) => {
		              e.stopPropagation();
		              if (activeInlineEdit) return;
		              const folderId = li.dataset.id || '';
		              // Select the display slot itself (no page exists yet).
		              selectedId = '';
		              selectedIds = new Set();
		              selectionAnchorId = '';
		              selectionParentKey = '';
		              selectedDisplaySlotFolderId = folderId;
		              syncSelectionClasses();
		            });
		          }
	          row.appendChild(slot);
	        }

	        // Pages show file location; folders don't need to show "path/meta".
	        const meta = document.createElement('span');
	        meta.className = 'node-meta';
        if (isFolder) {
          meta.textContent = folderDirForId(li.dataset.id) || (node.segment ? `${node.segment}` : '');
          meta.addEventListener('dblclick', (e) => {
            e.stopPropagation();
            selectedId = li.dataset.id;
            beginInlineEdit(li.dataset.id, 'segment', meta);
          });
          row.appendChild(meta);
        } else {
          meta.textContent = node.file ? `./${node.file}` : '';
          meta.addEventListener('dblclick', (e) => {
            e.stopPropagation();
            selectedId = li.dataset.id;
            beginInlineEdit(li.dataset.id, 'file', meta);
          });
          row.appendChild(meta);
        }

        li.appendChild(row);

	        li.addEventListener('dragstart', onDragStart);
		        li.addEventListener('dragend', onDragEnd);

		        if (node.type === 'folder') {
		          const children = Array.isArray(node.children) ? node.children : [];
		          // Overview page is rendered in the header slot, not in the list.
		          const rest = children.filter(c => !(c && c.type === 'page' && c.is_overview));
		          const collapsed = treeCollapsed.has(li.dataset.id);
		          if (!collapsed && canExpand) {
		            li.appendChild(buildTreeList(rest, false, depth + 1));
		          } else {
	            // Keep an empty children container so folder still shows as a folder
	            // but without large nested blocks.
	            const emptyUl = document.createElement('ul');
	            emptyUl.className = 'tree-children tree-explorer is-collapsed';
            li.appendChild(emptyUl);
          }
        }
        ul.appendChild(li);
      }
      return ul;
    }

    function onDragStart(e) {
      // dragstart bubbles: prevent parent <li> handlers from overwriting draggedId
      e.stopPropagation();
      if (activeInlineEdit) {
        e.preventDefault();
        return;
      }
      if (e.currentTarget && e.currentTarget.classList && e.currentTarget.classList.contains('is-editing')) {
        e.preventDefault();
        return;
      }
      const id = e.currentTarget.dataset.id || '';
      if (selectedIds && selectedIds.size > 1 && selectedIds.has(id)) {
        draggedIds = Array.from(selectedIds);
      } else {
        draggedIds = id ? [id] : [];
        if (id && (!selectedIds || !selectedIds.has(id))) selectNode(id);
      }
      draggedId = draggedIds[0] || id || '';
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', draggedId);
      e.currentTarget.classList.add('dragging');
      pushDebug('drag.start', { draggedId, draggedIds, type: e.currentTarget.dataset.type || '', title: e.currentTarget.dataset.title || '' });
    }

    function onDragEnd(e) {
      // dragend bubbles too; keep state consistent
      e.stopPropagation();
      if (e && e.currentTarget) e.currentTarget.classList.remove('dragging');
      draggedId = '';
      draggedIds = [];
      clearDropVisual();
      pushDebug('drag.end', {});
    }

    function onTreeDragLeave(e) {
      if (!e) return;
      const related = e.relatedTarget;
      if (related && els.tree.contains(related)) {
        return;
      }
      clearDropVisual();
    }

    function onTreeDragOver(e) {
      if (!draggedId) return;
      e.preventDefault();
      updateDropHintFromPointer(e.clientX, e.clientY);
    }

	    function onTreeDrop(e) {
	      if (!draggedId) return;
	      e.preventDefault();
	      pushDebug('drop.before', { draggedId, dropHint });
	      applyDrop();
	      clearDropVisual();
	      renderTree();
	      if (dragMode === 'nav_only') {
	        scheduleNavOnly('drag.drop.nav_only');
	      } else {
	        scheduleDragFilesSync('drag.drop.files');
	      }
	    }

	    function collectDraggedIdsForSync() {
	      const ids = (draggedIds && draggedIds.length) ? draggedIds : (draggedId ? [draggedId] : []);
	      return Array.from(new Set((ids || []).filter(Boolean)));
	    }

	    async function scheduleDragFilesSync(reason) {
	      if (autoSyncTimer) clearTimeout(autoSyncTimer);
	      const movedIds = collectDraggedIdsForSync();
	      autoSyncTimer = setTimeout(async () => {
	        autoSyncTimer = null;
	        pushDebug('auto_sync.run', { mode: 'drag_files', reason, movedIds });
	        setStatus('Syncing drag...', 'info');
	        try {
	          const data = await fetchJson('/api/sync_drag_files', {
	            method: 'POST',
	            headers: { 'Content-Type': 'application/json' },
	            body: JSON.stringify({ tree: stateTree, moved_ids: movedIds })
	          });
	          const moves = Array.isArray(data.moves) ? data.moves : [];
	          setStatus(`Drag synced.${moves.length ? ` moved:${moves.length}` : ''}`, 'success');
	          await loadState({ reset: false });
	          await loadSource();
	        } catch (e) {
	          const data = e && e.data ? e.data : null;
	          if (data && Array.isArray(data.collisions) && data.collisions.length) {
	            setStatus(`Drag blocked: file conflict (${data.collisions.length}). No changes applied.`, 'error');
	            pushDebug('drag.sync.blocked', { collisions: data.collisions });
	            await loadState({ reset: true });
	            await loadSource();
	            return;
	          }
	          setStatus(e.message || 'Drag sync failed.', 'error');
	        }
	      }, 250);
	    }

    function updateDropHintFromPointer(clientX, clientY) {
      const el = document.elementFromPoint(clientX, clientY);
      if (!el) {
        dropHint = { mode: 'root', targetId: '' };
        showRootDrop();
        logDropHint('root', '');
        return;
      }

      const li = el.closest('#tree li.node');
      if (!li) {
        // Over whitespace: if inside a folder's children box, treat as inside; otherwise root.
        const ul = el.closest('#tree ul');
        const parentFolder = ul ? ul.closest('li[data-type="folder"]') : null;
        if (parentFolder) {
          const folderId = parentFolder.dataset.id || '';
          dropHint = { mode: 'inside', targetId: folderId };
          showInside(parentFolder);
          logDropHint('inside', folderId);
        } else {
          dropHint = { mode: 'root', targetId: '' };
          showRootDrop();
          logDropHint('root', '');
        }
        return;
      }

      const targetId = li.dataset.id || '';
      const type = li.dataset.type || 'page';
      const row = li.querySelector(':scope > .row') || li;
      const rowRect = row.getBoundingClientRect();
      const ratio = rowRect.height ? ((clientY - rowRect.top) / rowRect.height) : 0.5;

      const inChildrenBox = type === 'folder' && (() => {
        const childUl = li.querySelector(':scope > ul');
        return childUl && childUl.contains(el) && !row.contains(el);
      })();

      if (inChildrenBox) {
        dropHint = { mode: 'inside', targetId };
        showInside(li);
        logDropHint('inside', targetId);
        return;
      }

      let mode = 'inside';
      if (ratio <= 0.25) mode = 'before';
      else if (ratio >= 0.75) mode = 'after';
      if (type === 'page' && mode === 'inside') mode = ratio < 0.5 ? 'before' : 'after';

      dropHint = { mode, targetId };
      if (mode === 'inside') showInside(li);
      else showLineAt(rowRect, mode === 'after');
      logDropHint(mode, targetId);
    }

    function logDropHint(mode, targetId) {
      const sig = `${mode}::${targetId}::${draggedId}::${(draggedIds || []).join(',')}`;
      const now = Date.now();
      if (sig === lastDropHintSignature && now - lastDragoverLogAt < 120) return;
      lastDropHintSignature = sig;
      lastDragoverLogAt = now;
      const target = targetId ? findNode(stateTree, targetId) : null;
      pushDebug('drag.over', {
        draggedId,
        draggedIds,
        mode,
        targetId,
        targetTitle: target ? target.node.title : null,
        targetType: target ? target.node.type : null
      });
    }

    function applyDrop() {
      const { mode, targetId } = dropHint || {};
      if (!mode) return;

      // Never allow moving into/self/descendant; treat as no-op (keeps detector free).
      const ids = (draggedIds && draggedIds.length) ? draggedIds : (draggedId ? [draggedId] : []);
      const descendant = targetId ? ids.some(id => isDescendant(id, targetId)) : false;
      const selfHit = targetId ? ids.includes(targetId) : false;
      if (targetId && (selfHit || descendant)) {
        const dragged = findNode(stateTree, draggedId);
        const target = findNode(stateTree, targetId);
        pushDebug('drop.noop', {
          reason: selfHit ? 'self_or_group' : 'target_is_descendant',
          mode,
          draggedId,
          draggedIds: ids,
          draggedTitle: dragged ? dragged.node.title : null,
          draggedPath: nodePath(draggedId),
          targetId,
          targetTitle: target ? target.node.title : null,
          targetPath: nodePath(targetId),
        });
        setStatus(targetId === draggedId ? 'Invalid: dropped on itself.' : 'Invalid: cannot drop a parent into its child.', 'info');
        return;
      }

      if (mode === 'root') {
        pushDebug('drop.apply', { mode, targetId: '' });
        withHistory('drop.root', () => moveNodes(ids, '', 'root'));
        setStatus('Moved.', 'success');
        return;
      }
      if (mode === 'inside') {
        pushDebug('drop.apply', { mode, targetId });
        withHistory('drop.inside', () => moveNodes(ids, targetId, 'inside'));
        setStatus('Moved.', 'success');
        return;
      }
      if (mode === 'before' || mode === 'after') {
        pushDebug('drop.apply', { mode, targetId });
        withHistory(`drop.${mode}`, () => moveNodes(ids, targetId, mode));
        setStatus('Moved.', 'success');
      }
    }

	    function moveNodes(ids, targetId, mode) {
	      const list = Array.from(new Set((ids || []).filter(Boolean)));
	      if (!list.length) return;

	      // Overview pages are special:
	      // - They cannot be swapped/reordered within a section.
	      // - If moved out of their section, they become normal pages.
	      const asNodes = list.map(id => {
	        const found = findNode(stateTree, id);
	        return found ? found.node : null;
	      }).filter(Boolean);

	      if (mode === 'root') {
	        const ctxs = detachManyWithContext(list);
	        for (const ctx of ctxs) {
	          if (ctx.node && ctx.node.is_overview) ctx.node.is_overview = false;
	          stateTree.push(ctx.node);
	        }
	        return;
	      }

	      if (mode === 'inside') {
	        const targetInfo = findNode(stateTree, targetId);
	        if (!targetInfo || targetInfo.node.type !== 'folder') return;
	        targetInfo.node.children = Array.isArray(targetInfo.node.children) ? targetInfo.node.children : [];
	        const overviewIdx = targetInfo.node.children.findIndex(n => n && n.type === 'page' && n.is_overview);
	        const ctxs = detachManyWithContext(list);
	        for (const ctx of ctxs) {
	          if (ctx.node && ctx.node.is_overview) ctx.node.is_overview = false;
	          if (overviewIdx >= 0) targetInfo.node.children.splice(overviewIdx + 1, 0, ctx.node);
	          else targetInfo.node.children.push(ctx.node);
	        }
	        return;
	      }

	      if (mode === 'before' || mode === 'after') {
	        // Detach first, then re-find target to get correct index after removal.
	        const ctxs = detachManyWithContext(list);
	        const targetInfo = findNode(stateTree, targetId);
	        if (!targetInfo) return;
	        const siblings = targetInfo.siblings;
	        const idx = siblings.findIndex(n => n.id === targetId);
	        if (idx < 0) return;
	        let insertAt = mode === 'before' ? idx : idx + 1;
	        const overviewAt = siblings.findIndex(n => n && n.type === 'page' && n.is_overview);
	        if (overviewAt >= 0 && insertAt <= overviewAt + 0) {
	          // Never insert before the overview slot.
	          insertAt = overviewAt + 1;
	        }
	        for (const ctx of ctxs) {
	          if (ctx.node && ctx.node.is_overview) {
	            // Prevent reordering overview within the same siblings list.
	            // If it was detached, re-insert it at its original slot (front).
	            siblings.splice(0, 0, ctx.node);
	            continue;
	          }
	          siblings.splice(insertAt, 0, ctx.node);
	          insertAt += 1;
	        }
	      }
	    }

    function isDescendant(dragId, targetId) {
      const drag = findNode(stateTree, dragId);
      const target = findNode(stateTree, targetId);
      if (!drag || !target) return false;
      let p = target.parent;
      while (p) {
        if (p.id === drag.node.id) return true;
        const parentInfo = findNode(stateTree, p.id);
        p = parentInfo ? parentInfo.parent : null;
      }
      return false;
    }

    function detachNode(id) {
      const found = findNode(stateTree, id);
      if (!found) return null;
      const idx = found.siblings.findIndex(n => n.id === id);
      if (idx < 0) return null;
      return found.siblings.splice(idx, 1)[0];
    }

    function detachNodeWithContext(id) {
      const found = findNode(stateTree, id);
      if (!found) return null;
      const idx = found.siblings.findIndex(n => n.id === id);
      if (idx < 0) return null;
      const node = found.siblings.splice(idx, 1)[0];
      return { node, siblings: found.siblings, index: idx };
    }

    function detachManyWithContext(ids) {
      const contexts = [];
      const byParent = new Map();
      for (const id of (ids || [])) {
        const found = findNode(stateTree, id);
        if (!found) continue;
        const idx = found.siblings.findIndex(n => n.id === id);
        if (idx < 0) continue;
        const parentKey = found.parent ? found.parent.id : 'root';
        if (!byParent.has(parentKey)) byParent.set(parentKey, []);
        byParent.get(parentKey).push({ id, siblings: found.siblings, index: idx });
      }

      // Detach in descending index per parent to keep indices valid.
      for (const group of byParent.values()) {
        group.sort((a, b) => b.index - a.index);
        for (const item of group) {
          const node = item.siblings.splice(item.index, 1)[0];
          contexts.push({ id: item.id, node, fromIndex: item.index });
        }
      }

      // Return in ascending original index order (stable visual order within parent).
      contexts.sort((a, b) => a.fromIndex - b.fromIndex);
      return contexts;
    }

    function nodePath(id) {
      if (!id) return [];
      const found = findNode(stateTree, id);
      if (!found) return [];
      const parts = [found.node.title || found.node.id];
      let p = found.parent;
      while (p) {
        parts.push(p.title || p.id);
        const parentInfo = findNode(stateTree, p.id);
        p = parentInfo ? parentInfo.parent : null;
      }
      return parts.reverse();
    }

    function restoreDetached(ctx) {
      if (!ctx || !ctx.node || !ctx.siblings) return;
      const idx = typeof ctx.index === 'number' ? ctx.index : ctx.siblings.length;
      ctx.siblings.splice(Math.min(Math.max(idx, 0), ctx.siblings.length), 0, ctx.node);
    }

    function moveNodeToRoot(id) {
      const ctx = detachNodeWithContext(id);
      if (!ctx) return;
      pushDebug('move.root', { id, title: ctx.node.title, fromIndex: ctx.index, fromPath: nodePath(id) });
      stateTree.push(ctx.node);
      pushDebug('move.root.done', { rootCount: stateTree.length });
    }

    function moveIntoFolder(dragId, folderId) {
      const folder = findNode(stateTree, folderId);
      if (!folder || folder.node.type !== 'folder') return;
      const ctx = detachNodeWithContext(dragId);
      if (!ctx) return;
      folder.node.children = Array.isArray(folder.node.children) ? folder.node.children : [];
      pushDebug('move.inside', {
        dragId,
        folderId,
        fromPath: nodePath(dragId),
        toPath: nodePath(folderId),
        insertIndex: folder.node.children.length
      });
      folder.node.children.push(ctx.node);
    }

    function moveNode(dragId, targetId, mode) {
      const targetInfo = findNode(stateTree, targetId);
      if (!targetInfo) return;
      const ctx = detachNodeWithContext(dragId);
      if (!ctx) return;

      if (mode === 'inside' && targetInfo.node.type === 'folder') {
        targetInfo.node.children = Array.isArray(targetInfo.node.children) ? targetInfo.node.children : [];
        targetInfo.node.children.push(ctx.node);
        return;
      }
      const siblings = targetInfo.siblings;
      const idx = siblings.findIndex(n => n.id === targetId);
      if (idx < 0) {
        pushDebug('move.restore', { reason: 'target_missing', dragId, targetId });
        restoreDetached(ctx);
        return;
      }
      pushDebug('move.sibling', {
        dragId,
        targetId,
        mode,
        targetIndex: idx,
        insertIndex: mode === 'before' ? idx : idx + 1,
        toParent: targetInfo.parent ? (targetInfo.parent.title || targetInfo.parent.id) : null
      });
      siblings.splice(mode === 'before' ? idx : idx + 1, 0, ctx.node);
    }

    function clearDropVisual() {
      dropHint = { mode: null, targetId: null };
      els.tree.classList.remove('drop-root');
      hideDropLine();
      document.querySelectorAll('#tree .drop-before, #tree .drop-after, #tree .drop-inside')
        .forEach(el => el.classList.remove('drop-before', 'drop-after', 'drop-inside'));
    }

    function hideDropLine() {
      if (!dropLineEl) return;
      dropLineEl.style.display = 'none';
    }

    function showRootDrop() {
      els.tree.classList.add('drop-root');
      hideDropLine();
      document.querySelectorAll('#tree .drop-inside').forEach(el => el.classList.remove('drop-inside'));
    }

    function showInside(li) {
      els.tree.classList.remove('drop-root');
      hideDropLine();
      document.querySelectorAll('#tree .drop-inside').forEach(el => el.classList.remove('drop-inside'));
      if (li) li.classList.add('drop-inside');
    }

    function showLineAt(targetRect, placeAfter) {
      els.tree.classList.remove('drop-root');
      document.querySelectorAll('#tree .drop-inside').forEach(el => el.classList.remove('drop-inside'));
      if (!dropLineEl) return;
      const containerRect = els.tree.getBoundingClientRect();
      const y = (placeAfter ? targetRect.bottom : targetRect.top) - containerRect.top + els.tree.scrollTop;
      dropLineEl.style.top = (y - 1) + 'px';
      dropLineEl.style.display = 'block';
    }

	    async function createNode(type) {
	      const creatingDisplay = type === 'page' && !!selectedDisplaySlotFolderId;
	      const title = creatingDisplay ? 'Overview' : prompt(type === 'folder' ? 'Section title:' : 'Page title:');
	      if (!title || !title.trim()) return;

	      const parentDir = (() => {
	        if (selectedDisplaySlotFolderId) return folderDirForId(selectedDisplaySlotFolderId);
	        if (!selectedId) return '';
	        const info = findNode(stateTree, selectedId);
	        if (!info) return '';
	        if (info.node.type === 'folder') return folderDirForId(info.node.id);
	        if (info.parent && info.parent.type === 'folder') return folderDirForId(info.parent.id);
	        return '';
	      })();

	      let newId = '';
	      withHistory('create', () => {
	        const parentInfo = selectedDisplaySlotFolderId
	          ? findNode(stateTree, selectedDisplaySlotFolderId)
	          : (selectedId ? findNode(stateTree, selectedId) : null);
	        let container = stateTree;
	        if (parentInfo) {
	          if (parentInfo.node.type === 'folder') {
	            parentInfo.node.children = Array.isArray(parentInfo.node.children) ? parentInfo.node.children : [];
	            container = parentInfo.node.children;
	          } else if (parentInfo.parent && parentInfo.parent.type === 'folder') {
	            parentInfo.parent.children = Array.isArray(parentInfo.parent.children) ? parentInfo.parent.children : [];
	            container = parentInfo.parent.children;
	          }
	        }

	        const id = crypto && crypto.randomUUID ? crypto.randomUUID().replace(/-/g, '') : String(Date.now());
	        newId = id;
	        if (type === 'folder') {
	          container.push({ id, type: 'folder', title: title.trim(), segment: '', file: null, children: [] });
	        } else {
	          // If user clicked an empty Display slot, create a dedicated overview page (title-less, fixed slot).
	          if (creatingDisplay) {
	            const already = container.find(n => n && n.type === 'page' && n.is_overview);
	            if (!already) container.unshift({ id, type: 'page', title: '', is_overview: true, file: null, file_prev: null, segment: null, children: [] });
	          } else {
	            container.push({ id, type: 'page', title: title.trim(), file: null, file_prev: null, segment: null, children: [] });
	          }
	        }
	      });
	      renderTree();
	      updateHistoryButtons();

	      // Create on disk immediately.
	      if (type === 'folder') {
	        try {
	          const data = await fetchJson('/api/create_section', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ title: title.trim(), parent_dir: parentDir })
          });
	          const found = findNode(stateTree, newId);
	          if (found && found.node && found.node.type === 'folder') {
	            found.node.segment = data.segment || found.node.segment || '';
	          }
	          // Create default section README (overview) as the first page under this folder.
	          const newFolderDir = folderDirForId(newId);
	          const pageId = crypto && crypto.randomUUID ? crypto.randomUUID().replace(/-/g, '') : String(Date.now() + 1);
	          withHistory('create.section_overview', () => {
	            const info = findNode(stateTree, newId);
	            if (!info || !info.node || info.node.type !== 'folder') return;
	            info.node.children = Array.isArray(info.node.children) ? info.node.children : [];
	            info.node.children.unshift({ id: pageId, type: 'page', title: '', is_overview: true, file: null, file_prev: null, segment: null, children: [] });
	          });
	          renderTree();
	          updateHistoryButtons();
	          try {
	            const pageData = await fetchJson('/api/create_page', {
	              method: 'POST',
	              headers: { 'Content-Type': 'application/json' },
	              body: JSON.stringify({ title: 'Overview', parent_dir: newFolderDir, basename: 'README.md' })
	            });
	            const pageFound = findNode(stateTree, pageId);
	            if (pageFound && pageFound.node && pageFound.node.type === 'page') {
	              pageFound.node.file = pageData.file || pageFound.node.file;
	              pageFound.node.file_prev = null;
	            }
	          } catch (e) {
	            pushDebug('create.section_overview.failed', { error: e.message || String(e) });
	          }
	          renderTree();
	          await loadSource();
	          setStatus('Section created on disk.', 'success');
	          scheduleNavOnly('create.section');
	        } catch (e) {
          setStatus(e.message || 'Create section failed.', 'error');
        }
        return;
      }

	      try {
	        const data = await fetchJson('/api/create_page', {
	          method: 'POST',
	          headers: { 'Content-Type': 'application/json' },
	          body: JSON.stringify(creatingDisplay
	            ? { title: 'Overview', parent_dir: parentDir, basename: 'README.md' }
	            : { title: title.trim(), parent_dir: parentDir })
	        });
	        const found = findNode(stateTree, newId);
	        if (found && found.node && found.node.type === 'page') {
	          found.node.file = data.file || found.node.file;
	          found.node.file_prev = null;
	          if (creatingDisplay) found.node.is_overview = true;
	        }
	        renderTree();
	        await loadSource();
	        setStatus(creatingDisplay ? 'Display page created.' : 'Page created on disk.', 'success');
	        scheduleNavOnly(creatingDisplay ? 'create.display' : 'create.page');
	      } catch (e) {
	        setStatus(e.message || 'Create page failed.', 'error');
	      }
	    }

    function renameSelected() {
      if (!selectedId) return setStatus('Select a node first.', 'info');
      const rowTitle = document.querySelector(`#tree li[data-id="${selectedId}"] .node-title`);
      if (!rowTitle) return setStatus('Selected node not visible (expand parent folders).', 'info');
      beginInlineEdit(selectedId, 'title', rowTitle);
    }

    function beginInlineEdit(id, field, hostEl) {
      if (!id || !hostEl) return;
      const info = findNode(stateTree, id);
      if (!info) return setStatus('Node not found.', 'error');

      if (activeInlineEdit && activeInlineEdit.id === id && activeInlineEdit.field === field) return;
      if (activeInlineEdit) cancelInlineEdit();

      const li = hostEl.closest('li.node');
      if (!li) return;

      const originalValue =
        field === 'file' ? (info.node.file || '') :
          field === 'segment' ? (info.node.segment || '') :
            (info.node.title || '');
      const originalDir = (() => {
        if (field !== 'file') return '';
        const p = String(originalValue || '').replace(/^\.\//, '');
        const idx = p.lastIndexOf('/');
        return idx >= 0 ? p.slice(0, idx + 1) : '';
      })();
      const startValue =
        field === 'file' ? (() => {
          const p = String(originalValue || '').replace(/^\.\//, '');
          const idx = p.lastIndexOf('/');
          return idx >= 0 ? p.slice(idx + 1) : p;
        })() :
          field === 'segment' ? originalValue :
            displayTitleForNode(info.node);

      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'inline-edit';
      input.value = startValue;
      input.spellcheck = false;
      input.draggable = false;

      const prevText = hostEl.textContent || '';
      hostEl.textContent = '';
      hostEl.appendChild(input);

      const prevDraggable = li.draggable;
      li.draggable = false;
      li.classList.add('is-editing');

      activeInlineEdit = { id, field, hostEl, input, prevText, prevDraggable, originalValue, originalDir };

      const finish = (mode) => {
        if (!activeInlineEdit) return;
        const current = activeInlineEdit;
        if (current.input) current.input.removeEventListener('keydown', onKeyDown);
        if (current.input) current.input.removeEventListener('blur', onBlur);
        li.draggable = current.prevDraggable;
        li.classList.remove('is-editing');
        const value = (current.input && current.input.value ? current.input.value : '').trim();
        activeInlineEdit = null;

        if (mode === 'cancel') {
          current.hostEl.textContent = current.prevText;
          return;
        }

        if (current.field === 'title') {
          if (!value) {
            current.hostEl.textContent = current.prevText;
            return;
          }
          withHistory('edit.title', () => {
            const nodeInfo = findNode(stateTree, current.id);
            if (nodeInfo) nodeInfo.node.title = value;
          });
          renderTree();
          updateHistoryButtons();
          setStatus('Renamed.', 'success');
          scheduleNavOnly('rename.title');
          return;
        }

        if (current.field === 'segment') {
          if (value.includes('/') || value.includes('\\')) {
            setStatus('Folder name cannot contain slashes.', 'error');
            current.hostEl.textContent = current.prevText;
            return;
          }
          const oldDir = folderDirForId(current.id);
          const newSeg = value.trim();
          (async () => {
            setStatus('Renaming folder...', 'info');
            try {
              const data = await fetchJson('/api/rename_dir', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ dir: oldDir, new_segment: newSeg })
              });
              const newDir = data.dir || oldDir;
              withHistory('edit.segment', () => {
                const nodeInfo = findNode(stateTree, current.id);
                if (!nodeInfo) return;
                nodeInfo.node.segment = data.segment || newSeg;
                updateDescendantPagePaths(current.id, oldDir, newDir);
              });
              renderTree();
              updateHistoryButtons();
              await loadSource();
              setStatus('Folder renamed on disk.', 'success');
              scheduleNavOnly('rename.segment');
            } catch (e) {
              setStatus(e.message || 'Rename folder failed.', 'error');
              renderTree();
            }
          })();
          return;
        }

        if (current.field === 'file') {
          if (value.includes('/') || value.includes('\\')) {
            setStatus('Filename only (no directories).', 'error');
            current.hostEl.textContent = current.prevText;
            return;
          }
          const oldFile = String(current.originalValue || '').replace(/^\.\//, '').trim();
          const newBase = value.trim();
          if (!oldFile) {
            setStatus('Cannot rename: missing old file path.', 'error');
            return;
          }
          (async () => {
            setStatus('Renaming file...', 'info');
            try {
              const data = await fetchJson('/api/rename_file', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ old_file: oldFile, new_basename: newBase })
              });
              withHistory('edit.file', () => {
                const nodeInfo = findNode(stateTree, current.id);
                if (!nodeInfo) return;
                nodeInfo.node.file = data.file || nodeInfo.node.file;
                nodeInfo.node.file_prev = null;
              });
              renderTree();
              updateHistoryButtons();
              await loadSource();
              setStatus('File renamed on disk.', 'success');
              scheduleNavOnly('rename.file');
            } catch (e) {
              setStatus(e.message || 'Rename file failed.', 'error');
              renderTree();
            }
          })();
          return;
        }
      };

      const onKeyDown = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          finish('commit');
        } else if (e.key === 'Escape') {
          e.preventDefault();
          finish('cancel');
        }
      };
      const onBlur = () => finish('commit');

      input.addEventListener('keydown', onKeyDown);
      input.addEventListener('blur', onBlur);

      requestAnimationFrame(() => {
        input.focus();
        input.select();
      });
    }

    function cancelInlineEdit() {
      if (!activeInlineEdit) return;
      const current = activeInlineEdit;
      const li = current.hostEl.closest('li.node');
      if (current.input) current.input.remove();
      if (li) {
        li.draggable = current.prevDraggable;
        li.classList.remove('is-editing');
      }
      current.hostEl.textContent = current.prevText;
      activeInlineEdit = null;
    }

    function updateDescendantPagePaths(folderId, oldDir, newDir) {
      const info = findNode(stateTree, folderId);
      if (!info || !info.node || info.node.type !== 'folder') return;
      const oldPrefix = oldDir ? `${oldDir.replace(/\\/g, '/')}/` : '';
      const newPrefix = newDir ? `${newDir.replace(/\\/g, '/')}/` : '';
      const walk = (node) => {
        if (!node) return;
        if (node.type === 'page') {
          if (node.file && oldPrefix && node.file.startsWith(oldPrefix)) {
            node.file = newPrefix + node.file.slice(oldPrefix.length);
          }
          if (node.file_prev && oldPrefix && node.file_prev.startsWith(oldPrefix)) {
            node.file_prev = newPrefix + node.file_prev.slice(oldPrefix.length);
          }
          return;
        }
        for (const c of (node.children || [])) walk(c);
      };
      for (const c of (info.node.children || [])) walk(c);
    }

    async function deleteSelected() {
      if ((!selectedId || !findNode(stateTree, selectedId)) && (!selectedIds || !selectedIds.size)) {
        return setStatus('Select a node first.', 'info');
      }
      const ids = selectedIds && selectedIds.size ? Array.from(selectedIds) : [selectedId];
      const folderCheck = classifyFoldersForDelete(ids);
      if (folderCheck.blocking.length) {
        const first = folderCheck.blocking[0];
        return setStatus(`Cannot delete non-empty folder "${first.title}". Move its pages first.`, 'info');
      }

      const filesToDelete = collectFilesForIds(ids);
      const dirsToDelete = folderCheck.emptyDirs;
      const hasFiles = filesToDelete.length > 0;
      const hasDirs = dirsToDelete.length > 0;

      const summary = [
        `Delete ${ids.length} item(s) from the tree`,
        hasFiles ? `delete ${filesToDelete.length} page file(s) on disk` : null,
        hasDirs ? `delete ${dirsToDelete.length} empty folder(s) on disk` : null,
      ].filter(Boolean).join(', ') + '. Continue?';
      const ok = confirm(summary);
      if (!ok) return;
      let removed = null;
      withHistory('delete', () => {
        const ctxs = detachManyWithContext(ids);
        removed = ctxs.length ? { count: ctxs.length } : null;
      });
      clearSelection();
      renderTree();
      updateHistoryButtons();
      setStatus(removed ? `Deleted ${removed.count || 1}.` : 'Not found.', removed ? 'success' : 'info');
      scheduleNavOnly('delete.tree');

      if (hasFiles) await deleteFilesOnDisk(filesToDelete, { deleteAssets: true });
      if (hasDirs) await deleteDirsOnDisk(dirsToDelete);
      if (hasFiles || hasDirs) scheduleNavOnly('delete.disk');
    }

	    function classifyFoldersForDelete(ids) {
	      const blocking = [];
	      const emptyDirs = [];
	      const seenDirs = new Set();

	      function hasNonOverviewPage(folder) {
	        if (!folder || folder.type !== 'folder') return false;
	        const children = Array.isArray(folder.children) ? folder.children : [];
	        const overview = children.find(c => c && c.type === 'page' && c.is_overview) || null;
	        for (const c of children) {
	          if (!c) continue;
	          if (c.type === 'page') {
	            if (overview && c === overview) continue;
	            return true;
	          }
	          if (c.type === 'folder') {
	            if (hasNonOverviewPage(c)) return true;
	          }
	        }
	        return false;
	      }

	      for (const id of (ids || [])) {
	        const found = findNode(stateTree, id);
	        if (!found || !found.node) continue;
	        if (found.node.type !== 'folder') continue;
	        if (hasNonOverviewPage(found.node)) {
	          blocking.push({ id, title: found.node.title || id });
	          continue;
	        }
	        const dir = folderDirForId(id);
        if (dir && !seenDirs.has(dir)) {
          seenDirs.add(dir);
          emptyDirs.push(dir);
        }
      }
      return { blocking, emptyDirs };
    }

    function folderDirForId(id) {
      if (!id) return '';
      const info = findNode(stateTree, id);
      if (!info || !info.node || info.node.type !== 'folder') return '';
      const segs = [];
      const selfSeg = (info.node.segment || '').trim();
      if (selfSeg) segs.push(selfSeg);
      let p = info.parent;
      while (p) {
        if (p.type === 'folder' && p.segment) segs.push(String(p.segment).trim());
        const parentInfo = findNode(stateTree, p.id);
        p = parentInfo ? parentInfo.parent : null;
      }
      return segs.reverse().filter(Boolean).join('/');
    }

    function collectFilesForIds(ids) {
      const out = [];
      const seen = new Set();
      function walk(node) {
        if (!node) return;
        if (node.type === 'page') {
          if (node.file) {
            const rel = String(node.file).replace(/^\.\//, '').trim();
            if (rel && !seen.has(rel)) {
              seen.add(rel);
              out.push(rel);
            }
          }
          return;
        }
        for (const c of (node.children || [])) walk(c);
      }
      for (const id of (ids || [])) {
        const found = findNode(stateTree, id);
        if (!found) continue;
        walk(found.node);
      }
      return out;
    }

    async function deleteFilesOnDisk(files, options) {
      const opts = options || {};
      const deleteAssets = !!opts.deleteAssets;
      setStatus('Deleting files...', 'info');
      try {
        const data = await fetchJson('/api/delete_files', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ files, delete_assets: deleteAssets })
        });
        const deleted = Array.isArray(data.deleted) ? data.deleted : [];
        const errors = Array.isArray(data.errors) ? data.errors : [];
        const msg = `Deleted ${deleted.length} item(s) from disk.${errors.length ? ` errors:${errors.length}` : ''}`;
        setStatus(msg, errors.length ? 'error' : 'success');
        await loadSource();
      } catch (e) {
        setStatus(e.message || 'Delete files failed.', 'error');
      }
    }

    async function deleteDirsOnDisk(dirs) {
      if (!Array.isArray(dirs) || !dirs.length) return;
      setStatus('Deleting empty folders...', 'info');
      try {
        const data = await fetchJson('/api/delete_dirs', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ dirs })
        });
        const deleted = Array.isArray(data.deleted) ? data.deleted : [];
        const errors = Array.isArray(data.errors) ? data.errors : [];
        const msg = `Deleted ${deleted.length} empty folder(s).${errors.length ? ` errors:${errors.length}` : ''}`;
        setStatus(msg, errors.length ? 'error' : 'success');
        await loadSource();
      } catch (e) {
        setStatus(e.message || 'Delete folders failed.', 'error');
      }
    }
  </script>
</body>

</html>
