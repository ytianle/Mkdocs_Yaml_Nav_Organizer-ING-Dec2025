<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>MkDocs Nav Manager</title>
  <link rel="stylesheet" href="/static/style.css">
</head>

<body>
  <div class="shell">
    <header class="toolbar">
      <div class="title">
        <h1>MkDocs Nav Manager</h1>
        <div id="meta" class="muted">Loading...</div>
      </div>
      <div class="inline-actions">
        <button id="toggle-tools" type="button" class="ghost" data-help="Toggle Tools panel">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
            <path d="M3 4h10M3 8h10M3 12h10"/>
            <circle cx="6" cy="4" r="1.2"/>
            <circle cx="10" cy="8" r="1.2"/>
            <circle cx="5" cy="12" r="1.2"/>
          </svg>
        </button>
        <button id="toggle-source" type="button" class="ghost" data-help="Toggle Source panel">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
            <rect x="2" y="3" width="12" height="10" rx="1"/>
            <path d="M2 6h12M6 3v10"/>
          </svg>
        </button>
        <button id="toggle-tree" type="button" class="ghost" data-help="Toggle Doc Tree panel">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M2 3h12M2 8h12M2 13h12"/>
          </svg>
        </button>
        <button id="toggle-info" type="button" class="ghost" data-help="Toggle Info panel">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
            <circle cx="8" cy="8" r="6"/>
            <path d="M8 7v4M8 5v.5"/>
          </svg>
        </button>
        <button id="toggle-simple-editor" type="button" class="ghost" data-help="simple md file editor">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M11.5 2.5l2 2-7 7-2.5.5.5-2.5 7-7z"/>
            <path d="M10 4l2 2"/>
          </svg>
        </button>
        <button id="toggle-theme" type="button" class="ghost" data-help="Toggle theme (Day/Night)">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M8 2a6 6 0 1 0 4.2 10.2A5 5 0 1 1 3.8 3.8 6 6 0 0 0 8 2z"/>
          </svg>
        </button>
        <button id="tool-debug" type="button" class="ghost icon-button" data-help="Toggle debug window (DnD logs)"
          aria-label="Toggle debug">üêû</button>
      </div>
    </header>

    <div id="tool-tooltip" class="tool-tooltip" hidden></div>
    <div id="tree-context" class="context-menu" hidden>
      <button type="button" data-action="new-folder" data-shortcut="Opt(Alt)+Shift+N">üóÇÔ∏è New Section <span class="context-shortcut">Opt(Alt)+Shift+N</span></button>
      <button type="button" data-action="new-page" data-shortcut="Opt(Alt)+N">üìÑ New Page <span class="context-shortcut">Opt(Alt)+N</span></button>
      <button type="button" data-action="new-page-with-folder" data-shortcut="Opt(Alt)+Shift+P">üìÅ Page w/ Folder <span class="context-shortcut">Opt(Alt)+Shift+P</span></button>
      <button type="button" data-action="rename" data-shortcut="F2">‚úèÔ∏è Rename <span class="context-shortcut">F2</span></button>
      <button type="button" data-action="locate" data-shortcut="Opt(Alt)+L">üß≠ Locate <span class="context-shortcut">Opt(Alt)+L</span></button>
      <button type="button" data-action="open" data-shortcut="Opt(Alt)+O">üîé Open <span class="context-shortcut">Opt(Alt)+O</span></button>
      <button type="button" data-action="edit" data-shortcut="Opt(Alt)+E">üìù Edit <span class="context-shortcut">Opt(Alt)+E</span></button>
      <button type="button" data-action="delete" class="danger" data-shortcut="Del/Backspace">üóëÔ∏è Delete <span class="context-shortcut">Del/Backspace</span></button>
    </div>

    <section class="dock-tools tools-toolbar" id="panel-tools">
      <div class="tools-bar" role="toolbar" aria-label="Tools">
        <button id="tool-undo" type="button" class="ghost icon-button" data-help="Undo last change"
          aria-label="Undo">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
            <path d="M5 8h6a3 3 0 0 1 0 6H8" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M7 6l-2 2 2 2" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
        <button id="tool-redo" type="button" class="ghost icon-button" data-help="Redo last undone change"
          aria-label="Redo">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
            <path d="M11 8H5a3 3 0 0 0 0 6h3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M9 6l2 2-2 2" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
        <button id="tool-import" type="button" class="ghost icon-button"
          data-help="Rebuild Doc Tree from mkdocs.yml nav (overwrites current draft)" aria-label="Load mkdocs.yml">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
            <path d="M8 2v8m0 0l3-3m-3 3L5 7" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M3 11v2a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-2" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
          </svg>
        </button>
        <button id="tool-beautify-nav" type="button" class="ghost icon-button"
          data-help="Beautify mkdocs.yml nav formatting (nav block only; no file moves)" aria-label="Beautify nav">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
            <circle cx="8" cy="5" r="2" stroke="currentColor" stroke-width="1.5"/>
            <path d="M4 10c0-2 1.5-3 4-3s4 1 4 3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M3 13l1.5-1.5M13 13l-1.5-1.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
          </svg>
        </button>
      </div>
    </section>

    <div id="workspace" class="workspace">
      <div class="main-grid">
        <section class="card panel" id="panel-source">
          <div class="card-head">
            <h2>Source</h2>
            <div class="inline-actions">
              <span class="muted">Click to locate in tree</span>
              <button id="source-view-btn" type="button" class="ghost"
                data-help="Toggle source view (Explorer / ASCII)">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
                  <path d="M2 4h12M2 8h12M2 12h8"/>
                </svg>
                ASCII
              </button>
            </div>
          </div>
          <div id="source" class="list-shell">Loading...</div>
        </section>

        <div class="splitter splitter-v" id="split-main-left" title="Drag to resize"></div>

	        <section class="card panel" id="panel-tree">
            <div class="card-head">
              <h2>üìö Doc Tree</h2>
              <div class="inline-actions">
	              <label class="switch" title="" data-help="" id="drag-mode-switch">
	                <input id="drag-mode-toggle" type="checkbox" aria-label="Drag mode toggle">
	                <span class="switch-track"></span>
	                <span class="switch-text" id="drag-mode-text">Drag: Files</span>
	              </label>
	              <button id="rainbow-toggle-btn" type="button" class="ghost" data-help="Toggle rainbow level colors">
	                <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
	                  <path d="M2 10a6 6 0 0 1 12 0" stroke="#FF6B6B" stroke-width="1.5" stroke-linecap="round"/>
	                  <path d="M3.5 10a4.5 4.5 0 0 1 9 0" stroke="#FFB84D" stroke-width="1.5" stroke-linecap="round"/>
	                  <path d="M5 10a3 3 0 0 1 6 0" stroke="#50DC8C" stroke-width="1.5" stroke-linecap="round"/>
	                  <path d="M6.5 10a1.5 1.5 0 0 1 3 0" stroke="#6AA9FF" stroke-width="1.5" stroke-linecap="round"/>
	                </svg>
	              </button>
              <div class="segmented" role="group" aria-label="Depth limit">
	                <button type="button" class="ghost depth-btn" data-depth="1" data-help="Show 1 level">1</button>
	                <button type="button" class="ghost depth-btn" data-depth="2" data-help="Show 2 levels">2</button>
	                <button type="button" class="ghost depth-btn" data-depth="3" data-help="Show 3 levels">3</button>
                <button type="button" class="ghost depth-btn" data-depth="4" data-help="Show 4 levels">4</button>
                <button type="button" class="ghost depth-btn" data-depth="5" data-help="Show 5 levels">5</button>
                <button type="button" class="ghost depth-btn" data-depth="n" data-help="Show all levels">‚àû</button>
              </div>
              <button id="new-folder-btn" type="button" data-help="Create a new section under selection" data-shortcut="Opt(Alt)+Shift+N">
                üóÇÔ∏è New Section
              </button>
              <button id="new-page-btn" type="button" data-help="Create a new page under selection" data-shortcut="Opt(Alt)+N">
                üìÑ New Page
              </button>
              <button id="new-page-with-folder-btn" type="button"
                data-help="Create a page (nav only) and store it inside a same-named folder on disk" data-shortcut="Opt(Alt)+Shift+P">
                üìÅ Page w/ Folder
              </button>
              <button id="delete-btn" type="button" data-help="Delete selected node (tree only)" data-shortcut="Del/Backspace">
                üóëÔ∏è Delete
              </button>
              <button id="tree-locate-btn" type="button" class="ghost" data-help="Locate selection in Source" data-shortcut="Opt(Alt)+L">
                üß≠ Locate
              </button>
              <button id="open-file-btn" type="button" class="ghost" data-help="Open selected page in editor or default viewer" data-shortcut="Opt(Alt)+O">
                üîé Open
              </button>
              <button id="simple-edit-btn" type="button" class="ghost" data-help="Open selected page in Simple Edit" data-shortcut="Opt(Alt)+E">
                üìù Edit
              </button>
            </div>
          </div>
          <div id="tree" class="list-shell">Loading...</div>
        </section>
      </div>

      <div class="splitter splitter-h" id="split-bottom" title="Drag to resize"></div>

      <div class="bottom-stack debug-hidden" id="bottom-stack">
        <section class="card panel" id="panel-info">
          <div class="card-head">
            <h2>‚ÑπÔ∏è Info</h2>
            <div class="inline-actions">
              <span class="muted">Hover tools for hints</span>
              <button id="status-expand-btn" type="button" class="ghost" data-help="Expand status history">
                Expand
              </button>
            </div>
          </div>
          <div class="list-shell info-body">
            <div id="status" class="status-box" data-type="info"></div>
            <div class="info-pills">
              <div id="info-meta-pill" class="info-pill" title=""></div>
              <div id="info-selection-pill" class="info-pill" title=""></div>
            </div>
            <details id="info-details" class="info-details">
              <summary class="info-summary">More</summary>
              <div id="info-meta" class="info-line"></div>
              <div id="info-selection" class="info-line"></div>
              <div id="info-errors" class="info-errors" hidden></div>
            </details>
            <div id="info-hover" class="info-hint" hidden></div>
          </div>
        </section>

        <div class="splitter splitter-h" id="split-info-debug" title="Drag to resize debug height"></div>

        <section id="debug-panel" class="card panel debug-panel" hidden>
          <div class="debug-head">
            <div class="debug-title">DnD Debug</div>
            <div class="debug-actions">
              <button id="debug-clear" type="button" class="ghost">Clear</button>
              <button id="debug-copy" type="button" class="ghost">Copy</button>
            </div>
          </div>
          <pre id="debug-log" class="debug-log"></pre>
        </section>
      </div>

      <section class="card panel simple-editor" id="simple-editor" hidden>
        <div class="card-head">
          <h2>‚úèÔ∏è Simple Edit</h2>
          <div class="inline-actions">
            <span id="simple-edit-file" class="muted"></span>
            <span id="simple-edit-diff" class="muted"></span>
            <button id="simple-edit-abort" type="button" class="ghost" data-help="Abort edit (discard changes)">‚ü≤ Abort</button>
            <button id="simple-edit-save" type="button" class="ghost" data-help="Save file" data-shortcut="Ctrl/Cmd+S">
              <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                <rect x="2" y="2" width="12" height="12" rx="1.5" fill="#6AA9FF" stroke="#4A89DF" stroke-width="1.2"/>
                <rect x="4" y="4" width="8" height="6" fill="white"/>
                <rect x="5" y="11" width="6" height="3" fill="#4A89DF"/>
              </svg>
              Save
            </button>
            <button id="simple-edit-close" type="button" class="ghost" data-help="Close">‚úï</button>
          </div>
        </div>
        <div class="simple-edit-body">
          <pre id="simple-edit-lines" class="simple-edit-lines"></pre>
          <pre id="simple-edit-highlight" class="simple-edit-highlight"></pre>
          <textarea id="simple-edit-input" class="simple-edit-input" spellcheck="false"></textarea>
        </div>
      </section>

      <div class="modal" id="modal" hidden>
        <div class="modal-backdrop"></div>
        <div class="modal-card" role="dialog" aria-modal="true">
          <div class="modal-title" id="modal-title"></div>
          <div class="modal-message" id="modal-message"></div>
          <div class="modal-input-wrap" id="modal-input-wrap" hidden>
            <label class="modal-checkbox">
              <input id="modal-input" class="modal-input" type="text" />
              <span id="modal-input-label" class="modal-input-label"></span>
            </label>
          </div>
          <div class="modal-actions" id="modal-actions"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let els = {};
    let stateTree = [];
    let sourceTree = [];
    let sourceView = 'list';
    let sourceCollapsed = new Set();
    let selectedId = '';
    let selectedIds = new Set();
    let selectionAnchorId = '';
    let selectionParentKey = '';
    let draggedId = '';
		    let draggedIds = [];
		    let dropHint = { mode: null, targetId: null };
		    let dropLineEl = null;
    let debugEnabled = false;
    let debugLog = [];
    let lastDropHintSignature = '';
    let lastDragoverLogAt = 0;
    let historyPast = [];
    let historyFuture = [];
    let lastPersistedSignature = '';
    let treeCollapsed = new Set();
    let treeMaxLevel = 'n';
    let toolTipEl = null;
    let maybeLoadEditorFromSelection = () => {};
		    let activeInlineEdit = null;
		    let autoSyncTimer = null;
    let statusHistory = [];
    let statusExpanded = false;
    let skipEmptyDeleteConfirmSession = false;
    let showChoice = async () => 'cancel';
    let showConfirm = async () => false;
    let showPrompt = async () => null;
    let showAlert = async () => {};
    let dragMode = 'sync_files'; // sync_files | nav_only
		    let selectedDisplaySlotFolderId = '';
		    let showTools = false;
    let showSource = false;
    let showTree = true;
    let showInfo = false;
    let theme = 'dark';
    let treeContextOpen = false;
    // Registry for one-time global handlers that clear the persistent located highlight
    let locatedClearHandlers = [];
    // Suppress clearing for a short window right after installing handlers
    let locatedSuppressUntil = 0;

	    document.addEventListener('DOMContentLoaded', () => {
      els = {
        meta: document.getElementById('meta'),
        status: document.getElementById('status'),
        source: document.getElementById('source'),
        tree: document.getElementById('tree'),
        workspace: document.getElementById('workspace'),
        panelTools: document.getElementById('panel-tools'),
        panelSource: document.getElementById('panel-source'),
        panelTree: document.getElementById('panel-tree'),
        panelInfo: document.getElementById('panel-info'),
        bottomStack: document.getElementById('bottom-stack'),
        infoMeta: document.getElementById('info-meta'),
	        infoMetaPill: document.getElementById('info-meta-pill'),
        infoHover: document.getElementById('info-hover'),
        infoSelection: document.getElementById('info-selection'),
	        infoSelectionPill: document.getElementById('info-selection-pill'),
	        infoDetails: document.getElementById('info-details'),
        infoErrors: document.getElementById('info-errors'),
        statusExpandBtn: document.getElementById('status-expand-btn'),
        sourceViewBtn: document.getElementById('source-view-btn'),
        newFolderBtn: document.getElementById('new-folder-btn'),
        newPageBtn: document.getElementById('new-page-btn'),
        newPageWithFolderBtn: document.getElementById('new-page-with-folder-btn'),
        deleteBtn: document.getElementById('delete-btn'),
        toolUndoBtn: document.getElementById('tool-undo'),
	        toolRedoBtn: document.getElementById('tool-redo'),
		        toolImportBtn: document.getElementById('tool-import'),
		        toolBeautifyNavBtn: document.getElementById('tool-beautify-nav'),
		        dragModeToggle: document.getElementById('drag-mode-toggle'),
		        dragModeSwitch: document.getElementById('drag-mode-switch'),
		        dragModeText: document.getElementById('drag-mode-text'),
		        toolDebugBtn: document.getElementById('tool-debug'),
        debugPanel: document.getElementById('debug-panel'),
        debugLog: document.getElementById('debug-log'),
        debugClear: document.getElementById('debug-clear'),
        debugCopy: document.getElementById('debug-copy'),
        splitMainLeft: document.getElementById('split-main-left'),
        splitBottom: document.getElementById('split-bottom'),
        splitInfoDebug: document.getElementById('split-info-debug'),
        splitTools: document.getElementById('split-tools'),
        toggleTools: document.getElementById('toggle-tools'),
        toggleSource: document.getElementById('toggle-source'),
        toggleTree: document.getElementById('toggle-tree'),
        toggleInfo: document.getElementById('toggle-info'),
        toggleSimpleEditor: document.getElementById('toggle-simple-editor'),
        toggleTheme: document.getElementById('toggle-theme'),
        rainbowToggleBtn: document.getElementById('rainbow-toggle-btn'),
        treeLocateBtn: document.getElementById('tree-locate-btn'),
        openFileBtn: document.getElementById('open-file-btn'),
        simpleEditBtn: document.getElementById('simple-edit-btn'),
        treeContext: document.getElementById('tree-context'),
        simpleEditor: document.getElementById('simple-editor'),
        simpleEditFile: document.getElementById('simple-edit-file'),
        simpleEditDiff: document.getElementById('simple-edit-diff'),
        simpleEditAbort: document.getElementById('simple-edit-abort'),
        simpleEditSave: document.getElementById('simple-edit-save'),
        simpleEditClose: document.getElementById('simple-edit-close'),
        simpleEditLines: document.getElementById('simple-edit-lines'),
        simpleEditHighlight: document.getElementById('simple-edit-highlight'),
        simpleEditInput: document.getElementById('simple-edit-input'),
        modal: document.getElementById('modal'),
        modalTitle: document.getElementById('modal-title'),
        modalMessage: document.getElementById('modal-message'),
        modalInputWrap: document.getElementById('modal-input-wrap'),
        modalInput: document.getElementById('modal-input'),
        modalInputLabel: document.getElementById('modal-input-label'),
        modalActions: document.getElementById('modal-actions'),
      };

		      // Load mkdocs.yml from disk, overwrite current draft tree, and beautify nav formatting.
		      els.toolImportBtn.addEventListener('click', () => importFromMkdocs({ confirm: true, beautify: true }));
		      if (els.toolBeautifyNavBtn) els.toolBeautifyNavBtn.addEventListener('click', beautifyNav);

      els.newFolderBtn.addEventListener('click', () => createNode('folder'));
      els.newPageBtn.addEventListener('click', () => createNode('page'));
      if (els.newPageWithFolderBtn) els.newPageWithFolderBtn.addEventListener('click', createPageWithFolder);
      els.deleteBtn.addEventListener('click', deleteSelected);
	      els.toolUndoBtn.addEventListener('click', undo);
	      els.toolRedoBtn.addEventListener('click', redo);
	      if (els.dragModeToggle) els.dragModeToggle.addEventListener('change', onDragModeToggle);

      els.toolDebugBtn.addEventListener('click', toggleDebug);
      els.debugClear.addEventListener('click', () => {
        debugLog = [];
        renderDebug();
      });
      els.debugCopy.addEventListener('click', () => {
        const text = (debugLog || []).join('\n');
        copyToClipboard(text);
        setStatus('Debug log copied.', 'info');
      });

      sourceView = localStorage.getItem('page_tree_source_view') || 'list';
      sourceCollapsed = new Set(JSON.parse(localStorage.getItem('page_tree_source_collapsed') || '[]'));
      els.sourceViewBtn.addEventListener('click', toggleSourceView);
      updateSourceViewButton();
      treeCollapsed = new Set(JSON.parse(localStorage.getItem('page_tree_tree_collapsed') || '[]'));
      treeMaxLevel = localStorage.getItem('page_tree_tree_max_level') || 'n';
      bindDepthButtons();
      updateDepthButtons();

      // Unified DnD handlers on the tree container (mouse-position detector).
      els.tree.addEventListener('dragover', onTreeDragOver);
      els.tree.addEventListener('drop', onTreeDrop);
      els.tree.addEventListener('dragleave', onTreeDragLeave);
      dropLineEl = document.createElement('div');
      dropLineEl.className = 'drop-line';
      els.tree.appendChild(dropLineEl);
      hideDropLine();

      // Default: hidden each session.
      debugEnabled = false;
      debugLog = [];
      if (els.debugPanel) els.debugPanel.hidden = true;
      updateDebugVisibility();

		      initSplitters();
		      bindToolHoverHints();

      // Default visible: Tools/Source/Doc Tree/Info (user can toggle).
      showTools = localStorage.getItem('page_tree_show_tools') !== 'false';
      showSource = localStorage.getItem('page_tree_show_source') !== 'false';
      showTree = localStorage.getItem('page_tree_show_tree') !== 'false';
      showInfo = localStorage.getItem('page_tree_show_info') !== 'false';
      initTheme();
      applyPanelVisibility();
      renderStatusHistory();
      if (els.status) {
        if (window.ResizeObserver) {
          const statusObserver = new ResizeObserver(() => renderStatusHistory());
          statusObserver.observe(els.status);
        } else {
          window.addEventListener('resize', renderStatusHistory);
        }
      }
      if (els.statusExpandBtn) {
        els.statusExpandBtn.addEventListener('click', () => {
          statusExpanded = !statusExpanded;
          if (els.status) els.status.classList.toggle('is-expanded', statusExpanded);
          els.statusExpandBtn.textContent = statusExpanded ? 'Collapse' : 'Expand';
          renderStatusHistory();
        });
      }

      if (els.toggleTools) els.toggleTools.addEventListener('click', () => {
        showTools = !showTools;
        localStorage.setItem('page_tree_show_tools', String(showTools));
        applyPanelVisibility();
      });
      if (els.toggleSource) els.toggleSource.addEventListener('click', () => {
        showSource = !showSource;
        localStorage.setItem('page_tree_show_source', String(showSource));
        applyPanelVisibility();
      });
      if (els.toggleTree) els.toggleTree.addEventListener('click', () => {
        showTree = !showTree;
        localStorage.setItem('page_tree_show_tree', String(showTree));
        applyPanelVisibility();
      });
      if (els.toggleInfo) els.toggleInfo.addEventListener('click', () => {
        showInfo = !showInfo;
        localStorage.setItem('page_tree_show_info', String(showInfo));
        applyPanelVisibility();
      });
      if (els.toggleTheme) els.toggleTheme.addEventListener('click', toggleTheme);
      if (els.rainbowToggleBtn) els.rainbowToggleBtn.addEventListener('click', toggleRainbowColors);

      document.addEventListener('keydown', (e) => {
        if (!e) return;
        const target = e.target;
        const tag = target && target.tagName ? target.tagName.toLowerCase() : '';
        const isInput = !!(target && (target.isContentEditable || tag === 'input' || tag === 'textarea' || tag === 'select'));
        const inModal = els.modal && !els.modal.hidden && els.modal.contains(target);
        const meta = e.metaKey || e.ctrlKey;
        const alt = e.altKey;
        const shift = e.shiftKey;
        const key = e.key || '';
        const code = e.code || '';
        const isSave = meta && (key.toLowerCase() === 's');

        if (inModal || activeInlineEdit) return;
        if (isInput && !(isSave && target === els.simpleEditInput)) return;

        if (alt && shift && code === 'KeyN') {
          e.preventDefault();
          return createNode('folder');
        }
        if (alt && !shift && code === 'KeyN') {
          e.preventDefault();
          return createNode('page');
        }
        if (alt && shift && code === 'KeyP') {
          e.preventDefault();
          return createPageWithFolder();
        }
        if (key === 'F2') {
          e.preventDefault();
          return renameSelected();
        }
        if ((key === 'Delete' || key === 'Backspace') && !isInput) {
          e.preventDefault();
          return deleteSelected();
        }
        if (alt && code === 'KeyL') {
          e.preventDefault();
          return locateSelectedInSource();
        }
        if (alt && code === 'KeyO') {
          e.preventDefault();
          return openSelectedFile();
        }
        if (alt && code === 'KeyE') {
          e.preventDefault();
          return openSimpleEditorFromSelection();
        }
        if (isSave && els.simpleEditor && !els.simpleEditor.hidden) {
          e.preventDefault();
          return saveSimpleEditor();
        }
      });

      // Click tree panel background to deselect (go back to root)
      els.tree.addEventListener('click', (e) => {
        // Only trigger if clicking directly on tree container (not on children)
        if (e.target === els.tree || e.target.classList.contains('tree-root')) {
          selectedId = '';
          selectedIds = new Set();
          selectionAnchorId = '';
          selectionParentKey = '';
          selectedDisplaySlotFolderId = '';
          syncSelectionClasses();
          updateInfo();
        }
      });

      // Click outside tree to deselect (go back to root)
      document.addEventListener('click', (e) => {
        const target = e.target;
        const inTree = els.tree.contains(target) || els.panelTree.contains(target);
        const inEditor = els.simpleEditor && !els.simpleEditor.hidden && els.simpleEditor.contains(target);
        const inEditorControl = target && target.closest
          ? target.closest('#toggle-simple-editor, #simple-edit-btn, #simple-edit-save, #simple-edit-abort, #simple-edit-close')
          : null;
        const inModal = els.modal && !els.modal.hidden && els.modal.contains(target);
        // Check if click is outside tree panel and not part of the simple editor flow
        if (!inTree && !inEditor && !inEditorControl && !inModal) {
          // Deselect all
          selectedId = '';
          selectedIds = new Set();
          selectionAnchorId = '';
          selectionParentKey = '';
          selectedDisplaySlotFolderId = '';
          selectionClearedManual = true;
          syncSelectionClasses();
          if (typeof updateInfo === 'function') updateInfo();
        }
      });

      // Locate button in the Doc Tree header: locate selected page/overview in Source pane
      const locateSelectedInSource = () => {
        // Determine selection id: prefer single selectedId, then first of selectedIds
        const id = selectedId || (selectedIds && selectedIds.size ? Array.from(selectedIds)[0] : '');
        // Helper to open source panel and call locateByFile
        const openAndLocate = (filePath) => {
          showSource = true;
          localStorage.setItem('page_tree_show_source', String(true));
          applyPanelVisibility();
          locateByFile(filePath);
        };

        if (!id) {
          // If no explicit selection, but a display slot folder selected, try to locate its overview
          if (selectedDisplaySlotFolderId) {
            const found = findNode(stateTree, selectedDisplaySlotFolderId);
            if (found && found.node && found.node.type === 'folder') {
              const overview = (found.node.children || []).find(c => c && c.type === 'page' && c.is_overview && c.file);
              if (overview && overview.file) return openAndLocate(overview.file);
            }
          }
          return setStatus('‚ö†Ô∏è No page selected to locate.', 'info');
        }

        const found = findNode(stateTree, id);
        if (!found) return setStatus('‚ö†Ô∏è Selected node not in tree.', 'info');
        const node = found.node;
        if (node.type === 'page' && node.file) return openAndLocate(node.file);
        if (node.type === 'folder') {
          const overview = (node.children || []).find(c => c && c.type === 'page' && c.is_overview && c.file);
          if (overview && overview.file) return openAndLocate(overview.file);
        }
        setStatus('‚ö†Ô∏è Selected node has no associated file to locate.', 'info');
      };
      if (els.treeLocateBtn) els.treeLocateBtn.addEventListener('click', locateSelectedInSource);

      function getFileForNode(node) {
        if (!node) return '';
        if (node.type === 'page' && node.file) return node.file;
        if (node.type === 'folder') {
          const overview = (node.children || []).find(c => c && c.type === 'page' && c.is_overview && c.file);
          if (overview && overview.file) return overview.file;
        }
        return '';
      }

      function resolveSelectedFile(forcedId) {
        let id = forcedId || selectedId || (selectedIds && selectedIds.size ? Array.from(selectedIds)[0] : '');
        if (!id && selectedDisplaySlotFolderId) {
          const found = findNode(stateTree, selectedDisplaySlotFolderId);
          const file = found && found.node ? getFileForNode(found.node) : '';
          if (file) id = found.node.id;
        }
        if (!id) return '';
        const found = findNode(stateTree, id);
        if (!found) return '';
        return getFileForNode(found.node);
      }

      const openSelectedFile = async () => {
        let id = selectedId || (selectedIds && selectedIds.size ? Array.from(selectedIds)[0] : '');
        const file = resolveSelectedFile(id);
        if (!file) return setStatus('‚ö†Ô∏è No page selected to open.', 'info');
        try {
          const data = await fetchJson('/api/open_file', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ file })
          });
          const mode = data && data.mode ? data.mode : 'default';
          setStatus(mode === 'vscode' ? '‚úÖ Opened in VS Code.' : '‚òëÔ∏è Opened in default viewer.', 'success');
        } catch (e) {
          setStatus(e.message || 'Open failed.', 'error');
        }
      };
      if (els.openFileBtn) els.openFileBtn.addEventListener('click', openSelectedFile);

      const editorState = {
        currentFile: '',
        dirty: false,
        originalLines: []
      };

      const modalState = { resolve: null, cleanup: null };

      const closeModal = (value) => {
        if (!modalState.resolve) return;
        const resolve = modalState.resolve;
        modalState.resolve = null;
        if (modalState.cleanup) {
          modalState.cleanup();
          modalState.cleanup = null;
        }
        if (els.modal) els.modal.hidden = true;
        resolve(value);
      };

      showChoice = (options) => {
        const opts = options || {};
        const title = String(opts.title || 'Confirm');
        const message = String(opts.message || '');
        const buttons = Array.isArray(opts.buttons) ? opts.buttons : [];
        const cancelValue = opts.cancelValue;
        const hasInput = !!opts.input;
        const defaultValue = opts.input && typeof opts.input.value === 'string' ? opts.input.value : '';
        const placeholder = opts.input && typeof opts.input.placeholder === 'string' ? opts.input.placeholder : '';
        const inputType = opts.input && typeof opts.input.type === 'string' ? opts.input.type : 'text';
        const inputLabel = opts.input && typeof opts.input.label === 'string' ? opts.input.label : '';
        return new Promise((resolve) => {
          modalState.resolve = resolve;
          if (els.modalTitle) els.modalTitle.textContent = title;
          if (els.modalMessage) els.modalMessage.textContent = message;
          if (els.modalInputWrap) {
            els.modalInputWrap.hidden = !hasInput;
            els.modalInputWrap.classList.toggle('is-checkbox', hasInput && inputType === 'checkbox');
          }
          if (els.modalInput) {
            if (hasInput) {
              els.modalInput.type = inputType === 'checkbox' ? 'checkbox' : 'text';
              if (inputType === 'checkbox') {
                els.modalInput.checked = !!opts.input.value;
                els.modalInput.placeholder = '';
              } else {
                els.modalInput.value = defaultValue;
                els.modalInput.placeholder = placeholder;
              }
            } else {
              els.modalInput.value = '';
              els.modalInput.placeholder = '';
            }
          }
          if (els.modalInputLabel) {
            els.modalInputLabel.textContent = inputLabel;
            els.modalInputLabel.hidden = !hasInput || !inputLabel;
          }
          if (els.modalActions) {
            els.modalActions.innerHTML = '';
            buttons.forEach((btn) => {
              const b = document.createElement('button');
              b.type = 'button';
              b.textContent = btn.label;
              if (btn.primary) b.classList.add('active');
              if (btn.ghost) b.classList.add('ghost');
              b.addEventListener('click', () => {
                const inputValue = hasInput && els.modalInput
                  ? (els.modalInput.type === 'checkbox' ? els.modalInput.checked : els.modalInput.value)
                  : '';
                closeModal({ value: btn.value, input: inputValue });
              });
              els.modalActions.appendChild(b);
            });
          }
          if (els.modal) els.modal.hidden = false;
          const primary = els.modalActions ? els.modalActions.querySelector('button.active') : null;
          if (primary) primary.focus();
          if (hasInput && els.modalInput) {
            els.modalInput.focus();
            if (els.modalInput.type !== 'checkbox') els.modalInput.select();
          }
          const onKey = (e) => {
            if (e.key === 'Escape' && modalState.resolve) {
              const inputValue = hasInput && els.modalInput
                ? (els.modalInput.type === 'checkbox' ? els.modalInput.checked : els.modalInput.value)
                : '';
              closeModal({ value: cancelValue, input: inputValue });
            }
            if (e.key === 'Enter' && hasInput && primary && modalState.resolve) {
              const inputValue = els.modalInput
                ? (els.modalInput.type === 'checkbox' ? els.modalInput.checked : els.modalInput.value)
                : '';
              closeModal({ value: buttons.find(b => b.primary)?.value ?? cancelValue, input: inputValue });
            }
          };
          const onBackdrop = (e) => {
            if (!els.modal || !modalState.resolve) return;
            if (e.target && e.target.classList && e.target.classList.contains('modal-backdrop')) {
              const inputValue = hasInput && els.modalInput
                ? (els.modalInput.type === 'checkbox' ? els.modalInput.checked : els.modalInput.value)
                : '';
              closeModal({ value: cancelValue, input: inputValue });
            }
          };
          modalState.cleanup = () => {
            window.removeEventListener('keydown', onKey);
            if (els.modal) els.modal.removeEventListener('click', onBackdrop);
          };
          window.addEventListener('keydown', onKey);
          if (els.modal) els.modal.addEventListener('click', onBackdrop);
        });
      };

      showConfirm = async (message, opts) => {
        const options = opts || {};
        const res = await showChoice({
          title: options.title || 'Confirm',
          message,
          cancelValue: false,
          buttons: [
            { label: options.okText || 'OK', value: true, primary: true },
            { label: options.cancelText || 'Cancel', value: false, ghost: true }
          ]
        });
        return !!(res && res.value);
      };

      showAlert = async (message, opts) => {
        const options = opts || {};
        await showChoice({
          title: options.title || 'Notice',
          message,
          cancelValue: true,
          buttons: [{ label: options.okText || 'OK', value: true, primary: true }]
        });
      };

      showPrompt = async (message, opts) => {
        const options = opts || {};
        const res = await showChoice({
          title: options.title || 'Input',
          message,
          cancelValue: null,
          input: {
            value: options.defaultValue || '',
            placeholder: options.placeholder || ''
          },
          buttons: [
            { label: options.okText || 'OK', value: 'ok', primary: true },
            { label: options.cancelText || 'Cancel', value: null, ghost: true }
          ]
        });
        if (!res || res.value === null) return null;
        return String(res.input || '');
      };

      function setSimpleEditorVisible(show) {
        if (!els.simpleEditor) return;
        els.simpleEditor.hidden = !show;
        if (els.toggleSimpleEditor) {
          if (show) els.toggleSimpleEditor.classList.add('active');
          else els.toggleSimpleEditor.classList.remove('active');
        }
      }

      async function confirmUnsavedClose() {
        if (!editorState.dirty) return true;
        return showConfirm('Unsaved changes in Simple Edit. Close without saving?', {
          title: 'Unsaved Changes',
          okText: 'Close',
          cancelText: 'Cancel'
        });
      }

      function escapeHtml(text) {
        return String(text || '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
      }

      function highlightMarkdown(source) {
        const lines = String(source || '').split('\n');
        const out = lines.map((line, idx) => {
          const escaped = escapeHtml(line);
          let rendered = escaped;
          const headingMatch = line.match(/^(\s{0,3})(#{1,6})\s+(.+)$/);
          if (headingMatch) {
            const lead = headingMatch[1] || '';
            const hashes = headingMatch[2] || '';
            const title = escapeHtml(headingMatch[3] || '');
            rendered = `${lead}<span class="md-hash">${hashes}</span> <span class="md-heading">${title}</span>`;
          } else {
            rendered = rendered.replace(/\*\*([^*]+)\*\*/g, '<span class="md-bold">**$1**</span>');
            rendered = rendered.replace(/`([^`]+)`/g, '<span class="md-code">`$1`</span>');
            rendered = rendered.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<span class="md-link">[$1]($2)</span>');
            rendered = rendered.replace(/^\s*[-*+]\s+/, (m) => `<span class="md-list">${m}</span>`);
          }
          const cls = 'md-line';
          const body = rendered === '' ? '&nbsp;' : rendered;
          return `<div class="${cls}">${body}</div>`;
        });
        if (!out.length) return '';
        return out.join('');
      }

      function buildLineNumbers(lines, originals) {
        const total = Math.max(lines.length, 1);
        const out = [];
        let added = 0;
        let modified = 0;
        for (let i = 0; i < total; i += 1) {
          const no = i + 1;
          const line = lines[i] ?? '';
          const original = originals && typeof originals[i] === 'string' ? originals[i] : '';
          const isNew = originals && i >= originals.length;
          const isModified = !isNew && line !== original;
          const cls = isNew ? 'line-no added' : (isModified ? 'line-no modified' : 'line-no');
          const mark = isNew ? '+' : (isModified ? '~' : '');
          if (isNew) added += 1;
          if (isModified) modified += 1;
          out.push(
            `<div class="${cls}">` +
            `<span class="line-no-mark">${mark}</span>` +
            `<span class="line-no-label">${no}</span>` +
            `</div>`
          );
        }
        const deleted = originals && originals.length > lines.length ? originals.length - lines.length : 0;
        return { html: out.join(''), added, modified, deleted };
      }

      function syncEditorHighlight() {
        if (!els.simpleEditInput || !els.simpleEditHighlight) return;
        const lines = String(els.simpleEditInput.value || '').split('\n');
        const originals = Array.isArray(editorState.originalLines) ? editorState.originalLines : [];
        els.simpleEditHighlight.innerHTML = highlightMarkdown(els.simpleEditInput.value);
        if (els.simpleEditLines) {
          const info = buildLineNumbers(lines, originals);
          els.simpleEditLines.innerHTML = info.html;
          if (els.simpleEditDiff) {
            const add = info.added || 0;
            const mod = info.modified || 0;
            const del = info.deleted || 0;
            els.simpleEditDiff.textContent = add || mod || del ? `+${add} ~${mod} -${del}` : '';
          }
        }
      }

      function syncEditorScroll() {
        if (!els.simpleEditInput || !els.simpleEditHighlight) return;
        els.simpleEditHighlight.scrollTop = els.simpleEditInput.scrollTop;
        els.simpleEditHighlight.scrollLeft = els.simpleEditInput.scrollLeft;
        if (els.simpleEditLines) els.simpleEditLines.scrollTop = els.simpleEditInput.scrollTop;
      }

      function updateEditorControls() {
        if (els.simpleEditFile) els.simpleEditFile.textContent = editorState.currentFile || '(no file)';
      }

      function resetSimpleEditorState() {
        editorState.currentFile = '';
        editorState.dirty = false;
        editorState.originalLines = [];
        if (els.simpleEditInput) els.simpleEditInput.value = '';
        syncEditorHighlight();
        syncEditorScroll();
        updateEditorControls();
      }

      async function loadEditorFile(file) {
        if (!file) return;
        try {
          const data = await fetchJson('/api/read_file', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ file })
          });
          editorState.currentFile = data.file || file;
          editorState.dirty = false;
          editorState.originalLines = String(data.content || '').split('\n');
          if (els.simpleEditInput) {
            els.simpleEditInput.value = data.content || '';
            syncEditorHighlight();
            syncEditorScroll();
          }
          updateEditorControls();
        } catch (e) {
          setStatus(e.message || 'Failed to load file.', 'error');
        }
      }

      async function saveSimpleEditor() {
        if (!editorState.currentFile) {
          setStatus('‚ö†Ô∏è No file loaded.', 'info');
          return false;
        }
        try {
          await fetchJson('/api/write_file', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ file: editorState.currentFile, content: els.simpleEditInput.value })
          });
          editorState.dirty = false;
          editorState.originalLines = String(els.simpleEditInput.value || '').split('\n');
          syncEditorHighlight();
          setStatus('‚úÖ Saved.', 'success');
          return true;
        } catch (e) {
          setStatus(e.message || '‚õîÔ∏è Save failed.', 'error');
          return false;
        }
      }

      const maybeLoadEditorFromSelectionImpl = async () => {
        if (!els.simpleEditor || els.simpleEditor.hidden) return;
        const file = resolveSelectedFile('');
        if (!file || file === editorState.currentFile) return;
        if (editorState.dirty) {
          const choice = await showChoice({
            title: 'Unsaved Changes',
            message: 'You have unsaved changes. What would you like to do?',
            cancelValue: 'cancel',
            buttons: [
              { label: 'Save', value: 'save', primary: true },
              { label: 'Abort Edit', value: 'discard' },
              { label: 'Cancel', value: 'cancel', ghost: true }
            ]
          });
          const action = choice ? choice.value : 'cancel';
          if (action === 'save') {
            const ok = await saveSimpleEditor();
            if (!ok) return;
          } else if (action === 'discard') {
            editorState.dirty = false;
          } else {
            setStatus('Switch canceled.', 'info');
            return;
          }
        }
        loadEditorFile(file);
      };
      maybeLoadEditorFromSelection = maybeLoadEditorFromSelectionImpl;

      function openSimpleEditor(file) {
        if (!els.simpleEditor) return;
        setSimpleEditorVisible(true);
        loadEditorFile(file);
      }

      const openSimpleEditorFromSelection = () => {
        const id = selectedId || (selectedIds && selectedIds.size ? Array.from(selectedIds)[0] : '');
        if (!id && selectedDisplaySlotFolderId) {
          const found = findNode(stateTree, selectedDisplaySlotFolderId);
          const file = found && found.node ? getFileForNode(found.node) : '';
          if (file) return openSimpleEditor(file);
        }
        if (!id) return setStatus('‚ö†Ô∏è No page selected to edit.', 'info');
        const found = findNode(stateTree, id);
        if (!found) return setStatus('‚ö†Ô∏è Selected node not in tree.', 'info');
        const file = getFileForNode(found.node);
        if (!file) return setStatus('‚ö†Ô∏è Selected node has no associated file to edit.', 'info');
        openSimpleEditor(file);
      };
      if (els.simpleEditBtn) els.simpleEditBtn.addEventListener('click', openSimpleEditorFromSelection);

      const hideTreeContext = () => {
        if (!els.treeContext) return;
        els.treeContext.hidden = true;
        treeContextOpen = false;
      };

      const positionTreeContext = (x, y) => {
        if (!els.treeContext) return;
        els.treeContext.hidden = false;
        treeContextOpen = true;
        const menu = els.treeContext;
        const padding = 12;
        const maxX = window.innerWidth - padding;
        const maxY = window.innerHeight - padding;
        menu.style.left = `${Math.min(x, maxX)}px`;
        menu.style.top = `${Math.min(y, maxY)}px`;
        const rect = menu.getBoundingClientRect();
        if (rect.right > maxX) menu.style.left = `${Math.max(padding, maxX - rect.width)}px`;
        if (rect.bottom > maxY) menu.style.top = `${Math.max(padding, maxY - rect.height)}px`;
      };

      const updateTreeContextState = () => {
        if (!els.treeContext) return;
        const hasSelection = !!selectedId || (selectedIds && selectedIds.size) || !!selectedDisplaySlotFolderId;
        const hasFile = !!resolveSelectedFile('');
        const buttons = Array.from(els.treeContext.querySelectorAll('button[data-action]'));
        buttons.forEach((btn) => {
          const action = btn.dataset.action || '';
          let enabled = true;
          if (action === 'rename') enabled = !!selectedId;
          if (action === 'delete') enabled = !!selectedId || (selectedIds && selectedIds.size);
          if (action === 'locate' || action === 'open' || action === 'edit') enabled = hasFile;
          if (!hasSelection && (action === 'rename' || action === 'delete' || action === 'locate' || action === 'open' || action === 'edit')) enabled = false;
          btn.disabled = !enabled;
        });
      };

      const selectContextTarget = (target) => {
        if (!target) return;
        if (target.classList.contains('overview-inline')) {
          const overviewId = target.dataset.overviewId || '';
          const folderId = target.dataset.folderId || '';
          if (overviewId) {
            if (!(selectedIds && selectedIds.size && selectedIds.has(overviewId))) selectNode(overviewId);
          } else if (folderId) {
            selectedId = '';
            selectedIds = new Set();
            selectionAnchorId = '';
            selectionParentKey = '';
            selectedDisplaySlotFolderId = folderId;
            syncSelectionClasses();
            if (typeof updateInfo === 'function') updateInfo();
          }
          return;
        }
        const id = target.dataset.id || '';
        if (!id) return;
        if (selectedIds && selectedIds.size && selectedIds.has(id)) return;
        selectNode(id);
      };

      if (els.tree) {
        els.tree.addEventListener('contextmenu', (e) => {
          const target = e.target.closest('#tree li.node, #tree .overview-inline');
          if (!target) return;
          e.preventDefault();
          if (activeInlineEdit) return;
          selectContextTarget(target);
          updateTreeContextState();
          positionTreeContext(e.clientX, e.clientY);
        });
      }

      if (els.treeContext) {
        els.treeContext.addEventListener('click', (e) => {
          const btn = e.target.closest('button[data-action]');
          if (!btn || btn.disabled) return;
          const action = btn.dataset.action || '';
          if (action === 'new-folder') createNode('folder');
          if (action === 'new-page') createNode('page');
          if (action === 'new-page-with-folder') createPageWithFolder();
          if (action === 'rename') renameSelected();
          if (action === 'delete') deleteSelected();
          if (action === 'locate') locateSelectedInSource();
          if (action === 'open') openSelectedFile();
          if (action === 'edit') openSimpleEditorFromSelection();
          hideTreeContext();
        });
      }

      document.addEventListener('pointerdown', (e) => {
        if (!treeContextOpen) return;
        if (!els.treeContext) return;
        if (e.target && els.treeContext.contains(e.target)) return;
        hideTreeContext();
      });

      window.addEventListener('scroll', () => {
        if (treeContextOpen) hideTreeContext();
      }, { passive: true });

      window.addEventListener('keydown', (e) => {
        if (!treeContextOpen) return;
        if (e.key === 'Escape') hideTreeContext();
      });

      if (els.simpleEditClose) els.simpleEditClose.addEventListener('click', async () => {
        const ok = await confirmUnsavedClose();
        if (!ok) return;
        setSimpleEditorVisible(false);
        resetSimpleEditorState();
        clearSelection();
      });

      if (els.simpleEditAbort) els.simpleEditAbort.addEventListener('click', async () => {
        if (!editorState.currentFile) return setStatus('‚ö†Ô∏è No file loaded.', 'info');
        if (editorState.dirty) {
          const ok = await showConfirm('Discard changes and reload the file?', {
            title: 'Abort Edit',
            okText: 'Discard',
            cancelText: 'Cancel'
          });
          if (!ok) return;
        }
        loadEditorFile(editorState.currentFile);
      });

      if (els.simpleEditSave) els.simpleEditSave.addEventListener('click', saveSimpleEditor);

      if (els.simpleEditInput) {
        els.simpleEditInput.addEventListener('input', () => {
          editorState.dirty = true;
          syncEditorHighlight();
        });
        els.simpleEditInput.addEventListener('scroll', syncEditorScroll);
      }

      window.addEventListener('beforeunload', (e) => {
        if (!editorState.dirty) return;
        e.preventDefault();
        e.returnValue = '';
      });

      if (els.toggleSimpleEditor) els.toggleSimpleEditor.addEventListener('click', () => {
        if (!els.simpleEditor) return;
        const willShow = els.simpleEditor.hidden;
        setSimpleEditorVisible(willShow);
        if (!willShow) {
          resetSimpleEditorState();
          clearSelection();
          return;
        }
        if (editorState.currentFile) {
          updateEditorControls();
          return;
        }
        const id = selectedId || (selectedIds && selectedIds.size ? Array.from(selectedIds)[0] : '');
        if (id) {
          const found = findNode(stateTree, id);
          if (found && found.node) {
            const file = getFileForNode(found.node);
            if (file) return openSimpleEditor(file);
          }
        }
        setStatus('‚ö†Ô∏è Simple Edit opened. Select a page and click üßæ Edit to load it.', 'info');
      });

      if (els.simpleEditor) {
        const header = els.simpleEditor.querySelector('.card-head');
        let drag = null;
        const onMove = (e) => {
          if (!drag || !els.simpleEditor) return;
          const x = e.clientX - drag.offsetX;
          const y = e.clientY - drag.offsetY;
          const maxX = window.innerWidth - drag.width - 8;
          const maxY = window.innerHeight - drag.height - 8;
          const clampedX = Math.min(Math.max(x, 8), Math.max(8, maxX));
          const clampedY = Math.min(Math.max(y, 8), Math.max(8, maxY));
          els.simpleEditor.style.left = `${clampedX}px`;
          els.simpleEditor.style.top = `${clampedY}px`;
        };
        const onUp = () => {
          if (!drag) return;
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('pointerup', onUp);
          drag = null;
        };
        if (header) {
          header.addEventListener('pointerdown', (e) => {
            if (e.button !== 0) return;
            if (e.target && e.target.closest('button')) return;
            if (!els.simpleEditor) return;
            const rect = els.simpleEditor.getBoundingClientRect();
            els.simpleEditor.style.left = `${rect.left}px`;
            els.simpleEditor.style.top = `${rect.top}px`;
            els.simpleEditor.style.right = 'auto';
            els.simpleEditor.style.bottom = 'auto';
            drag = {
              offsetX: e.clientX - rect.left,
              offsetY: e.clientY - rect.top,
              width: rect.width,
              height: rect.height
            };
            window.addEventListener('pointermove', onMove);
            window.addEventListener('pointerup', onUp);
          });
        }
      }

      window.addEventListener('keydown', (e) => {
        if (activeInlineEdit) return;
        // Clear located highlight on navigation keys or when selection changes
        const navKeys = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Enter','Delete','Backspace','PageUp','PageDown','Home','End'];
        if (navKeys.includes(e.key)) clearLocatedSource();
        if (e.key === 'Escape') {
          clearSelection();
        }
      });

	      dragMode = localStorage.getItem('page_tree_drag_mode') || 'sync_files';
	      updateDragModeSwitch();
	      loadMeta();
	      // Default: auto-load mkdocs.yml on entry. If invalid, block rendering.
	      bootstrap();
		    });

		    function onDragModeToggle() {
		      if (!els.dragModeToggle) return;
		      dragMode = els.dragModeToggle.checked ? 'sync_files' : 'nav_only';
		      localStorage.setItem('page_tree_drag_mode', dragMode);
		      updateDragModeSwitch();
		      setStatus(dragMode === 'nav_only' ? '‚õìÔ∏è‚Äçüí• Drag: Nav only' : '‚õìÔ∏è Drag: Nav + Files', 'info');
		    }

		    function updateDragModeSwitch() {
		      const isFiles = dragMode === 'sync_files';
		      if (els.dragModeToggle) els.dragModeToggle.checked = isFiles;
		      if (els.dragModeText) els.dragModeText.textContent = isFiles ? 'Drag: Files' : 'Drag: Nav';
		      if (els.dragModeSwitch) {
		        els.dragModeSwitch.dataset.help = isFiles
		          ? 'Drag & drop updates mkdocs.yml and moves files on disk'
		          : 'Drag & drop updates mkdocs.yml nav only (no file moves)';
		        els.dragModeSwitch.title = els.dragModeSwitch.dataset.help;
		      }
		    }

		    async function bootstrap() {
		      setStatus('‚è≥ Loading mkdocs.yml...', 'info');
		      try {
		        const data = await fetchJson('/api/import', { method: 'POST' });
		        stateTree = Array.isArray(data.tree) ? data.tree : [];
		        const warnings = Array.isArray(data.warnings) ? data.warnings : [];
		        lastPersistedSignature = treeSignature(stateTree);
		        resetHistory();
		        renderTree();
		        updateHistoryButtons();
		        await loadSource();
		        setStatus(warnings.length ? `‚ö†Ô∏è Loaded with warnings (${warnings.length}).` : '‚úÖ Loaded from mkdocs.yml.', warnings.length ? 'info' : 'success');
		      } catch (e) {
		        const data = e && e.data ? e.data : null;
		        if (data && Array.isArray(data.errors)) {
		          const count = data.errors.length;
		          setStatus(`‚õîÔ∏è Import blocked: ${count} invalid/missing doc path(s).`, 'error');
		          pushDebug('import.blocked', { errors: data.errors });
		          showImportErrors(data);
		          if (els.tree) els.tree.textContent = 'Blocked: invalid mkdocs.yml paths.';
		          if (els.source) els.source.textContent = 'Blocked.';
		          clearSelection();
		          return;
		        }
		        setStatus(`‚õîÔ∏è ${e.message || 'Import failed.'}`, 'error');
		        if (els.tree) els.tree.textContent = 'Failed to load tree.';
		      }
		    }

    function initTheme() {
      theme = localStorage.getItem('page_tree_theme') || 'dark';
      applyTheme();
      
      // Initialize rainbow colors state
      const rainbowEnabled = localStorage.getItem('page_tree_rainbow_colors') === 'true';
      document.body.classList.toggle('rainbow-colors', rainbowEnabled);
      if (els.rainbowToggleBtn) {
        els.rainbowToggleBtn.style.opacity = rainbowEnabled ? '1' : '0.5';
      }
    }

    function toggleTheme() {
      theme = theme === 'light' ? 'dark' : 'light';
      localStorage.setItem('page_tree_theme', theme);
      applyTheme();
    }

    function applyTheme() {
      document.body.classList.toggle('theme-light', theme === 'light');
      if (els.toggleTheme) els.toggleTheme.textContent = theme === 'light' ? '‚òÄÔ∏è' : 'üåô';
      pushDebug('theme.set', { theme });
    }

    function toggleRainbowColors() {
      const rainbowEnabled = document.body.classList.toggle('rainbow-colors');
      localStorage.setItem('page_tree_rainbow_colors', rainbowEnabled ? 'true' : 'false');
      if (els.rainbowToggleBtn) {
        els.rainbowToggleBtn.style.opacity = rainbowEnabled ? '1' : '0.5';
      }
      pushDebug('rainbow.toggle', { enabled: rainbowEnabled });
    }

    function applyPanelVisibility() {
      if (els.panelTools) els.panelTools.hidden = !showTools;
      if (els.panelSource) els.panelSource.hidden = !showSource;
      if (els.panelTree) els.panelTree.hidden = !showTree;
      if (els.panelInfo) els.panelInfo.hidden = !showInfo;
      if (els.splitMainLeft) els.splitMainLeft.style.display = (showSource && showTree) ? '' : 'none';
      if (els.splitBottom) els.splitBottom.style.display = showInfo ? '' : 'none';
      if (els.bottomStack) els.bottomStack.hidden = !showInfo;

      if (els.workspace) {
        els.workspace.classList.toggle('no-tools', !showTools);
        els.workspace.classList.toggle('no-source', !showSource);
        els.workspace.classList.toggle('no-tree', !showTree);
        els.workspace.classList.toggle('no-bottom', !showInfo);
        const singleMain = (showSource ? 1 : 0) + (showTree ? 1 : 0) === 1;
        els.workspace.classList.toggle('single-main', singleMain);
      }

      if (els.toggleTools) els.toggleTools.classList.toggle('active', showTools);
      if (els.toggleSource) els.toggleSource.classList.toggle('active', showSource);
      if (els.toggleTree) els.toggleTree.classList.toggle('active', showTree);
      if (els.toggleInfo) els.toggleInfo.classList.toggle('active', showInfo);
    }

    function bindToolHoverHints() {
      toolTipEl = document.getElementById('tool-tooltip');
      const buttons = document.querySelectorAll('[data-help]');
      buttons.forEach(btn => {
        btn.addEventListener('mouseenter', (e) => {
          const text = btn.dataset.help || '';
          const shortcut = btn.dataset.shortcut || '';
          setInfoHover(text);
          showToolTip(text, shortcut, e);
        });
        btn.addEventListener('mousemove', (e) => {
          moveToolTip(e);
        });
        btn.addEventListener('mouseleave', () => {
          setInfoHover('');
          hideToolTip();
        });
      });
    }

	    function scheduleAutoSync(reason, modeOverride) {
	      if (autoSyncTimer) clearTimeout(autoSyncTimer);
	      const mode = modeOverride || 'sync_files';
	      autoSyncTimer = setTimeout(async () => {
	        autoSyncTimer = null;
	        pushDebug('auto_sync.run', { mode, reason });
	        await sync(mode, { confirm: false, silent: true });
	      }, 250);
	    }

	    function scheduleNavOnly(reason) {
	      return scheduleAutoSync(reason, 'nav_only');
	    }

    function showToolTip(text, shortcut, e) {
      if (!toolTipEl) return;
      const value = (text || '').trim();
      if (!value) return;
      toolTipEl.textContent = shortcut ? `${value} (${shortcut})` : value;
      toolTipEl.hidden = false;
      moveToolTip(e);
    }

    function moveToolTip(e) {
      if (!toolTipEl || toolTipEl.hidden) return;
      const pad = 12;
      const maxLeft = window.innerWidth - toolTipEl.offsetWidth - pad;
      const maxTop = window.innerHeight - toolTipEl.offsetHeight - pad;
      const left = Math.min(e.clientX + pad, Math.max(pad, maxLeft));
      const top = Math.min(e.clientY + pad, Math.max(pad, maxTop));
      toolTipEl.style.left = `${left}px`;
      toolTipEl.style.top = `${top}px`;
    }

    function hideToolTip() {
      if (!toolTipEl) return;
      toolTipEl.hidden = true;
      toolTipEl.textContent = '';
    }

    function toggleSourceView() {
      sourceView = sourceView === 'ascii' ? 'list' : 'ascii';
      localStorage.setItem('page_tree_source_view', sourceView);
      updateSourceViewButton();
      renderSource();
    }

    function bindDepthButtons() {
      const buttons = document.querySelectorAll('.depth-btn');
      buttons.forEach(btn => {
        btn.addEventListener('click', () => {
          treeMaxLevel = btn.dataset.depth || 'n';
          localStorage.setItem('page_tree_tree_max_level', treeMaxLevel);
          updateDepthButtons();
          renderTree();
        });
      });
    }

    function updateDepthButtons() {
      const buttons = document.querySelectorAll('.depth-btn');
      buttons.forEach(btn => {
        btn.classList.toggle('active', (btn.dataset.depth || '') === String(treeMaxLevel));
      });
    }

    function maxLevelValue() {
      if (treeMaxLevel === 'n') return Number.POSITIVE_INFINITY;
      const n = parseInt(String(treeMaxLevel), 10);
      return Number.isFinite(n) && n > 0 ? n : Number.POSITIVE_INFINITY;
    }

    function updateSourceViewButton() {
      if (!els.sourceViewBtn) return;
      els.sourceViewBtn.classList.toggle('active', sourceView === 'ascii');
      // Show the view you can switch to.
      els.sourceViewBtn.textContent = sourceView === 'ascii' ? 'üóÇ Explorer' : 'üßæ ASCII';
    }

    function deepClone(value) {
      return JSON.parse(JSON.stringify(value));
    }

    function treeSignature(tree) {
      try {
        return JSON.stringify(tree || []);
      } catch (e) {
        return String(Date.now());
      }
    }

    function isDirty() {
      return treeSignature(stateTree) !== lastPersistedSignature;
    }

    function updateHistoryButtons() {
      if (els.toolUndoBtn) els.toolUndoBtn.disabled = historyPast.length === 0;
      if (els.toolRedoBtn) els.toolRedoBtn.disabled = historyFuture.length === 0;
    }

    function resetHistory() {
      historyPast = [];
      historyFuture = [];
      updateHistoryButtons();
    }

    function makeSnapshot(tree, mode) {
      return { tree: deepClone(tree), dragMode: mode || dragMode || 'sync_files' };
    }

    function snapshotTree(snapshot) {
      // Back-compat: older history entries stored the tree array directly.
      if (Array.isArray(snapshot)) return snapshot;
      if (snapshot && Array.isArray(snapshot.tree)) return snapshot.tree;
      return [];
    }

    function snapshotDragMode(snapshot) {
      if (snapshot && typeof snapshot === 'object' && typeof snapshot.dragMode === 'string') return snapshot.dragMode;
      return null;
    }

    function applySnapshot(snapshot) {
      stateTree = deepClone(snapshotTree(snapshot));
      const mode = snapshotDragMode(snapshot);
      if (mode === 'nav_only' || mode === 'sync_files') {
        dragMode = mode;
        localStorage.setItem('page_tree_drag_mode', dragMode);
        updateDragModeSwitch();
      }
    }

    function pushHistorySnapshot(snapshot) {
      historyPast.push(snapshot);
      if (historyPast.length > 5) historyPast.shift();
      historyFuture = [];
      updateHistoryButtons();
      persistHistory();
    }

    function withHistory(label, mutator) {
      const before = makeSnapshot(stateTree, dragMode);
      pushHistorySnapshot(before);
      mutator();
      pushDebug('history.commit', { label });
      persistHistory();
    }

    async function withHistoryAsync(label, mutator) {
      const before = makeSnapshot(stateTree, dragMode);
      pushHistorySnapshot(before);
      await mutator();
      pushDebug('history.commit', { label });
      persistHistory();
    }

    function buildFileMap(tree) {
      const map = new Map();
      const walk = (nodes) => {
        for (const n of (nodes || [])) {
          if (!n) continue;
          if (n.type === 'page') {
            if (n.id) map.set(n.id, n.file || '');
          } else if (n.type === 'folder') {
            walk(n.children || []);
          }
        }
      };
      walk(tree || []);
      return map;
    }

    function applyFilePrevFromCurrent(targetTree, currentFileMap) {
      const walk = (nodes) => {
        for (const n of (nodes || [])) {
          if (!n) continue;
          if (n.type === 'page') {
            const cur = currentFileMap.get(n.id) || '';
            const next = n.file || '';
            if (cur && next && cur !== next) {
              n.file_prev = cur;
            } else {
              n.file_prev = null;
            }
          } else if (n.type === 'folder') {
            walk(n.children || []);
          }
        }
      };
      walk(targetTree || []);
    }

    async function undo() {
      if (!historyPast.length) {
        setStatus('Nothing to undo.', 'info');
        return;
      }
      const beforeTree = deepClone(stateTree);
      const beforePast = historyPast.slice();
      const beforeFuture = historyFuture.slice();

      const current = makeSnapshot(stateTree, dragMode);
      const previous = historyPast.pop();
      historyFuture.push(current);
      applySnapshot(previous);
      applyFilePrevFromCurrent(stateTree, buildFileMap(beforeTree));
      ensureSelectedValid();
      renderTree();
      updateHistoryButtons();
      pushDebug('history.undo', {});
      setStatus('Undoing...', 'info');
      const res = await fetchJson('/api/apply_history_step', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ before_tree: beforeTree, after_tree: stateTree }),
      });
      if (res && res.error) {
        setStatus(res.error, 'error');
      } else {
        setStatus('Undid last action.', 'success');
      }

      // If blocked, keep history consistent by rolling back.
      if (els.status && els.status.dataset.type === 'error' && String(els.status.textContent || '').includes('Sync blocked')) {
        stateTree = beforeTree;
        historyPast = beforePast;
        historyFuture = beforeFuture;
        ensureSelectedValid();
        renderTree();
        updateHistoryButtons();
        setStatus('Undo blocked by file conflict.', 'error');
        return;
      }
      persistHistory();
    }

    async function redo() {
      if (!historyFuture.length) {
        setStatus('Nothing to redo.', 'info');
        return;
      }
      const beforeTree = deepClone(stateTree);
      const beforePast = historyPast.slice();
      const beforeFuture = historyFuture.slice();

      const current = makeSnapshot(stateTree, dragMode);
      const next = historyFuture.pop();
      historyPast.push(current);
      applySnapshot(next);
      applyFilePrevFromCurrent(stateTree, buildFileMap(beforeTree));
      ensureSelectedValid();
      renderTree();
      updateHistoryButtons();
      pushDebug('history.redo', {});
      setStatus('Redoing...', 'info');
      const res = await fetchJson('/api/apply_history_step', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ before_tree: beforeTree, after_tree: stateTree }),
      });
      if (res && res.error) {
        setStatus(res.error, 'error');
      } else {
        setStatus('Redid last action.', 'success');
      }

      if (els.status && els.status.dataset.type === 'error' && String(els.status.textContent || '').includes('Sync blocked')) {
        stateTree = beforeTree;
        historyPast = beforePast;
        historyFuture = beforeFuture;
        ensureSelectedValid();
        renderTree();
        updateHistoryButtons();
        setStatus('Redo blocked by file conflict.', 'error');
        return;
      }
      persistHistory();
    }

    function persistHistory() {
      try {
        const payload = {
          version: 1,
          at: Date.now(),
          currentSig: treeSignature(stateTree),
          past: historyPast.slice(-5),
          future: historyFuture.slice(-5),
        };
        localStorage.setItem('page_tree_history', JSON.stringify(payload));
      } catch {
        // ignore
      }
    }

    function restoreHistoryIfMatching() {
      try {
        const raw = localStorage.getItem('page_tree_history');
        if (!raw) return;
        const data = JSON.parse(raw);
        if (!data || data.version !== 1) return;
        if (data.currentSig && data.currentSig === treeSignature(stateTree) && Array.isArray(data.past)) {
          historyPast = data.past.slice(-5);
          historyFuture = Array.isArray(data.future) ? data.future.slice(-5) : [];
        }
      } catch {
        // ignore
      }
    }

    function toggleDebug() {
      debugEnabled = !debugEnabled;
      updateDebugVisibility();
      pushDebug('debug.toggle', { enabled: debugEnabled });
    }

    function updateDebugVisibility() {
      if (!els.debugPanel) return;
      els.debugPanel.hidden = !debugEnabled;
      if (els.splitInfoDebug) els.splitInfoDebug.style.display = debugEnabled ? '' : 'none';
      if (els.bottomStack) els.bottomStack.classList.toggle('debug-hidden', !debugEnabled);
      if (els.toolDebugBtn) els.toolDebugBtn.classList.toggle('active', debugEnabled);
      renderDebug();
    }

    function renderDebug() {
      if (!debugEnabled) return;
      const lines = (debugLog || []).slice(-300);
      els.debugLog.textContent = lines.join('\n');
      // Always keep the latest line visible.
      requestAnimationFrame(() => {
        els.debugLog.scrollTop = els.debugLog.scrollHeight;
      });
    }

    function pushDebug(tag, payload) {
      if (!debugEnabled) return;
      const ts = new Date().toISOString().slice(11, 23);
      let detail = '';
      try {
        detail = payload === undefined ? '' : ' ' + JSON.stringify(payload);
      } catch (e) {
        detail = ' ' + String(payload);
      }
      debugLog.push(`[${ts}] ${tag}${detail}`);
      if (debugLog.length > 800) debugLog = debugLog.slice(-800);
      renderDebug();
    }

    async function copyToClipboard(text) {
      try {
        await navigator.clipboard.writeText(text);
      } catch (e) {
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position = 'fixed';
        ta.style.left = '-9999px';
        document.body.appendChild(ta);
        ta.focus();
        ta.select();
        document.execCommand('copy');
        ta.remove();
      }
    }

    function initSplitters() {
      if (!els.workspace) return;

      const defaults = {
        left: 360,
        bottom: 180,
        debug: 180,
        toolsLeft: 520,
      };

      const readNum = (key, fallback) => {
        const raw = localStorage.getItem(key);
        const n = raw ? parseFloat(raw) : NaN;
        return Number.isFinite(n) ? n : fallback;
      };

      const clampNum = (v, min, max) => Math.min(Math.max(v, min), max);
      const left = clampNum(readNum('page_tree_layout_left', defaults.left), 240, 820);
      const bottom = clampNum(readNum('page_tree_layout_bottom', defaults.bottom), 120, 360);
      const debugHeight = clampNum(readNum('page_tree_layout_debug', defaults.debug), 120, 360);
      const toolsLeft = clampNum(readNum('page_tree_layout_tools_left', defaults.toolsLeft), 320, 920);

      els.workspace.style.setProperty('--left-width', `${left}px`);
      els.workspace.style.setProperty('--bottom-height', `${bottom}px`);
      els.workspace.style.setProperty('--debug-height', `${debugHeight}px`);
      els.workspace.style.setProperty('--tools-left-width', `${toolsLeft}px`);

      const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
      let drag = null;

      const onMove = (e) => {
        if (!drag) return;
        const x = e.clientX;
        const y = e.clientY;

        if (drag.kind === 'left') {
          const width = clamp(x - drag.rect.left, 240, drag.max);
          els.workspace.style.setProperty('--left-width', `${width}px`);
          return;
        }
        if (drag.kind === 'bottom') {
          const height = clamp(drag.bottom - y, 120, drag.max);
          els.workspace.style.setProperty('--bottom-height', `${height}px`);
          return;
        }
        if (drag.kind === 'debug') {
          const height = clamp(drag.bottom - y, 120, drag.max);
          els.workspace.style.setProperty('--debug-height', `${height}px`);
          return;
        }
        if (drag.kind === 'tools') {
          const width = clamp(x - drag.left, 320, drag.max);
          els.workspace.style.setProperty('--tools-left-width', `${width}px`);
        }
      };

      const onUp = () => {
        if (!drag) return;
        const style = getComputedStyle(els.workspace);
        localStorage.setItem('page_tree_layout_left', parseFloat(style.getPropertyValue('--left-width')) || defaults.left);
        localStorage.setItem('page_tree_layout_bottom', parseFloat(style.getPropertyValue('--bottom-height')) || defaults.bottom);
        localStorage.setItem('page_tree_layout_debug', parseFloat(style.getPropertyValue('--debug-height')) || defaults.debug);
        localStorage.setItem('page_tree_layout_tools_left', parseFloat(style.getPropertyValue('--tools-left-width')) || defaults.toolsLeft);
        drag = null;
        document.body.classList.remove('is-resizing');
        window.removeEventListener('pointermove', onMove);
        window.removeEventListener('pointerup', onUp);
      };

      const start = (kind) => (e) => {
        e.preventDefault();
        if (kind === 'left') {
          const rect = els.workspace.querySelector('.main-grid').getBoundingClientRect();
          drag = { kind, rect, max: Math.max(240, rect.width - 520) };
        } else if (kind === 'bottom') {
          const rect = els.workspace.getBoundingClientRect();
          drag = { kind, bottom: rect.bottom, max: Math.max(120, rect.height - 320) };
        } else if (kind === 'debug') {
          const rect = els.bottomStack.getBoundingClientRect();
          drag = { kind, bottom: rect.bottom, max: Math.max(120, rect.height - 120) };
        } else if (kind === 'tools') {
          const panel = document.getElementById('panel-tools');
          const rect = panel ? panel.getBoundingClientRect() : els.workspace.getBoundingClientRect();
          drag = { kind, left: rect.left, max: Math.max(320, rect.width - 360) };
        } else {
          drag = { kind };
        }
        document.body.classList.add('is-resizing');
        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onUp);
      };

      if (els.splitMainLeft) els.splitMainLeft.addEventListener('pointerdown', start('left'));
      if (els.splitBottom) els.splitBottom.addEventListener('pointerdown', start('bottom'));
      if (els.splitInfoDebug) els.splitInfoDebug.addEventListener('pointerdown', start('debug'));
      if (els.splitTools) els.splitTools.addEventListener('pointerdown', start('tools'));
    }

    async function fetchJson(url, options) {
      const response = await fetch(url, options);
      const text = await response.text();
      let data = null;
      try { data = text ? JSON.parse(text) : null; } catch (e) { data = null; }
      if (!response.ok) {
        const msg = data && typeof data.error === 'string' ? data.error : 'Request failed.';
        const err = new Error(msg);
        err.data = data;
        err.status = response.status;
        throw err;
      }
      return data;
    }

    function renderStatusHistory() {
      if (!els.status) return;
      if (statusExpanded) {
        els.status.textContent = statusHistory.join('\n');
      } else {
        els.status.textContent = statusHistory[statusHistory.length - 1] || '';
      }
    }

    function setStatus(message, type) {
      const text = String(message || '').trim();
      if (text) {
        statusHistory.push(text);
        if (statusHistory.length > 20) statusHistory = statusHistory.slice(-20);
      }
      els.status.dataset.type = type || 'info';
      renderStatusHistory();
    }

    function setInfoMeta(text) {
      const value = (text || '').trim();
      if (els.infoMeta) els.infoMeta.textContent = value;
      if (els.infoMetaPill) {
        els.infoMetaPill.textContent = shortenPathLine(value);
        els.infoMetaPill.title = value;
      }
    }

    function setInfoSelection(text) {
      const value = (text || '').trim();
      if (els.infoSelection) els.infoSelection.textContent = value;
      if (els.infoSelectionPill) {
        const short = value.replace(/^Selection:\\s*/i, '') || 'Selection: (none)';
        els.infoSelectionPill.textContent = short;
        els.infoSelectionPill.title = value;
      }
    }

    function setInfoHover(text) {
      if (!els.infoHover) return;
      const value = (text || '').trim();
      if (!value) {
        els.infoHover.hidden = true;
        els.infoHover.textContent = '';
        return;
      }
      els.infoHover.hidden = false;
      els.infoHover.textContent = value;
    }

    function shortenPathLine(line) {
      if (!line) return '';
      const parts = line.split('|').map(s => s.trim()).filter(Boolean);
      if (parts.length < 2) return line;
      const mk = parts[0].replace(/\\\\/g, '/').split('/').pop() || parts[0];
      const docs = parts[1].replace(/\\\\/g, '/').split('/').pop() || parts[1];
      return `${mk} ‚Ä¢ ${docs}`;
    }

    function findNode(nodes, id, parent = null) {
      for (const node of (nodes || [])) {
        if (node.id === id) return { node, parent, siblings: nodes };
        if (node.type === 'folder' && Array.isArray(node.children)) {
          const found = findNode(node.children, id, node);
          if (found) return found;
        }
      }
      return null;
    }

    function ensureSelectedValid() {
      if (selectedIds && selectedIds.size) {
        const next = new Set();
        for (const id of selectedIds) {
          if (findNode(stateTree, id)) next.add(id);
        }
        selectedIds = next;
      }
      if (selectedId && !findNode(stateTree, selectedId)) selectedId = '';
      if (selectedId && selectedIds && selectedIds.size && !selectedIds.has(selectedId)) {
        selectedId = Array.from(selectedIds)[0] || '';
      }
      if (!selectedId && selectedIds && selectedIds.size) selectedId = Array.from(selectedIds)[0] || '';
    }

    async function loadMeta() {
      try {
        const data = await fetchJson('/api/meta');
        const text = `${data.mkdocs_path} | ${data.docs_root}`;
        els.meta.textContent = shortenPathLine(text);
        els.meta.title = text;
        setInfoMeta(text);
      } catch (e) {
        els.meta.textContent = '(meta unavailable)';
        setInfoMeta('(meta unavailable)');
      }
    }

    async function loadState(options) {
      const reset = options && options.reset;
      const silentStatus = options && options.silentStatus;
      if (!silentStatus) setStatus('Loading tree...', 'info');
      try {
        const data = await fetchJson('/api/state');
        stateTree = Array.isArray(data.tree) ? data.tree : [];
        lastPersistedSignature = treeSignature(stateTree);
        if (reset) resetHistory();
        else restoreHistoryIfMatching();
        ensureSelectedValid();
        renderTree();
        updateHistoryButtons();
        if (!silentStatus) setStatus('üå≥ Tree loaded.', 'success');
      } catch (e) {
        els.tree.textContent = 'Failed to load tree.';
        if (!silentStatus) setStatus(e.message || 'Failed to load tree.', 'error');
      }
    }

    async function loadSource() {
      try {
        const data = await fetchJson('/api/source');
        sourceTree = Array.isArray(data) ? data : [];
        renderSource();
      } catch (e) {
        els.source.textContent = 'Failed to load source.';
      }
    }

	    async function importFromMkdocs(options) {
	      const opts = options || {};
	      const shouldConfirm = opts.confirm !== false;
	      const shouldBeautify = opts.beautify === true;
	      if (shouldConfirm) {
	        const ok = await showConfirm('Import will overwrite current tree state. Continue?', {
            title: 'Import mkdocs.yml',
            okText: 'Import',
            cancelText: 'Cancel'
          });
	        if (!ok) return;
	      }
	      setStatus('Importing...', 'info');
	      try {
	        const data = await fetchJson('/api/import', { method: 'POST' });
	        stateTree = Array.isArray(data.tree) ? data.tree : [];
	        const warnings = Array.isArray(data.warnings) ? data.warnings : [];
	        lastPersistedSignature = treeSignature(stateTree);
	        resetHistory();
	        selectedId = '';
	        renderTree();
	        updateHistoryButtons();
	        setStatus(warnings.length ? `Imported with warnings (${warnings.length}).` : 'Imported from mkdocs.yml.', warnings.length ? 'info' : 'success');
	        await loadSource();
	        if (shouldBeautify) {
	          // Re-write mkdocs.yml nav with normalized 2-space indentation (nav block only; no file moves).
	          pushDebug('import.beautify', {});
	          await sync('nav_only', { confirm: false, silent: true });
	          setStatus('üñ≤Ô∏è Loaded and beautified mkdocs.yml nav.', 'success');
	        }
	      } catch (e) {
	        const data = e && e.data ? e.data : null;
	        if (data && Array.isArray(data.errors)) {
	          setStatus(`Import blocked: ${data.errors.length} invalid/missing doc path(s).`, 'error');
	          pushDebug('import.blocked', { errors: data.errors });
	          showImportErrors(data);
	          return;
	        }
	        setStatus(e.message || 'Import failed.', 'error');
	      }
	    }

	    async function beautifyNav() {
	      setStatus('Beautifying nav...', 'info');
	      pushDebug('beautify.nav', {});
	      await sync('nav_only', { confirm: false, silent: false });
	    }

	    function showImportErrors(payload) {
	      if (!els.infoErrors || !els.infoDetails) return;
	      const lines = Array.isArray(payload && payload.lines) ? payload.lines : [];
	      const errors = Array.isArray(payload && payload.errors) ? payload.errors : [];
	      const parts = [];
	      parts.push(`mkdocs.yml import blocked (${errors.length})`);
	      for (const err of errors) {
	        if (!err) continue;
	        const kind = err.type || 'error';
	        const file = err.file ? ` file=${err.file}` : '';
	        const path = err.path ? ` path=${err.path}` : '';
	        const msg = err.error ? ` error=${err.error}` : '';
	        parts.push(`- ${kind}${file}${path}${msg}`);
	      }
	      if (lines.length) {
	        parts.push('');
	        parts.push('Matched mkdocs.yml lines:');
	        for (const l of lines) {
	          if (!l) continue;
	          const no = (l.no != null) ? String(l.no) : '';
	          const text = (l.text || '').trimEnd();
	          parts.push(`${no.padStart(4, ' ')} | ${text}`);
	        }
	      }
	      els.infoErrors.hidden = false;
	      els.infoErrors.textContent = parts.join('\n');
	      els.infoDetails.open = true;
	    }

    async function sync(mode, options) {
      const opts = options || {};
      const shouldConfirm = opts.confirm !== false;
      const silent = !!opts.silent;

      if (shouldConfirm) {
        const msg = mode === 'sync_files'
          ? 'This will move .md files (and sibling asset folders) on disk. Continue?'
          : 'This will write mkdocs.yml nav. Continue?';
        const ok = await showConfirm(msg, {
          title: mode === 'sync_files' ? 'Sync Files' : 'Sync Nav',
          okText: 'Continue',
          cancelText: 'Cancel'
        });
        if (!ok) return;
      }
      if (!silent) setStatus('Syncing...', 'info');
      try {
        const data = await fetchJson('/api/sync', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ mode, tree: stateTree })
        });
        const moves = Array.isArray(data.moves) ? data.moves : [];
        const warnings = Array.isArray(data.warnings) ? data.warnings : [];
        const extra = moves.length ? ` moved:${moves.length}` : '';
        const warn = warnings.length ? ` warnings:${warnings.length}` : '';
        if (!silent) setStatus(`Sync ok.${extra}${warn}`, warnings.length ? 'info' : 'success');
        await loadState({ reset: false, silentStatus: silent });
        await loadSource();
        lastPersistedSignature = treeSignature(stateTree);
      } catch (e) {
        const data = e && e.data ? e.data : null;
        if (data && Array.isArray(data.collisions) && data.collisions.length) {
          setStatus(`Sync blocked: file name conflict (${data.collisions.length}). No changes applied.`, 'error');
          pushDebug('sync.blocked', { collisions: data.collisions });
          await loadState({ reset: true, silentStatus: silent });
          await loadSource();
          return;
        }
        setStatus(e.message || 'Sync failed.', 'error');
      }
    }

    function renderSource() {
      els.source.innerHTML = '';
      if (!Array.isArray(sourceTree) || !sourceTree.length) {
        els.source.textContent = '(no markdown files found)';
        return;
      }
      els.source.appendChild(sourceView === 'ascii' ? buildSourceAscii(sourceTree) : buildSourceList(sourceTree));
    }

    function persistSourceCollapsed() {
      localStorage.setItem('page_tree_source_collapsed', JSON.stringify(Array.from(sourceCollapsed)));
    }

    function toggleSourceDir(path) {
      if (!path) return;
      if (sourceCollapsed.has(path)) sourceCollapsed.delete(path);
      else sourceCollapsed.add(path);
      persistSourceCollapsed();
      renderSource();
    }

    function buildSourceList(nodes, depth = 0) {
      const ul = document.createElement('ul');
      ul.className = depth === 0 ? 'source-explorer' : 'source-children';
      for (const node of (nodes || [])) {
        const li = document.createElement('li');
        li.className = 'source-item';
        li.dataset.kind = node.kind || '';
        li.dataset.path = node.path || '';

        const row = document.createElement('div');
        row.className = 'source-row ' + (node.kind === 'dir' ? 'kind-dir' : 'kind-file');
        row.title = node.path ? `./${node.path}` : '';

        const twist = document.createElement('span');
        twist.className = 'source-twist';
        const isDir = node.kind === 'dir';
        const isCollapsed = isDir && node.path && sourceCollapsed.has(node.path);
        twist.textContent = isDir ? (isCollapsed ? '‚ñ∏' : '‚ñæ') : '';
        row.appendChild(twist);

        const icon = document.createElement('span');
        icon.className = 'source-icon';
        icon.textContent = isDir ? 'üóÇÔ∏è' : 'üìù';
        row.appendChild(icon);

        const name = document.createElement('span');
        name.className = 'source-name';
        name.textContent = node.name || '(unnamed)';
        row.appendChild(name);

        li.appendChild(row);

        if (node.kind === 'file') {
          row.classList.add('clickable');
          row.addEventListener('click', (e) => {
            e.stopPropagation();
            // If this file is a section README/index and we can find its overview page, select the overview
            const overview = findOverviewBySourcePath(node.path || '');
            if (overview) {
              selectNode(overview.id);
              return;
            }
            // Default: select the page nav element corresponding to this file
            // Shift+click: select the containing section (folder) instead
            const info = findNodeByFile(node.path || '');
            if (e.shiftKey && info && info.parent && info.parent.id) {
              // select the parent folder's nav element
              selectNode(info.parent.id);
            } else if (info && info.node && info.node.id) {
              // select the page nav element
              locateInTree(node.path || '', { markSourceLocated: false });
            } else {
              // fallback: try locate by path without marking source
              locateInTree(node.path || '', { markSourceLocated: false });
            }
          });
        } else if (node.kind === 'dir') {
          row.classList.add('clickable');
          row.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleSourceDir(node.path || '');
          });
        }

        if (node.kind === 'dir' && Array.isArray(node.children) && node.children.length) {
          const collapsed = node.path && sourceCollapsed.has(node.path);
          if (!collapsed) {
            li.appendChild(buildSourceList(node.children, depth + 1));
          }
        }
        ul.appendChild(li);
      }
      return ul;
    }

    function buildSourceAscii(nodes) {
      const container = document.createElement('div');
      container.className = 'source-ascii';
      const lines = [];

      function walk(items, prefixParts) {
        (items || []).forEach((node, index) => {
          const isLast = index === items.length - 1;
          const branch = isLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ';
          const prefix = (prefixParts || []).join('') + branch;

          const line = document.createElement('div');
          line.className = 'source-line';
          if (node.path) line.dataset.path = node.path || '';

          const pre = document.createElement('span');
          pre.className = 'source-prefix';
          pre.textContent = prefix;
          line.appendChild(pre);

          const name = document.createElement('span');
          name.className = 'source-name ' + (node.kind === 'dir' ? 'kind-dir' : 'kind-file');
          const ext = node.kind === 'file' ? (String(node.name || '').split('.').pop() || '').toLowerCase() : '';
          if (ext) name.dataset.ext = ext;
          name.textContent = node.name || '(unnamed)';
          line.appendChild(name);

          if (node.kind === 'file' && node.path) {
            line.classList.add('clickable');
            line.addEventListener('click', (e) => {
              e.stopPropagation();
              // If this file is a section README/index and we can find its overview page, select the overview
              const overview = findOverviewBySourcePath(node.path || '');
              if (overview) { selectNode(overview.id); return; }
              // Default: select the page nav element corresponding to this file
              // Shift+click: select the containing section (folder) instead
              const info = findNodeByFile(node.path || '');
              if (e.shiftKey && info && info.parent && info.parent.id) {
                selectNode(info.parent.id);
              } else if (info && info.node && info.node.id) {
                locateInTree(node.path || '', { markSourceLocated: false });
              } else {
                locateInTree(node.path || '', { markSourceLocated: false });
              }
            });
          }

          lines.push(line);

          const nextPrefixParts = (prefixParts || []).slice();
          nextPrefixParts.push(isLast ? '    ' : '‚îÇ   ');
          if (Array.isArray(node.children) && node.children.length) {
            walk(node.children, nextPrefixParts);
          }
        });
      }

      walk(nodes || [], []);
      lines.forEach(l => container.appendChild(l));
      return container;
    }

    function locateByFile(file) {
      // Keep legacy tree-locate behavior but prefer locating inside Source explorer
      const normalized = normalizePath(file);
      if (!normalized) return;
      const foundInSource = locateInSource(file);
      if (foundInSource) return;
      // Fallback: highlight in tree if not found in source
      const all = Array.from(document.querySelectorAll('#tree li[data-file]'));
      all.forEach(el => el.classList.remove('flash'));
      const hit = all.find(el => normalizePath(el.dataset.file || '') === normalized);
      if (!hit) {
        setStatus('Not found in tree or source.', 'info');
        return;
      }
      hit.classList.add('flash');
      hit.scrollIntoView({ behavior: 'smooth', block: 'center' });
      setTimeout(() => hit.classList.remove('flash'), 900);
    }

    // Ensure the source explorer has the directory path expanded and scroll/highlight the file item.
    function ensureSourcePathVisible(path) {
      const normalized = normalizePath(path);
      if (!normalized) return null;
      const items = Array.from(document.querySelectorAll('#source .source-item, #source .source-line'));
      // Find matching file element by data-path
      const hit = items.find(el => normalizePath(el.dataset.path || el.dataset.path || el.dataset.file || '') === normalized || normalizePath(el.dataset.path || el.dataset.file || '') === normalized);
      if (!hit) return null;
      // If this is an ASCII line (no nested children), simply mark and scroll
      if (hit.classList && hit.classList.contains('source-line')) {
        clearLocatedSource();
        hit.classList.add('located');
        hit.scrollIntoView({ behavior: 'smooth', block: 'center' });
        // Install one-time global clear handlers so any user action clears .located
        attachLocatedClearHandlers();
        return hit;
      }

      // For the tree-like explorer, expand ancestor directories by triggering their twist toggle (simulate click on their row)
      let parent = hit.parentElement;
      while (parent && parent.id !== 'source') {
        if (parent.classList && (parent.classList.contains('source-children') || parent.classList.contains('source-explorer'))) {
          const prev = parent.previousElementSibling;
          if (prev && prev.classList && prev.classList.contains('source-row') && prev.querySelector('.source-twist')) {
            const twist = prev.querySelector('.source-twist');
            if (twist && twist.textContent === '‚ñ∏') prev.click();
          }
        }
        parent = parent.parentElement;
      }
      // Now scroll the hit into view within the source panel and mark it as located (persist until next action)
      clearLocatedSource();
      hit.classList.add('located');
      hit.scrollIntoView({ behavior: 'smooth', block: 'center' });
      // Install one-time global clear handlers so any user action clears .located
      attachLocatedClearHandlers();
      return hit;
    }

    function clearLocatedSource() {
      const prev = document.querySelectorAll('#source .source-item.located, #source .source-line.located');
      prev && prev.forEach(el => el.classList.remove('located'));
      // Remove any registered global handlers
      if (Array.isArray(locatedClearHandlers) && locatedClearHandlers.length) {
        for (const h of locatedClearHandlers) {
          try { document.removeEventListener(h.event, h.fn, h.opts || false); } catch (e) { /* ignore */ }
        }
        locatedClearHandlers = [];
      }
    }

    function attachLocatedClearHandlers() {
      // Clear any existing handlers first to avoid duplicates
      if (Array.isArray(locatedClearHandlers) && locatedClearHandlers.length) {
        for (const h of locatedClearHandlers) {
          try { document.removeEventListener(h.event, h.fn, h.opts || false); } catch (e) { /* ignore */ }
        }
        locatedClearHandlers = [];
      }
      const events = ['click', 'pointerdown', 'wheel', 'keydown', 'touchstart', 'contextmenu', 'focusin'];
      locatedSuppressUntil = Date.now() + 160; // ignore immediate originating event
      for (const ev of events) {
        const fn = function one(e) {
          if (Date.now() < locatedSuppressUntil) return;
          clearLocatedSource();
        };
        // Use capture for click/pointerdown to catch early
        const opts = (ev === 'click' || ev === 'pointerdown') ? true : false;
        document.addEventListener(ev, fn, opts);
        locatedClearHandlers.push({ event: ev, fn: fn, opts: opts });
      }
    }

    function locateInSource(file) {
      if (!file) return null;
      const path = (file || '').replace(/^\.\//, '');
      // Ensure source panel visible
      showSource = true;
      localStorage.setItem('page_tree_show_source', String(true));
      applyPanelVisibility();
      // Render may be synchronous; attempt to ensure the source DOM exists
      // Try immediate lookup; if not found, wait a short delay for renderSource completion
      let hit = ensureSourcePathVisible(path);
      if (hit) return hit;
      // If not found immediately, try re-render and retry after a tick
      renderSource();
      hit = ensureSourcePathVisible(path);
      if (hit) return hit;
      // Final attempt after small delay
      setTimeout(() => ensureSourcePathVisible(path), 120);
      return null;
    }

    // Locate and select the corresponding nav element in the tree for a given source file
    function locateInTree(file, opts) {
      opts = opts || {};
      const normalized = normalizePath(file || '');
      if (!normalized) return null;
      const all = Array.from(document.querySelectorAll('#tree li[data-file]'));
      all.forEach(el => el.classList.remove('flash'));

      // Matching strategies in order:
      // 1) exact normalized path
      // 2) compare basenames
      // 3) README/index mapping: if source is docs/foo/README.md, match nav file docs/foo.md or docs/foo/README.md or docs/foo/index.md
      // 4) directory-level mapping: if nav has docs/foo/ then match docs/foo/README.md

      const tryNormalize = p => normalizePath(p || '');
      const basename = p => (String(p || '').split('/').pop() || '').toLowerCase();

      let hit = all.find(el => tryNormalize(el.dataset.file) === normalized);
      if (!hit) {
          // 2) basename match but only when it yields a unique candidate
          const name = basename(normalized);
          if (name) {
            const cand = all.filter(el => basename(el.dataset.file) === name);
            if (cand.length === 1) hit = cand[0];
          }
      }
      if (!hit) {
        // 3) README/index mapping
          const dir = normalized;
        const altCandidates = [];
        // if path ends with README.md or index.md, try both forms
        const withoutFile = normalized.replace(/(?:readme|index)\.md$/i, '').replace(/\/$/, '');
        if (withoutFile && withoutFile !== normalized) {
          altCandidates.push(withoutFile + '.md');
          altCandidates.push(withoutFile + '/README.md');
          altCandidates.push(withoutFile + '/index.md');
        }
        // if path is a dir (no .md), try dir/README.md
        if (!/\.md$/i.test(normalized)) {
          altCandidates.push(normalized.replace(/\/$/, '') + '/README.md');
          altCandidates.push(normalized.replace(/\/$/, '') + '/index.md');
        }
        // Try matching candidates exactly first
        for (const c of altCandidates) {
          const n = tryNormalize(c);
          hit = all.find(el => tryNormalize(el.dataset.file) === n);
          if (hit) break;
        }
        // If still not found and this is a README/index, try finding the folder's overview page via stateTree
        if (!hit && /(?:readme|index)\.md$/i.test(normalized)) {
          const folderSegment = dir.replace(/(?:readme|index)\.md$/i, '').replace(/\/$/, '');
          // find folder node in stateTree by segment
          function findFolderBySegment(seg, nodes) {
            for (const n of (nodes || [])) {
              if (!n) continue;
              if (n.type === 'folder' && (n.segment || '') === seg) return n;
              if (Array.isArray(n.children)) {
                const f = findFolderBySegment(seg, n.children);
                if (f) return f;
              }
            }
            return null;
          }
          const folder = findFolderBySegment(folderSegment, stateTree);
          if (folder) {
            const overview = (Array.isArray(folder.children) ? folder.children : []).find(c => c && c.type === 'page' && c.is_overview);
            if (overview && overview.id) {
              const el = document.querySelector(`#tree li.node[data-id="${String(overview.id)}"]`);
              if (el) hit = el;
            }
          }
        }
      }
      if (!hit) return null;

      // Select the node
      const id = hit.dataset.id;
      if (id) {
        selectedId = id;
        selectedIds = new Set([id]);
        selectionAnchorId = id;
        selectionParentKey = selectionKeyForId(id);
        selectedDisplaySlotFolderId = '';
        syncSelectionClasses();
      }
      // Flash and scroll
      hit.classList.add('flash');
      hit.scrollIntoView({ behavior: 'smooth', block: 'center' });
      setTimeout(() => hit.classList.remove('flash'), 900);
      // Also mark the source explorer item as located (persistent) if present
      if (opts.markSourceLocated !== false) {
        try { ensureSourcePathVisible(file); } catch (e) { /* ignore */ }
      }
      return hit;
    }

    // Find a node in stateTree by its file path, return {node, parent} or null
    function findNodeByFile(file, nodes = stateTree, parent = null) {
      const nfile = normalizePath(file || '');
      for (const node of (nodes || [])) {
        if (!node) continue;
        if (node.type === 'page' && normalizePath(node.file || '') === nfile) return { node, parent };
        if (node.type === 'folder' && Array.isArray(node.children)) {
          const found = findNodeByFile(file, node.children, node);
          if (found) return found;
        }
      }
      return null;
    }

    // Find an overview page node by source path (README/index mapping), return node or null
    function findOverviewBySourcePath(file) {
      const nfile = normalizePath(file || '');
      // Direct match to any overview page
      function walk(nodes) {
        for (const node of (nodes || [])) {
          if (!node) continue;
          if (node.type === 'page' && node.is_overview && normalizePath(node.file || '') === nfile) return node;
          if (Array.isArray(node.children)) {
            const found = walk(node.children);
            if (found) return found;
          }
        }
        return null;
      }
      const direct = walk(stateTree);
      if (direct) return direct;
      // If path ends with README.md or index.md, try matching by folder path
      if (/(?:readme|index)\.md$/i.test(nfile)) {
        const folderPath = nfile.replace(/(?:readme|index)\.md$/i, '').replace(/\/$/, '');
        function walkFolder(nodes) {
          for (const node of (nodes || [])) {
            if (!node) continue;
            if (node.type === 'folder') {
              // check children for overview
              const overview = (Array.isArray(node.children) ? node.children : []).find(c => c && c.type === 'page' && c.is_overview && normalizePath(c.file || '').startsWith(folderPath));
              if (overview) return overview;
            }
            if (Array.isArray(node.children)) {
              const found = walkFolder(node.children);
              if (found) return found;
            }
          }
          return null;
        }
        const byFolder = walkFolder(stateTree);
        if (byFolder) return byFolder;
      }
      return null;
    }

    function normalizePath(path) {
      return (path || '').trim().replace(/^\.\//, '').replace(/\\/g, '/').replace(/\/+/g, '/').toLowerCase();
    }

    function renderTree() {
      els.tree.innerHTML = '';
      dropLineEl = dropLineEl || document.createElement('div');
      dropLineEl.className = 'drop-line';
      const list = buildTreeList(Array.isArray(stateTree) ? stateTree : [], true, 0);
      els.tree.appendChild(list);
      els.tree.appendChild(dropLineEl);
      hideDropLine();
      updateSelectionInfo();
      if (!stateTree.length) {
        const hint = document.createElement('div');
        hint.className = 'empty-hint';
        hint.textContent = '(empty)';
        els.tree.appendChild(hint);
      }
    }

    function updateSelectionInfo() {
      if (selectedIds && selectedIds.size > 1) {
        setInfoSelection(`Selection: ${selectedIds.size} items`);
        return;
      }
      if (!selectedId && selectedDisplaySlotFolderId) {
        const found = findNode(stateTree, selectedDisplaySlotFolderId);
        const title = found && found.node ? found.node.title : '(section)';
        setInfoSelection(`Selection: display | ${title}`);
        return;
      }
      if (!selectedId) {
        setInfoSelection('Selection: (none)');
        return;
      }
      const found = findNode(stateTree, selectedId);
      if (!found) {
        setInfoSelection('Selection: (none)');
        return;
      }
      const kind = found.node.type === 'folder' ? 'section' : 'page';
      const file = found.node.file ? ` | file: ./${found.node.file}` : '';
      const segment = found.node.segment ? ` | dir: ${found.node.segment}` : '';
      setInfoSelection(`Selection: ${kind} | ${found.node.title}${segment}${file}`);
    }

	    function selectNode(id) {
	      // Any selection change clears located highlight
	      clearLocatedSource();
	      selectedId = id || '';
	      selectedIds = new Set(selectedId ? [selectedId] : []);
	      selectionAnchorId = selectedId;
	      selectionParentKey = selectionKeyForId(selectedId);
	      selectedDisplaySlotFolderId = '';
	      syncSelectionClasses();
        // Scroll selection into view: prefer page li, otherwise overview slot
        if (selectedId) {
          const el = document.querySelector(`#tree li.node[data-id="${CSS.escape(selectedId)}"]`);
          if (el) {
            el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            return;
          }
          const ov = document.querySelector(`#tree .overview-inline[data-overview-id="${CSS.escape(selectedId)}"]`);
          if (ov) ov.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
	    }

	    function clearSelection() {
	      clearLocatedSource();
	      selectedId = '';
	      selectedIds = new Set();
	      selectionAnchorId = '';
	      selectionParentKey = '';
	      selectedDisplaySlotFolderId = '';
	      syncSelectionClasses();
	    }

    function selectionKeyForId(id) {
      if (!id) return '';
      const info = findNode(stateTree, id);
      if (!info) return '';
      return info.parent ? `p:${info.parent.id}` : 'root';
    }

	    function syncSelectionClasses() {
	      document.querySelectorAll('#tree li.node.selected').forEach(el => el.classList.remove('selected'));
	      document.querySelectorAll('#tree .overview-inline.selected').forEach(el => el.classList.remove('selected'));
	      for (const id of (selectedIds || [])) {
	        const el = document.querySelector(`#tree li.node[data-id="${CSS.escape(id)}"]`);
	        if (el) el.classList.add('selected');
	        const ov = document.querySelector(`#tree .overview-inline[data-overview-id="${CSS.escape(id)}"]`);
	        if (ov) ov.classList.add('selected');
	      }
	      if (selectedDisplaySlotFolderId) {
	        const slot = document.querySelector(`#tree .overview-inline[data-folder-id="${CSS.escape(selectedDisplaySlotFolderId)}"]`);
	        if (slot) slot.classList.add('selected');
	      }
	      updateSelectionInfo();
        maybeLoadEditorFromSelection();
	    }

    function selectWithModifiers(id, e) {
      const isMeta = !!(e && (e.metaKey || e.ctrlKey));
      const isShift = !!(e && e.shiftKey);
      const key = selectionKeyForId(id);
      if (!id) return;

      // Clear located highlight when user changes selection via mouse modifiers
      clearLocatedSource();

      // First selection.
      if (!selectedIds || selectedIds.size === 0) {
        selectedId = id;
        selectedIds = new Set([id]);
        selectionAnchorId = id;
        selectionParentKey = key;
        syncSelectionClasses();
        return;
      }

      // Restrict multi-select to the same parent (same siblings list).
      if (selectionParentKey && key && selectionParentKey !== key) {
        selectedId = id;
        selectedIds = new Set([id]);
        selectionAnchorId = id;
        selectionParentKey = key;
        syncSelectionClasses();
        return;
      }

      if (isShift && selectionAnchorId) {
        const anchorInfo = findNode(stateTree, selectionAnchorId);
        const targetInfo = findNode(stateTree, id);
        if (!anchorInfo || !targetInfo) return;
        const sameParent = (anchorInfo.parent ? anchorInfo.parent.id : 'root') === (targetInfo.parent ? targetInfo.parent.id : 'root');
        if (!sameParent) {
          selectedId = id;
          selectedIds = new Set([id]);
          selectionAnchorId = id;
          selectionParentKey = key;
          syncSelectionClasses();
          return;
        }
        const siblings = anchorInfo.siblings || [];
        const a = siblings.findIndex(n => n.id === selectionAnchorId);
        const b = siblings.findIndex(n => n.id === id);
        if (a < 0 || b < 0) return;
        const lo = Math.min(a, b);
        const hi = Math.max(a, b);
        const next = new Set();
        for (let i = lo; i <= hi; i++) next.add(siblings[i].id);
        selectedIds = next;
        selectedId = id;
        selectionParentKey = key;
        syncSelectionClasses();
        return;
      }

      if (isMeta) {
        const next = new Set(selectedIds || []);
        if (next.has(id)) next.delete(id);
        else next.add(id);
        selectedIds = next;
        selectedId = id;
        selectionAnchorId = id;
        selectionParentKey = key;
        if (!selectedIds.size) {
          selectedId = '';
          selectionAnchorId = '';
          selectionParentKey = '';
        }
        syncSelectionClasses();
        return;
      }

      // Plain click: single select.
      selectedId = id;
      selectedIds = new Set([id]);
      selectionAnchorId = id;
      selectionParentKey = key;
      syncSelectionClasses();
    }

    function persistTreeCollapsed() {
      localStorage.setItem('page_tree_tree_collapsed', JSON.stringify(Array.from(treeCollapsed)));
    }

    function toggleTreeDir(id) {
      if (!id) return;
      if (treeCollapsed.has(id)) treeCollapsed.delete(id);
      else treeCollapsed.add(id);
      persistTreeCollapsed();
      renderTree();
    }

    function displayTitleForNode(node) {
      const title = String((node && node.title) || '').trim();
      if (!title) return '(untitled)';
      if (title.includes('/') || title.includes('\\')) {
        const parts = title.replace(/\\/g, '/').split('/');
        return parts[parts.length - 1] || title;
      }
      return title;
    }

	    function buildTreeList(nodes, isRoot = false, depth = 0) {
	      const ul = document.createElement('ul');
	      ul.className = isRoot ? 'tree-root tree-explorer' : 'tree-children tree-explorer';
	      for (const node of (nodes || [])) {
        const li = document.createElement('li');
        li.className = 'node tree-item ' + (node.type === 'folder' ? 'dir' : 'page');
        li.draggable = true;
        li.dataset.id = node.id || '';
        li.dataset.type = node.type || 'page';
        li.dataset.title = node.title || '';
        li.dataset.segment = node.segment || '';
        li.dataset.file = node.file || '';
        li.dataset.depth = String(depth);

        if ((selectedIds && selectedIds.has(li.dataset.id)) || li.dataset.id === selectedId) li.classList.add('selected');

	        const row = document.createElement('div');
	        row.className = 'row tree-row ' + (node.type === 'folder' ? 'kind-dir' : 'kind-file');
	        row.style.paddingLeft = `${8 + depth * 8}px`;
        row.addEventListener('click', (e) => {
          e.stopPropagation();
          if (activeInlineEdit) return;
          selectWithModifiers(li.dataset.id, e);
        });

	        const left = document.createElement('div');
	        left.className = 'row-left';

	        const twist = document.createElement('span');
	        twist.className = 'tree-twist';
	        const isFolder = node.type === 'folder';
	        const collapsed = isFolder && treeCollapsed.has(li.dataset.id);
	        const allowedByDepth = (depth + 2) <= maxLevelValue();
	        const canExpand = isFolder && allowedByDepth;
	        twist.textContent = isFolder ? (collapsed ? '‚ñ∏' : '‚ñæ') : '';
        twist.addEventListener('click', (e) => {
          e.stopPropagation();
          if (!isFolder) return;
          if (!canExpand) {
            setStatus(`Depth limited to ${treeMaxLevel === 'n' ? '‚àû' : treeMaxLevel} levels.`, 'info');
            return;
          }
          toggleTreeDir(li.dataset.id);
        });
	        left.appendChild(twist);

	        const icon = document.createElement('span');
	        icon.className = 'tree-icon';
	        icon.textContent = isFolder ? 'üóÉÔ∏è' : 'üóíÔ∏è';
	        left.appendChild(icon);

		        const title = document.createElement('span');
		        title.className = 'node-title';
		        title.textContent = node && node.is_overview ? '' : displayTitleForNode(node);
	        title.addEventListener('dblclick', (e) => {
	          e.stopPropagation();
	          selectedId = li.dataset.id;
	          if (node && node.is_overview) return;
	          beginInlineEdit(li.dataset.id, 'title', title);
	        });
		        left.appendChild(title);

	        row.appendChild(left);

	        // Section overview slot (title-less): inline with section header.
	        if (isFolder) {
	          const children = Array.isArray(node.children) ? node.children : [];
	          const overview = children.find(c => c && c.type === 'page' && c.is_overview) || null;
	          const slot = document.createElement('div');
	          slot.className = 'overview-inline';
	          slot.dataset.overviewId = overview && overview.id ? String(overview.id) : '';
	          slot.dataset.folderId = li.dataset.id || '';
	          // Prevent row click/drag handlers from swallowing slot interactions.
	          slot.addEventListener('pointerdown', (e) => e.stopPropagation());
	          const label = document.createElement('span');
	          label.className = 'overview-label';
	          label.textContent = 'Display';
	          slot.appendChild(label);

	          const value = document.createElement('span');
	          value.className = 'overview-value';
	          slot.appendChild(value);

          if (overview && overview.file) {
            slot.classList.add('has-overview');
            slot.draggable = true;
            slot.dataset.id = overview && overview.id ? String(overview.id) : '';
            slot.dataset.type = 'page';
            slot.dataset.title = overview && overview.title ? String(overview.title) : '';
            slot.dataset.file = overview && overview.file ? String(overview.file) : '';
            if ((selectedIds && selectedIds.has(overview.id)) || selectedId === overview.id) slot.classList.add('selected');
            value.textContent = `./${String(overview.file).replace(/^\.\//, '')}`;
            slot.title = value.textContent;
            slot.addEventListener('dragstart', onDragStart);
            slot.addEventListener('dragend', onDragEnd);
            slot.addEventListener('click', (e) => {
              e.stopPropagation();
              if (activeInlineEdit) return;
              selectedDisplaySlotFolderId = '';
              selectNode(overview.id);
            });
	            slot.addEventListener('dblclick', (e) => {
	              e.stopPropagation();
	              if (activeInlineEdit) return;
	              selectedId = overview.id;
	              beginInlineEdit(overview.id, 'file', value);
	            });
		          } else {
		            slot.classList.add('empty');
		            value.textContent = '(none)';
		            slot.addEventListener('click', (e) => {
		              e.stopPropagation();
		              if (activeInlineEdit) return;
		              const folderId = li.dataset.id || '';
		              // Select the display slot itself (no page exists yet).
		              selectedId = '';
		              selectedIds = new Set();
		              selectionAnchorId = '';
		              selectionParentKey = '';
		              selectedDisplaySlotFolderId = folderId;
		              syncSelectionClasses();
		            });
		          }
	          row.appendChild(slot);
	        }

	        // Pages show file location; folders don't need to show "path/meta".
	        const meta = document.createElement('span');
	        meta.className = 'node-meta';
        if (isFolder) {
          meta.textContent = folderDirForId(li.dataset.id) || (node.segment ? `${node.segment}` : '');
          meta.addEventListener('dblclick', (e) => {
            e.stopPropagation();
            selectedId = li.dataset.id;
            beginInlineEdit(li.dataset.id, 'segment', meta);
          });
          row.appendChild(meta);
        } else {
          meta.textContent = node.file ? `./${node.file}` : '';
          meta.addEventListener('dblclick', (e) => {
            e.stopPropagation();
            selectedId = li.dataset.id;
            beginInlineEdit(li.dataset.id, 'file', meta);
          });
          row.appendChild(meta);
        }

        li.appendChild(row);

	        li.addEventListener('dragstart', onDragStart);
		        li.addEventListener('dragend', onDragEnd);

		        if (node.type === 'folder') {
		          const children = Array.isArray(node.children) ? node.children : [];
		          // Overview page is rendered in the header slot, not in the list.
		          const rest = children.filter(c => !(c && c.type === 'page' && c.is_overview));
		          const collapsed = treeCollapsed.has(li.dataset.id);
		          if (!collapsed && canExpand) {
		            li.appendChild(buildTreeList(rest, false, depth + 1));
		          } else {
	            // Keep an empty children container so folder still shows as a folder
	            // but without large nested blocks.
	            const emptyUl = document.createElement('ul');
	            emptyUl.className = 'tree-children tree-explorer is-collapsed';
            li.appendChild(emptyUl);
          }
        }
        ul.appendChild(li);
      }
      return ul;
    }

    function onDragStart(e) {
      // dragstart bubbles: prevent parent <li> handlers from overwriting draggedId
      e.stopPropagation();
      if (activeInlineEdit) {
        e.preventDefault();
        return;
      }
      if (e.currentTarget && e.currentTarget.classList && e.currentTarget.classList.contains('is-editing')) {
        e.preventDefault();
        return;
      }
      const id = e.currentTarget.dataset.id || '';
      if (selectedIds && selectedIds.size > 1 && selectedIds.has(id)) {
        draggedIds = Array.from(selectedIds);
      } else {
        draggedIds = id ? [id] : [];
        if (id && (!selectedIds || !selectedIds.has(id))) selectNode(id);
      }
      draggedId = draggedIds[0] || id || '';
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', draggedId);
      e.currentTarget.classList.add('dragging');
      pushDebug('drag.start', { draggedId, draggedIds, type: e.currentTarget.dataset.type || '', title: e.currentTarget.dataset.title || '' });
    }

    function onDragEnd(e) {
      // dragend bubbles too; keep state consistent
      e.stopPropagation();
      if (e && e.currentTarget) e.currentTarget.classList.remove('dragging');
      draggedId = '';
      draggedIds = [];
      clearDropVisual();
      pushDebug('drag.end', {});
    }

    function onTreeDragLeave(e) {
      if (!e) return;
      const related = e.relatedTarget;
      if (related && els.tree.contains(related)) {
        return;
      }
      clearDropVisual();
    }

    function onTreeDragOver(e) {
      if (!draggedId) return;
      e.preventDefault();
      updateDropHintFromPointer(e.clientX, e.clientY);
    }

    async function onTreeDrop(e) {
      if (!draggedId) return;
      e.preventDefault();
      pushDebug('drop.before', { draggedId, dropHint });
      await applyDrop();
      clearDropVisual();
      renderTree();
      if (dragMode === 'nav_only') {
        scheduleNavOnly('drag.drop.nav_only');
	      } else {
	        scheduleDragFilesSync('drag.drop.files');
	      }
	    }

	    function collectDraggedIdsForSync() {
	      const ids = (draggedIds && draggedIds.length) ? draggedIds : (draggedId ? [draggedId] : []);
	      return Array.from(new Set((ids || []).filter(Boolean)));
	    }

	    async function scheduleDragFilesSync(reason) {
	      if (autoSyncTimer) clearTimeout(autoSyncTimer);
	      const movedIds = collectDraggedIdsForSync();
	      autoSyncTimer = setTimeout(async () => {
	        autoSyncTimer = null;
	        pushDebug('auto_sync.run', { mode: 'drag_files', reason, movedIds });
	        setStatus('Syncing drag...', 'info');
	        try {
	          const data = await fetchJson('/api/sync_drag_files', {
	            method: 'POST',
	            headers: { 'Content-Type': 'application/json' },
	            body: JSON.stringify({ tree: stateTree, moved_ids: movedIds })
	          });
	          const moves = Array.isArray(data.moves) ? data.moves : [];
	          setStatus(`Drag synced.${moves.length ? ` moved:${moves.length}` : ''}`, 'success');
	          await loadState({ reset: false, silentStatus: true });
	          await loadSource();
	        } catch (e) {
	          const data = e && e.data ? e.data : null;
	          if (data && Array.isArray(data.collisions) && data.collisions.length) {
	            setStatus(`Drag blocked: file conflict (${data.collisions.length}). No changes applied.`, 'error');
	            pushDebug('drag.sync.blocked', { collisions: data.collisions });
	            await loadState({ reset: true, silentStatus: true });
	            await loadSource();
	            return;
	          }
	          setStatus(e.message || 'Drag sync failed.', 'error');
	        }
	      }, 250);
	    }

    function updateDropHintFromPointer(clientX, clientY) {
      const el = document.elementFromPoint(clientX, clientY);
      if (!el) {
        dropHint = { mode: 'root', targetId: '' };
        showRootDrop();
        logDropHint('root', '');
        return;
      }

      const li = el.closest('#tree li.node');
      if (!li) {
        // Over whitespace: if inside a folder's children box, treat as inside; otherwise root.
        const ul = el.closest('#tree ul');
        const parentFolder = ul ? ul.closest('li[data-type="folder"]') : null;
        if (parentFolder) {
          const folderId = parentFolder.dataset.id || '';
          dropHint = { mode: 'inside', targetId: folderId };
          showInside(parentFolder);
          logDropHint('inside', folderId);
        } else {
          dropHint = { mode: 'root', targetId: '' };
          showRootDrop();
          logDropHint('root', '');
        }
        return;
      }

      const targetId = li.dataset.id || '';
      const type = li.dataset.type || 'page';
      const row = li.querySelector(':scope > .row') || li;
      const rowRect = row.getBoundingClientRect();
      const ratio = rowRect.height ? ((clientY - rowRect.top) / rowRect.height) : 0.5;

      const inChildrenBox = type === 'folder' && (() => {
        const childUl = li.querySelector(':scope > ul');
        return childUl && childUl.contains(el) && !row.contains(el);
      })();

      if (inChildrenBox) {
        dropHint = { mode: 'inside', targetId };
        showInside(li);
        logDropHint('inside', targetId);
        return;
      }

      let mode = 'inside';
      if (ratio <= 0.25) mode = 'before';
      else if (ratio >= 0.75) mode = 'after';
      if (type === 'page' && mode === 'inside') mode = ratio < 0.5 ? 'before' : 'after';

      dropHint = { mode, targetId };
      if (mode === 'inside') showInside(li);
      else showLineAt(rowRect, mode === 'after');
      logDropHint(mode, targetId);
    }

    function logDropHint(mode, targetId) {
      const sig = `${mode}::${targetId}::${draggedId}::${(draggedIds || []).join(',')}`;
      const now = Date.now();
      if (sig === lastDropHintSignature && now - lastDragoverLogAt < 120) return;
      lastDropHintSignature = sig;
      lastDragoverLogAt = now;
      const target = targetId ? findNode(stateTree, targetId) : null;
      pushDebug('drag.over', {
        draggedId,
        draggedIds,
        mode,
        targetId,
        targetTitle: target ? target.node.title : null,
        targetType: target ? target.node.type : null
      });
    }

    async function applyDrop() {
      const { mode, targetId } = dropHint || {};
      if (!mode) return;

      // Never allow moving into/self/descendant; treat as no-op (keeps detector free).
      const ids = (draggedIds && draggedIds.length) ? draggedIds : (draggedId ? [draggedId] : []);
      const descendant = targetId ? ids.some(id => isDescendant(id, targetId)) : false;
      const selfHit = targetId ? ids.includes(targetId) : false;
      if (targetId && (selfHit || descendant)) {
        const dragged = findNode(stateTree, draggedId);
        const target = findNode(stateTree, targetId);
        pushDebug('drop.noop', {
          reason: selfHit ? 'self_or_group' : 'target_is_descendant',
          mode,
          draggedId,
          draggedIds: ids,
          draggedTitle: dragged ? dragged.node.title : null,
          draggedPath: nodePath(draggedId),
          targetId,
          targetTitle: target ? target.node.title : null,
          targetPath: nodePath(targetId),
        });
        setStatus(targetId === draggedId ? 'Invalid: dropped on itself.' : 'Invalid: cannot drop a parent into its child.', 'info');
        return;
      }

      if (mode === 'root') {
        pushDebug('drop.apply', { mode, targetId: '' });
        await withHistoryAsync('drop.root', () => moveNodes(ids, '', 'root'));
        setStatus('Moved.', 'success');
        return;
      }
      if (mode === 'inside') {
        pushDebug('drop.apply', { mode, targetId });
        await withHistoryAsync('drop.inside', () => moveNodes(ids, targetId, 'inside'));
        setStatus('Moved.', 'success');
        return;
      }
      if (mode === 'before' || mode === 'after') {
        pushDebug('drop.apply', { mode, targetId });
        await withHistoryAsync(`drop.${mode}`, () => moveNodes(ids, targetId, mode));
        setStatus('Moved.', 'success');
      }
    }

	    async function moveNodes(ids, targetId, mode) {
	      const list = Array.from(new Set((ids || []).filter(Boolean)));
	      if (!list.length) return;

	      // Overview pages are special:
	      // - Moving them converts to a normal page and prompts for a title.
	      const asNodes = list.map(id => {
	        const found = findNode(stateTree, id);
	        return found ? found.node : null;
	      }).filter(Boolean);

	      if (mode === 'root') {
	        const ctxs = detachManyWithContext(list);
	        const targetDir = targetFolderDirForMove('root', '');
	        for (const ctx of ctxs) {
	          if (!(await promptRenameForOverview(ctx, targetDir))) {
	            restoreAll(ctxs);
	            return;
	          }
	          stateTree.push(ctx.node);
	        }
	        return;
	      }

	      if (mode === 'inside') {
	        const targetInfo = findNode(stateTree, targetId);
	        if (!targetInfo || targetInfo.node.type !== 'folder') return;
	        targetInfo.node.children = Array.isArray(targetInfo.node.children) ? targetInfo.node.children : [];
	        const ctxs = detachManyWithContext(list);
	        const overviewIdx = targetInfo.node.children.findIndex(n => n && n.type === 'page' && n.is_overview);
	        const targetDir = targetFolderDirForMove('inside', targetId);
	        for (const ctx of ctxs) {
	          if (!(await promptRenameForOverview(ctx, targetDir))) {
	            restoreAll(ctxs);
	            return;
	          }
	          if (overviewIdx >= 0) targetInfo.node.children.splice(overviewIdx + 1, 0, ctx.node);
	          else targetInfo.node.children.push(ctx.node);
	        }
	        return;
	      }

	      if (mode === 'before' || mode === 'after') {
	        // Detach first, then re-find target to get correct index after removal.
	        const ctxs = detachManyWithContext(list);
	        const targetInfo = findNode(stateTree, targetId);
	        if (!targetInfo) return;
	        const siblings = targetInfo.siblings;
	        const idx = siblings.findIndex(n => n.id === targetId);
	        if (idx < 0) return;
	        let insertAt = mode === 'before' ? idx : idx + 1;
	        const overviewAt = siblings.findIndex(n => n && n.type === 'page' && n.is_overview);
	        if (overviewAt >= 0 && insertAt <= overviewAt + 0) {
	          // Never insert before the overview slot.
	          insertAt = overviewAt + 1;
	        }
	        const targetDir = targetFolderDirForMove(mode, targetId);
	        for (const ctx of ctxs) {
	          if (!(await promptRenameForOverview(ctx, targetDir))) {
	            restoreAll(ctxs);
	            return;
	          }
	          siblings.splice(insertAt, 0, ctx.node);
	          insertAt += 1;
	        }
	      }
	    }

    function isDescendant(dragId, targetId) {
      const drag = findNode(stateTree, dragId);
      const target = findNode(stateTree, targetId);
      if (!drag || !target) return false;
      let p = target.parent;
      while (p) {
        if (p.id === drag.node.id) return true;
        const parentInfo = findNode(stateTree, p.id);
        p = parentInfo ? parentInfo.parent : null;
      }
      return false;
    }

    function detachNode(id) {
      const found = findNode(stateTree, id);
      if (!found) return null;
      const idx = found.siblings.findIndex(n => n.id === id);
      if (idx < 0) return null;
      return found.siblings.splice(idx, 1)[0];
    }

    function detachNodeWithContext(id) {
      const found = findNode(stateTree, id);
      if (!found) return null;
      const idx = found.siblings.findIndex(n => n.id === id);
      if (idx < 0) return null;
      const node = found.siblings.splice(idx, 1)[0];
      return { node, siblings: found.siblings, index: idx };
    }

    function detachManyWithContext(ids) {
      const contexts = [];
      const byParent = new Map();
      for (const id of (ids || [])) {
        const found = findNode(stateTree, id);
        if (!found) continue;
        const idx = found.siblings.findIndex(n => n.id === id);
        if (idx < 0) continue;
        const parentKey = found.parent ? found.parent.id : 'root';
        if (!byParent.has(parentKey)) byParent.set(parentKey, []);
        byParent.get(parentKey).push({ id, siblings: found.siblings, index: idx, parentId: parentKey });
      }

      // Detach in descending index per parent to keep indices valid.
      for (const group of byParent.values()) {
        group.sort((a, b) => b.index - a.index);
        for (const item of group) {
          const node = item.siblings.splice(item.index, 1)[0];
          contexts.push({
            id: item.id,
            node,
            fromIndex: item.index,
            index: item.index,
            siblings: item.siblings,
            parentId: item.parentId
          });
        }
      }

      // Return in ascending original index order (stable visual order within parent).
      contexts.sort((a, b) => a.fromIndex - b.fromIndex);
      return contexts;
    }

    function slugifyFileBase(text) {
      const cleaned = String(text || '').trim().toLowerCase();
      const slug = cleaned.replace(/[^0-9a-z._-]+/g, '-').replace(/^-+|-+$/g, '');
      return slug || 'page';
    }

    function buildBasenameFromInput(input) {
      const raw = String(input || '').trim().replace(/\\/g, '/');
      if (!raw) return '';
      const name = raw.split('/').pop();
      if (!name) return '';
      const lower = name.toLowerCase();
      const allowed = ['.md', '.markdown', '.mdx'];
      if (allowed.some(ext => lower.endsWith(ext))) return name;
      if (name.includes('.')) return `${name}.md`;
      return `${slugifyFileBase(name)}.md`;
    }

    function targetFolderDirForMove(mode, targetId) {
      if (mode === 'root') return '';
      if (mode === 'inside') return folderDirForId(targetId);
      const targetInfo = findNode(stateTree, targetId);
      if (targetInfo && targetInfo.parent && targetInfo.parent.type === 'folder') {
        return folderDirForId(targetInfo.parent.id);
      }
      return '';
    }

    async function promptRenameForOverview(ctx, targetDir) {
      if (!ctx || !ctx.node || !ctx.node.is_overview) return true;
      const currentTitle = String(ctx.node.title || '').trim() || 'Overview';
      const nextTitle = await showPrompt('Moving a section overview page. Enter a new title (used for filename):', {
        title: 'Rename Overview',
        okText: 'Rename',
        cancelText: 'Cancel',
        defaultValue: currentTitle
      });
      if (nextTitle === null) return false;
      const trimmedTitle = String(nextTitle).trim() || currentTitle;
      const basename = buildBasenameFromInput(trimmedTitle);
      if (!basename) return false;
      const desiredRel = targetDir ? `${targetDir}/${basename}` : basename;
      if (ctx.node.file && !ctx.node.file_prev) ctx.node.file_prev = ctx.node.file;
      ctx.node.title = trimmedTitle;
      ctx.node.file = desiredRel;
      ctx.node.is_overview = false;
      return true;
    }

    function restoreAll(ctxs) {
      const sorted = Array.from(ctxs || []).sort((a, b) => (b.index || 0) - (a.index || 0));
      sorted.forEach(restoreDetached);
    }

    function nodePath(id) {
      if (!id) return [];
      const found = findNode(stateTree, id);
      if (!found) return [];
      const parts = [found.node.title || found.node.id];
      let p = found.parent;
      while (p) {
        parts.push(p.title || p.id);
        const parentInfo = findNode(stateTree, p.id);
        p = parentInfo ? parentInfo.parent : null;
      }
      return parts.reverse();
    }

    function restoreDetached(ctx) {
      if (!ctx || !ctx.node || !ctx.siblings) return;
      const idx = typeof ctx.index === 'number' ? ctx.index : ctx.siblings.length;
      ctx.siblings.splice(Math.min(Math.max(idx, 0), ctx.siblings.length), 0, ctx.node);
    }

    function moveNodeToRoot(id) {
      const ctx = detachNodeWithContext(id);
      if (!ctx) return;
      pushDebug('move.root', { id, title: ctx.node.title, fromIndex: ctx.index, fromPath: nodePath(id) });
      stateTree.push(ctx.node);
      pushDebug('move.root.done', { rootCount: stateTree.length });
    }

    function moveIntoFolder(dragId, folderId) {
      const folder = findNode(stateTree, folderId);
      if (!folder || folder.node.type !== 'folder') return;
      const ctx = detachNodeWithContext(dragId);
      if (!ctx) return;
      folder.node.children = Array.isArray(folder.node.children) ? folder.node.children : [];
      pushDebug('move.inside', {
        dragId,
        folderId,
        fromPath: nodePath(dragId),
        toPath: nodePath(folderId),
        insertIndex: folder.node.children.length
      });
      folder.node.children.push(ctx.node);
    }

    function moveNode(dragId, targetId, mode) {
      const targetInfo = findNode(stateTree, targetId);
      if (!targetInfo) return;
      const ctx = detachNodeWithContext(dragId);
      if (!ctx) return;

      if (mode === 'inside' && targetInfo.node.type === 'folder') {
        targetInfo.node.children = Array.isArray(targetInfo.node.children) ? targetInfo.node.children : [];
        targetInfo.node.children.push(ctx.node);
        return;
      }
      const siblings = targetInfo.siblings;
      const idx = siblings.findIndex(n => n.id === targetId);
      if (idx < 0) {
        pushDebug('move.restore', { reason: 'target_missing', dragId, targetId });
        restoreDetached(ctx);
        return;
      }
      pushDebug('move.sibling', {
        dragId,
        targetId,
        mode,
        targetIndex: idx,
        insertIndex: mode === 'before' ? idx : idx + 1,
        toParent: targetInfo.parent ? (targetInfo.parent.title || targetInfo.parent.id) : null
      });
      siblings.splice(mode === 'before' ? idx : idx + 1, 0, ctx.node);
    }

    function clearDropVisual() {
      dropHint = { mode: null, targetId: null };
      els.tree.classList.remove('drop-root');
      hideDropLine();
      document.querySelectorAll('#tree .drop-before, #tree .drop-after, #tree .drop-inside')
        .forEach(el => el.classList.remove('drop-before', 'drop-after', 'drop-inside'));
    }

    function hideDropLine() {
      if (!dropLineEl) return;
      dropLineEl.style.display = 'none';
    }

    function showRootDrop() {
      els.tree.classList.add('drop-root');
      hideDropLine();
      document.querySelectorAll('#tree .drop-inside').forEach(el => el.classList.remove('drop-inside'));
    }

    function showInside(li) {
      els.tree.classList.remove('drop-root');
      hideDropLine();
      document.querySelectorAll('#tree .drop-inside').forEach(el => el.classList.remove('drop-inside'));
      if (li) li.classList.add('drop-inside');
    }

    function showLineAt(targetRect, placeAfter) {
      els.tree.classList.remove('drop-root');
      document.querySelectorAll('#tree .drop-inside').forEach(el => el.classList.remove('drop-inside'));
      if (!dropLineEl) return;
      const containerRect = els.tree.getBoundingClientRect();
      const y = (placeAfter ? targetRect.bottom : targetRect.top) - containerRect.top + els.tree.scrollTop;
      dropLineEl.style.top = (y - 1) + 'px';
      dropLineEl.style.display = 'block';
    }

	    async function createNode(type) {
	      const creatingDisplay = type === 'page' && !!selectedDisplaySlotFolderId;
	      const title = creatingDisplay
	        ? 'Overview'
	        : await showPrompt(type === 'folder' ? 'Section title:' : 'Page title:', {
	          title: type === 'folder' ? 'New Section' : 'New Page',
	          okText: 'Create',
	          cancelText: 'Cancel'
	        });
	      if (!title || !title.trim()) {
	        setStatus('‚ö†Ô∏è Title is required. Creation cancelled.', 'info');
	        return;
	      }

	      const parentDir = (() => {
	        if (selectedDisplaySlotFolderId) return folderDirForId(selectedDisplaySlotFolderId);
	        if (!selectedId) return '';
	        const info = findNode(stateTree, selectedId);
	        if (!info) return '';
	        if (info.node.type === 'folder') return folderDirForId(info.node.id);
	        if (info.parent && info.parent.type === 'folder') return folderDirForId(info.parent.id);
	        return '';
	      })();
	      {
	        const id = selectedId || selectedDisplaySlotFolderId;
	        const info = id ? findNode(stateTree, id) : null;
	        const meta = info && info.node ? {
	          id,
	          type: info.node.type,
	          title: info.node.title,
	          segment: info.node.segment,
	          file: info.node.file
	        } : { id };
	        console.warn('[createNode] parent_dir', { parentDir, meta, selectedId, selectedDisplaySlotFolderId });
	        if (!parentDir) {
	          setStatus('‚ö†Ô∏è parent_dir is empty; creation will go to root. Check selection/segment.', 'info');
	        }
	      }

	      let newId = '';
	      withHistory('create', () => {
	        const parentInfo = selectedDisplaySlotFolderId
	          ? findNode(stateTree, selectedDisplaySlotFolderId)
	          : (selectedId ? findNode(stateTree, selectedId) : null);
	        let container = stateTree;
	        if (parentInfo) {
	          if (parentInfo.node.type === 'folder') {
	            parentInfo.node.children = Array.isArray(parentInfo.node.children) ? parentInfo.node.children : [];
	            container = parentInfo.node.children;
	          } else if (parentInfo.parent && parentInfo.parent.type === 'folder') {
	            parentInfo.parent.children = Array.isArray(parentInfo.parent.children) ? parentInfo.parent.children : [];
	            container = parentInfo.parent.children;
	          }
	        }

	        const id = crypto && crypto.randomUUID ? crypto.randomUUID().replace(/-/g, '') : String(Date.now());
	        newId = id;
	        if (type === 'folder') {
	          container.push({ id, type: 'folder', title: title.trim(), segment: '', file: null, children: [] });
	        } else {
	          // If user clicked an empty Display slot, create a dedicated overview page (title-less, fixed slot).
	          if (creatingDisplay) {
	            const already = container.find(n => n && n.type === 'page' && n.is_overview);
	            if (!already) container.unshift({ id, type: 'page', title: '', is_overview: true, file: null, file_prev: null, segment: null, children: [] });
	          } else {
	            container.push({ id, type: 'page', title: title.trim(), file: null, file_prev: null, segment: null, children: [] });
	          }
	        }
	      });
	      renderTree();
	      updateHistoryButtons();

	      // Create on disk immediately.
	      if (type === 'folder') {
	        try {
	          const data = await fetchJson('/api/create_section', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ title: title.trim(), parent_dir: parentDir })
          });
	          const found = findNode(stateTree, newId);
	          if (found && found.node && found.node.type === 'folder') {
	            found.node.segment = data.segment || found.node.segment || '';
	          }
	          // Create default section README (overview) as the first page under this folder.
	          const newFolderDir = folderDirForId(newId);
	          const pageId = crypto && crypto.randomUUID ? crypto.randomUUID().replace(/-/g, '') : String(Date.now() + 1);
	          withHistory('create.section_overview', () => {
	            const info = findNode(stateTree, newId);
	            if (!info || !info.node || info.node.type !== 'folder') return;
	            info.node.children = Array.isArray(info.node.children) ? info.node.children : [];
	            info.node.children.unshift({ id: pageId, type: 'page', title: '', is_overview: true, file: null, file_prev: null, segment: null, children: [] });
	          });
	          renderTree();
	          updateHistoryButtons();
	          try {
	            const pageData = await fetchJson('/api/create_page', {
	              method: 'POST',
	              headers: { 'Content-Type': 'application/json' },
	              body: JSON.stringify({ title: 'Overview', parent_dir: newFolderDir, basename: 'README.md' })
	            });
	            const pageFound = findNode(stateTree, pageId);
	            if (pageFound && pageFound.node && pageFound.node.type === 'page') {
	              pageFound.node.file = pageData.file || pageFound.node.file;
	              pageFound.node.file_prev = null;
	            }
	          } catch (e) {
	            pushDebug('create.section_overview.failed', { error: e.message || String(e) });
	          }
	          renderTree();
	          await loadSource();
	          setStatus('Section created on disk.', 'success');
	          scheduleNavOnly('create.section');
	        } catch (e) {
          setStatus(e.message || 'Create section failed.', 'error');
        }
        return;
      }

	      try {
	        const data = await fetchJson('/api/create_page', {
	          method: 'POST',
	          headers: { 'Content-Type': 'application/json' },
	          body: JSON.stringify(creatingDisplay
	            ? { title: 'Overview', parent_dir: parentDir, basename: 'README.md' }
	            : { title: title.trim(), parent_dir: parentDir })
	        });
	        const found = findNode(stateTree, newId);
	        if (found && found.node && found.node.type === 'page') {
	          found.node.file = data.file || found.node.file;
	          found.node.file_prev = null;
	          if (creatingDisplay) found.node.is_overview = true;
	        }
	        renderTree();
	        await loadSource();
	        setStatus(creatingDisplay ? 'Display page created.' : 'Page created on disk.', 'success');
	        scheduleNavOnly(creatingDisplay ? 'create.display' : 'create.page');
	      } catch (e) {
	        setStatus(e.message || '‚õîÔ∏è Create page failed.', 'error');
	      }
	    }

	    async function createPageWithFolder() {
	      if (activeInlineEdit) return;
	      const title = await showPrompt('Page title (folder + file will use the same name):', {
	        title: 'New Page + Folder',
	        okText: 'Create',
	        cancelText: 'Cancel'
	      });
	      if (!title || !title.trim()) {
	        setStatus('‚ö†Ô∏è Title is required. Creation cancelled.', 'info');
	        return;
	      }
	      const cleanTitle = title.trim();

	      const parentDir = (() => {
	        if (selectedDisplaySlotFolderId) return folderDirForId(selectedDisplaySlotFolderId);
	        if (!selectedId) return '';
	        const info = findNode(stateTree, selectedId);
	        if (!info) return '';
	        if (info.node.type === 'folder') return folderDirForId(info.node.id);
	        if (info.parent && info.parent.type === 'folder') return folderDirForId(info.parent.id);
	        return '';
	      })();
	      {
	        const id = selectedId || selectedDisplaySlotFolderId;
	        const info = id ? findNode(stateTree, id) : null;
	        const meta = info && info.node ? {
	          id,
	          type: info.node.type,
	          title: info.node.title,
	          segment: info.node.segment,
	          file: info.node.file
	        } : { id };
	        console.warn('[createPageWithFolder] parent_dir', { parentDir, meta, selectedId, selectedDisplaySlotFolderId });
	        if (!parentDir) {
	          setStatus('‚ö†Ô∏è parent_dir is empty; creation will go to root. Check selection/segment.', 'info');
	        }
	      }

	      let pageId = '';
	      withHistory('create.page_with_folder', () => {
	        const parentInfo = selectedDisplaySlotFolderId
	          ? findNode(stateTree, selectedDisplaySlotFolderId)
	          : (selectedId ? findNode(stateTree, selectedId) : null);
	        let container = stateTree;
	        if (parentInfo) {
	          if (parentInfo.node.type === 'folder') {
	            parentInfo.node.children = Array.isArray(parentInfo.node.children) ? parentInfo.node.children : [];
	            container = parentInfo.node.children;
	          } else if (parentInfo.parent && parentInfo.parent.type === 'folder') {
	            parentInfo.parent.children = Array.isArray(parentInfo.parent.children) ? parentInfo.parent.children : [];
	            container = parentInfo.parent.children;
	          }
	        }

	        pageId = crypto && crypto.randomUUID ? crypto.randomUUID().replace(/-/g, '') : String(Date.now() + 1);
	        container.push({ id: pageId, type: 'page', title: cleanTitle, file: null, file_prev: null, segment: null, children: [] });
	      });

	      renderTree();
	      updateHistoryButtons();
	      setStatus('Creating folder + page...', 'info');

	      try {
	        const page = await fetchJson('/api/create_page_with_folder', {
	          method: 'POST',
	          headers: { 'Content-Type': 'application/json' },
	          body: JSON.stringify({ title: cleanTitle, parent_dir: parentDir })
	        });
	        const pageFound = findNode(stateTree, pageId);
	        if (pageFound && pageFound.node && pageFound.node.type === 'page') {
	          pageFound.node.file = page.file || pageFound.node.file;
	          pageFound.node.file_prev = null;
	        }
	        renderTree();
	        await loadSource();
	        setStatus('‚úÖ Page + folder created on disk.', 'success');
	        scheduleNavOnly('create.page_with_folder');
	      } catch (e) {
	        setStatus(e.message || '‚õîÔ∏è Create page + folder failed.', 'error');
	      }
	    }

    function renameSelected() {
      if (!selectedId) return setStatus('‚ö†Ô∏è Select a node first.', 'info');
      const rowTitle = document.querySelector(`#tree li[data-id="${selectedId}"] .node-title`);
      if (!rowTitle) return setStatus('‚ö†Ô∏è Selected node not visible (expand parent folders).', 'info');
      beginInlineEdit(selectedId, 'title', rowTitle);
    }

    function beginInlineEdit(id, field, hostEl) {
      if (!id || !hostEl) return;
      const info = findNode(stateTree, id);
      if (!info) return setStatus('‚ö†Ô∏è Node not found.', 'error');

      if (activeInlineEdit && activeInlineEdit.id === id && activeInlineEdit.field === field) return;
      if (activeInlineEdit) cancelInlineEdit();

      const li = hostEl.closest('li.node');
      if (!li) return;

      const originalValue =
        field === 'file' ? (info.node.file || '') :
          field === 'segment' ? (info.node.segment || '') :
            (info.node.title || '');
      const originalDir = (() => {
        if (field !== 'file') return '';
        const p = String(originalValue || '').replace(/^\.\//, '');
        const idx = p.lastIndexOf('/');
        return idx >= 0 ? p.slice(0, idx + 1) : '';
      })();
      const startValue =
        field === 'file' ? (() => {
          const p = String(originalValue || '').replace(/^\.\//, '');
          const idx = p.lastIndexOf('/');
          return idx >= 0 ? p.slice(idx + 1) : p;
        })() :
          field === 'segment' ? originalValue :
            displayTitleForNode(info.node);

      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'inline-edit';
      input.value = startValue;
      input.spellcheck = false;
      input.draggable = false;

      const prevText = hostEl.textContent || '';
      hostEl.textContent = '';
      hostEl.appendChild(input);

      const prevDraggable = li.draggable;
      li.draggable = false;
      li.classList.add('is-editing');

      activeInlineEdit = { id, field, hostEl, input, prevText, prevDraggable, originalValue, originalDir };

      const finish = (mode) => {
        if (!activeInlineEdit) return;
        const current = activeInlineEdit;
        if (current.input) current.input.removeEventListener('keydown', onKeyDown);
        if (current.input) current.input.removeEventListener('blur', onBlur);
        li.draggable = current.prevDraggable;
        li.classList.remove('is-editing');
        const value = (current.input && current.input.value ? current.input.value : '').trim();
        activeInlineEdit = null;

        if (mode === 'cancel') {
          current.hostEl.textContent = current.prevText;
          return;
        }

        if (current.field === 'title') {
          if (!value) {
            current.hostEl.textContent = current.prevText;
            return;
          }
          withHistory('edit.title', () => {
            const nodeInfo = findNode(stateTree, current.id);
            if (nodeInfo) nodeInfo.node.title = value;
          });
          renderTree();
          updateHistoryButtons();
          setStatus('Renamed.', 'success');
          scheduleNavOnly('rename.title');
          return;
        }

        if (current.field === 'segment') {
          if (value.includes('/') || value.includes('\\')) {
            setStatus('Folder name cannot contain slashes.', 'error');
            current.hostEl.textContent = current.prevText;
            return;
          }
          const oldDir = folderDirForId(current.id);
          const newSeg = value.trim();
          (async () => {
            setStatus('Renaming folder...', 'info');
            try {
              const data = await fetchJson('/api/rename_dir', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ dir: oldDir, new_segment: newSeg })
              });
              const newDir = data.dir || oldDir;
              withHistory('edit.segment', () => {
                const nodeInfo = findNode(stateTree, current.id);
                if (!nodeInfo) return;
                nodeInfo.node.segment = data.segment || newSeg;
                updateDescendantPagePaths(current.id, oldDir, newDir);
              });
              renderTree();
              updateHistoryButtons();
              await loadSource();
              setStatus('Folder renamed on disk.', 'success');
              scheduleNavOnly('rename.segment');
            } catch (e) {
              setStatus(e.message || 'Rename folder failed.', 'error');
              renderTree();
            }
          })();
          return;
        }

        if (current.field === 'file') {
          if (value.includes('/') || value.includes('\\')) {
            setStatus('Filename only (no directories).', 'error');
            current.hostEl.textContent = current.prevText;
            return;
          }
          const oldFile = String(current.originalValue || '').replace(/^\.\//, '').trim();
          const newBase = value.trim();
          if (!oldFile) {
            setStatus('Cannot rename: missing old file path.', 'error');
            return;
          }
          (async () => {
            setStatus('Renaming file...', 'info');
            try {
              const data = await fetchJson('/api/rename_file', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ old_file: oldFile, new_basename: newBase })
              });
              withHistory('edit.file', () => {
                const nodeInfo = findNode(stateTree, current.id);
                if (!nodeInfo) return;
                nodeInfo.node.file = data.file || nodeInfo.node.file;
                nodeInfo.node.file_prev = null;
              });
              renderTree();
              updateHistoryButtons();
              await loadSource();
              setStatus('File renamed on disk.', 'success');
              scheduleNavOnly('rename.file');
            } catch (e) {
              setStatus(e.message || 'Rename file failed.', 'error');
              renderTree();
            }
          })();
          return;
        }
      };

      const onKeyDown = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          finish('commit');
        } else if (e.key === 'Escape') {
          e.preventDefault();
          finish('cancel');
        }
      };
      const onBlur = () => finish('commit');

      input.addEventListener('keydown', onKeyDown);
      input.addEventListener('blur', onBlur);

      requestAnimationFrame(() => {
        input.focus();
        input.select();
      });
    }

    function cancelInlineEdit() {
      if (!activeInlineEdit) return;
      const current = activeInlineEdit;
      const li = current.hostEl.closest('li.node');
      if (current.input) current.input.remove();
      if (li) {
        li.draggable = current.prevDraggable;
        li.classList.remove('is-editing');
      }
      current.hostEl.textContent = current.prevText;
      activeInlineEdit = null;
    }

    function updateDescendantPagePaths(folderId, oldDir, newDir) {
      const info = findNode(stateTree, folderId);
      if (!info || !info.node || info.node.type !== 'folder') return;
      const oldPrefix = oldDir ? `${oldDir.replace(/\\/g, '/')}/` : '';
      const newPrefix = newDir ? `${newDir.replace(/\\/g, '/')}/` : '';
      const walk = (node) => {
        if (!node) return;
        if (node.type === 'page') {
          if (node.file && oldPrefix && node.file.startsWith(oldPrefix)) {
            node.file = newPrefix + node.file.slice(oldPrefix.length);
          }
          if (node.file_prev && oldPrefix && node.file_prev.startsWith(oldPrefix)) {
            node.file_prev = newPrefix + node.file_prev.slice(oldPrefix.length);
          }
          return;
        }
        for (const c of (node.children || [])) walk(c);
      };
      for (const c of (info.node.children || [])) walk(c);
    }

    async function deleteSelected() {
      if ((!selectedId || !findNode(stateTree, selectedId)) && (!selectedIds || !selectedIds.size)) {
        return setStatus('‚ö†Ô∏è Select a node first.', 'info');
      }
      const ids = selectedIds && selectedIds.size ? Array.from(selectedIds) : [selectedId];
      const folderCheck = classifyFoldersForDelete(ids);
      if (folderCheck.blocking.length) {
        const first = folderCheck.blocking[0];
        return setStatus(`‚ö†Ô∏è Cannot delete non-empty folder "${first.title}". Move its pages first.`, 'info');
      }

      const filesToDelete = collectFilesForIds(ids);
      const dirsToDelete = folderCheck.emptyDirs;
      const hasFiles = filesToDelete.length > 0;
      const hasDirs = dirsToDelete.length > 0;
      const navOnly = dragMode === 'nav_only';
      const overviewFiles = (() => {
        const out = new Set();
        for (const id of ids) {
          const found = findNode(stateTree, id);
          if (!found || !found.node || found.node.type !== 'folder') continue;
          const children = Array.isArray(found.node.children) ? found.node.children : [];
          const overview = children.find(c => c && c.type === 'page' && c.is_overview && c.file);
          if (overview && overview.file) out.add(String(overview.file).replace(/^\.\//, '').trim());
        }
        return out;
      })();
      const nonOverviewFiles = filesToDelete.filter(f => !overviewFiles.has(f));
      const emptyOnly = hasDirs && nonOverviewFiles.length === 0;
      const skipEmptyDeleteConfirm = skipEmptyDeleteConfirmSession;

      const summary = [
        `Delete ${ids.length} item(s) from the tree`,
        hasFiles ? `delete ${filesToDelete.length} page file(s) on disk` : null,
        hasDirs ? `delete ${dirsToDelete.length} empty folder(s) on disk` : null,
      ].filter(Boolean).join(', ') + '. Continue?';
      if (emptyOnly && !navOnly) {
        if (!skipEmptyDeleteConfirm) {
          const res = await showChoice({
            title: 'Delete',
            message: summary,
            cancelValue: false,
            input: {
              type: 'checkbox',
              value: false,
            label: 'Do not ask again for empty-folder deletes (this session)'
            },
            buttons: [
              { label: 'Delete', value: true, primary: true },
              { label: 'Cancel', value: false, ghost: true }
            ]
          });
          if (!res || !res.value) return;
          if (res.input) skipEmptyDeleteConfirmSession = true;
        } else {
          setStatus('‚ÑπÔ∏è Empty-folder delete (sync files), confirmation skipped.', 'info');
        }
      } else {
        const ok = await showConfirm(summary, {
          title: 'Delete',
          okText: 'Delete',
          cancelText: 'Cancel'
        });
        if (!ok) return;
      }
      let removed = null;
      withHistory('delete', () => {
        const ctxs = detachManyWithContext(ids);
        removed = ctxs.length ? { count: ctxs.length } : null;
      });
      clearSelection();
      renderTree();
      updateHistoryButtons();
      setStatus(removed ? `Deleted ${removed.count || 1}.` : 'Not found.', removed ? 'success' : 'info');
      scheduleNavOnly('delete.tree');

      if (!navOnly) {
        let fileResult = { deleted: [], errors: [] };
        if (hasFiles) fileResult = await deleteFilesOnDisk(filesToDelete, { deleteAssets: true });
        if (hasDirs) {
          if (fileResult.errors && fileResult.errors.length) {
            setStatus('‚ö†Ô∏è Skipped deleting folders because some files failed to delete.', 'info');
          } else {
            await deleteDirsOnDisk(dirsToDelete);
          }
        }
        if (hasFiles || hasDirs) scheduleNavOnly('delete.disk');
      } else if (hasFiles || hasDirs) {
        setStatus('‚ö†Ô∏è Nav-only mode: disk folders/files unchanged. Clean manually if needed.', 'info');
      }
    }

	    function classifyFoldersForDelete(ids) {
	      const blocking = [];
	      const emptyDirs = [];
	      const seenDirs = new Set();

	      function hasNonOverviewPage(folder) {
	        if (!folder || folder.type !== 'folder') return false;
	        const children = Array.isArray(folder.children) ? folder.children : [];
	        const overview = children.find(c => c && c.type === 'page' && c.is_overview) || null;
	        for (const c of children) {
	          if (!c) continue;
	          if (c.type === 'page') {
	            if (overview && c === overview) continue;
	            return true;
	          }
	          if (c.type === 'folder') {
	            if (hasNonOverviewPage(c)) return true;
	          }
	        }
	        return false;
	      }

	      for (const id of (ids || [])) {
	        const found = findNode(stateTree, id);
	        if (!found || !found.node) continue;
	        if (found.node.type !== 'folder') continue;
	        if (hasNonOverviewPage(found.node)) {
	          blocking.push({ id, title: found.node.title || id });
	          continue;
	        }
	        const dir = folderDirForId(id);
        if (dir && !seenDirs.has(dir)) {
          seenDirs.add(dir);
          emptyDirs.push(dir);
        }
      }
      return { blocking, emptyDirs };
    }

    function folderDirForId(id) {
      if (!id) return '';
      const info = findNode(stateTree, id);
      if (!info || !info.node || info.node.type !== 'folder') return '';
      const segs = [];
      const selfSeg = (info.node.segment || '').trim();
      if (selfSeg) segs.push(selfSeg);
      let p = info.parent;
      while (p) {
        if (p.type === 'folder' && p.segment) segs.push(String(p.segment).trim());
        const parentInfo = findNode(stateTree, p.id);
        p = parentInfo ? parentInfo.parent : null;
      }
      return segs.reverse().filter(Boolean).join('/');
    }

    function collectFilesForIds(ids) {
      const out = [];
      const seen = new Set();
      function walk(node) {
        if (!node) return;
        if (node.type === 'page') {
          if (node.file) {
            const rel = String(node.file).replace(/^\.\//, '').trim();
            if (rel && !seen.has(rel)) {
              seen.add(rel);
              out.push(rel);
            }
          }
          return;
        }
        for (const c of (node.children || [])) walk(c);
      }
      for (const id of (ids || [])) {
        const found = findNode(stateTree, id);
        if (!found) continue;
        walk(found.node);
      }
      return out;
    }

    async function deleteFilesOnDisk(files, options) {
      const opts = options || {};
      const deleteAssets = !!opts.deleteAssets;
      setStatus('üóëÔ∏è Deleting files...', 'info');
      try {
        const data = await fetchJson('/api/delete_files', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ files, delete_assets: deleteAssets })
        });
        const deleted = Array.isArray(data.deleted) ? data.deleted : [];
        const errors = Array.isArray(data.errors) ? data.errors : [];
        const list = deleted.map(item => item && item.path ? item.path : '').filter(Boolean);
        const head = list[0] ? ` ${list[0]}` : '';
        const more = list.length > 1 ? ` +${list.length - 1}` : '';
        const msg = `‚úÖ Deleted ${deleted.length} item(s) from disk.${head}${more}${errors.length ? ` errors:${errors.length}` : ''}`;
        setStatus(msg, errors.length ? 'error' : 'success');
        await loadSource();
        return { deleted, errors };
      } catch (e) {
        setStatus(e.message || '‚õîÔ∏è Delete files failed.', 'error');
        return { deleted: [], errors: [{ error: e.message || 'Delete files failed.' }] };
      }
    }

    async function deleteDirsOnDisk(dirs) {
      if (!Array.isArray(dirs) || !dirs.length) return;
      setStatus('üóëÔ∏è Deleting empty folders...', 'info');
      try {
        const data = await fetchJson('/api/delete_dirs', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ dirs })
        });
        const deleted = Array.isArray(data.deleted) ? data.deleted : [];
        const errors = Array.isArray(data.errors) ? data.errors : [];
        const list = deleted.map(item => item && item.path ? item.path : '').filter(Boolean);
        const head = list[0] ? ` ${list[0]}` : '';
        const more = list.length > 1 ? ` +${list.length - 1}` : '';
        const msg = `‚úÖ Deleted ${deleted.length} empty folder(s).${head}${more}${errors.length ? ` errors:${errors.length}` : ''}`;
        setStatus(msg, errors.length ? 'error' : 'success');
        await loadSource();
      } catch (e) {
        setStatus(e.message || '‚õîÔ∏è Delete folders failed.', 'error');
      }
    }
  </script>
</body>

</html>
