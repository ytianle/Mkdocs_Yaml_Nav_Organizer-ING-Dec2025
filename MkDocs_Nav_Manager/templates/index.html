<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>MkDocs Nav Manager</title>
  <link rel="stylesheet" href="/static/style.css">
</head>

<body>
  <div class="shell">
    <header class="toolbar">
      <div class="title">
        <div class="title-row">
          <h1>MkDocs Nav Manager</h1>
        </div>
        <div class="title-subline">
          <div id="meta" class="muted">Loading...</div>
          <div id="mkdocs-status" class="mkdocs-status" data-state="stopped">MkDocs: stopped</div>
        </div>
      </div>
      <div class="inline-actions">
        <div class="mkdocs-actions" aria-label="MkDocs controls">
          <button id="mkdocs-start-btn" type="button" class="ghost mkdocs-control" data-help="Start mkdocs serve (livereload)">
            <svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
              <path d="M6 4l6 4-6 4V4z"/>
            </svg>
          </button>
          <button id="mkdocs-stop-btn" type="button" class="ghost mkdocs-control" data-help="Stop mkdocs serve">
            <svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.6">
              <rect x="4" y="4" width="8" height="8" rx="1"/>
            </svg>
          </button>
          <button id="mkdocs-open-btn" type="button" class="ghost mkdocs-control" data-help="Open MkDocs site in browser">
            <svg width="14" height="14" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
              <path d="M6 10l4-4"/>
              <path d="M7.5 5H11v3.5"/>
              <rect x="3.2" y="3.2" width="9.6" height="9.6" rx="2"/>
            </svg>
          </button>
        </div>
        <span class="action-divider" aria-hidden="true">|</span>
        <button id="toggle-tools" type="button" class="ghost" data-help="Toggle Tools panel">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
            <path d="M3 4h10M3 8h10M3 12h10"/>
            <circle cx="6" cy="4" r="1.2"/>
            <circle cx="10" cy="8" r="1.2"/>
            <circle cx="5" cy="12" r="1.2"/>
          </svg>
        </button>
        <button id="toggle-source" type="button" class="ghost" data-help="Toggle Source panel">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
            <rect x="2" y="3" width="12" height="10" rx="1"/>
            <path d="M2 6h12M6 3v10"/>
          </svg>
        </button>
        <button id="toggle-tree" type="button" class="ghost" data-help="Toggle Doc Tree panel">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M2 3h12M2 8h12M2 13h12"/>
          </svg>
        </button>
        <button id="toggle-info" type="button" class="ghost" data-help="Toggle Info panel">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
            <circle cx="8" cy="8" r="6"/>
            <path d="M8 7v4M8 5v.5"/>
          </svg>
        </button>
        <button id="tool-debug" type="button" class="ghost icon-button" data-help="Toggle debug window (DnD logs)"
          aria-label="Toggle debug">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
            <path d="M6 4.5h4"/>
            <path d="M5 6.5h6"/>
            <path d="M5 9.5h6"/>
            <path d="M6.5 12h3"/>
            <path d="M4 7.5H2.5M11.9 7.5h1.6"/>
            <path d="M4.4 11.6 3.3 12.7M11.6 11.6 12.7 12.7"/>
            <path d="M5 6l-1.2-1M11 6l1.2-1"/>
            <rect x="4" y="5" width="8" height="7" rx="3"/>
          </svg>
        </button>
        <span class="action-divider" aria-hidden="true">|</span>
        <button id="toggle-icons-panel" type="button" class="ghost icon-button" data-help="Icons & emoji search"
          aria-label="Toggle icons search">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round">
            <circle cx="7" cy="7" r="4.2"/>
            <path d="M10.5 10.5L13.2 13.2"/>
            <path d="M5.6 6.4c.5-.5 1.4-.5 1.9 0"/>
            <path d="M6.2 8.6c.6.7 1.9.7 2.6 0"/>
          </svg>
        </button>
        <button id="toggle-simple-editor" type="button" class="ghost" data-help="simple md file editor">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M11.5 2.5l2 2-7 7-2.5.5.5-2.5 7-7z"/>
            <path d="M10 4l2 2"/>
          </svg>
        </button>
        <span class="action-divider" aria-hidden="true">|</span>
        <button id="toggle-theme" type="button" class="ghost" data-help="Toggle theme (Day/Night)">
          <svg class="icon-moon" width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M10.8 2.7a5.9 5.9 0 1 0 2.5 9.8A4.7 4.7 0 1 1 10.8 2.7z"/>
          </svg>
          <svg class="icon-sun" width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
            <circle cx="8" cy="8" r="3.2"/>
            <path d="M8 1.5v2M8 12.5v2M1.5 8h2M12.5 8h2M3 3l1.4 1.4M11.6 11.6 13 13M3 13l1.4-1.4M11.6 4.4 13 3"/>
          </svg>
        </button>
      </div>
    </header>

    <div id="tool-tooltip" class="tool-tooltip" hidden></div>
    <div id="tree-context" class="context-menu" hidden>
      <button type="button" data-action="new-folder" data-shortcut="Opt(Alt)+Shift+N">üóÇÔ∏è New Section <span class="context-shortcut">Opt(Alt)+Shift+N</span></button>
      <button type="button" data-action="new-page" data-shortcut="Opt(Alt)+N">üìÑ New Page <span class="context-shortcut">Opt(Alt)+N</span></button>
      <button type="button" data-action="new-page-with-folder" data-shortcut="Opt(Alt)+Shift+P">üìÅ Page w/ Folder <span class="context-shortcut">Opt(Alt)+Shift+P</span></button>
      <button type="button" data-action="rename" data-shortcut="F2">‚úèÔ∏è Rename <span class="context-shortcut">F2</span></button>
      <button type="button" data-action="locate" data-shortcut="Opt(Alt)+L">üß≠ Locate <span class="context-shortcut">Opt(Alt)+L</span></button>
      <button type="button" data-action="open" data-shortcut="Opt(Alt)+O">üìÇ Open <span class="context-shortcut">Opt(Alt)+O</span></button>
      <button type="button" data-action="open-web" data-shortcut="Opt(Alt)+R">üåê Rendered <span class="context-shortcut">Opt(Alt)+R</span></button>
      <button type="button" data-action="edit" data-shortcut="Opt(Alt)+E">üìù Edit <span class="context-shortcut">Opt(Alt)+E</span></button>
      <button type="button" data-action="delete" class="danger" data-shortcut="Del/Backspace">üóëÔ∏è Delete <span class="context-shortcut">Del/Backspace</span></button>
    </div>

    <section class="dock-tools tools-toolbar" id="panel-tools">
      <div class="tools-bar" role="toolbar" aria-label="Tools">
        <button id="tool-undo" type="button" class="ghost icon-button" data-help="Undo last change"
          aria-label="Undo">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
            <path d="M5 8h6a3 3 0 0 1 0 6H8" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M7 6l-2 2 2 2" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
        <button id="tool-redo" type="button" class="ghost icon-button" data-help="Redo last undone change"
          aria-label="Redo">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
            <path d="M11 8H5a3 3 0 0 0 0 6h3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M9 6l2 2-2 2" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
          </svg>
        </button>
        <button id="tool-import" type="button" class="ghost icon-button"
          data-help="Rebuild Doc Tree from mkdocs.yml nav (overwrites current draft)" aria-label="Load mkdocs.yml">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
            <path d="M8 2v8m0 0l3-3m-3 3L5 7" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M3 11v2a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1v-2" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
          </svg>
        </button>
        <button id="tool-beautify-nav" type="button" class="ghost icon-button"
          data-help="Beautify mkdocs.yml nav formatting (nav block only; no file moves)" aria-label="Beautify nav">
          <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
            <circle cx="8" cy="5" r="2" stroke="currentColor" stroke-width="1.5"/>
            <path d="M4 10c0-2 1.5-3 4-3s4 1 4 3" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
            <path d="M3 13l1.5-1.5M13 13l-1.5-1.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
          </svg>
        </button>
      </div>
    </section>

    <div id="workspace" class="workspace">
      <div class="main-grid">
        <section class="card panel" id="panel-source">
          <div class="card-head">
            <h2>Source</h2>
            <div class="inline-actions">
              <button id="source-view-btn" type="button" class="ghost"
                data-help="Toggle source view (Explorer / ASCII)">
                <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5">
                  <path d="M2 4h12M2 8h12M2 12h8"/>
                </svg>
                ASCII
              </button>
            </div>
          </div>
          <div id="source" class="list-shell">Loading...</div>
        </section>

        <div class="splitter splitter-v" id="split-main-left" title="Drag to resize"></div>

	        <section class="card panel" id="panel-tree">
            <div class="card-head">
              <h2>üìö Doc Tree</h2>
              <div class="inline-actions tree-actions">
                <div class="tree-actions-row">
	                <label class="switch" title="" data-help="" id="drag-mode-switch">
	                  <input id="drag-mode-toggle" type="checkbox" aria-label="Drag mode toggle">
	                  <span class="switch-track"></span>
	                  <span class="switch-text" id="drag-mode-text">Drag: Files</span>
	                </label>
	                <button id="rainbow-toggle-btn" type="button" class="ghost" data-help="Toggle rainbow level colors">
	                  <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
	                    <path d="M2 10a6 6 0 0 1 12 0" stroke="#FF6B6B" stroke-width="1.5" stroke-linecap="round"/>
	                    <path d="M3.5 10a4.5 4.5 0 0 1 9 0" stroke="#FFB84D" stroke-width="1.5" stroke-linecap="round"/>
	                    <path d="M5 10a3 3 0 0 1 6 0" stroke="#50DC8C" stroke-width="1.5" stroke-linecap="round"/>
	                    <path d="M6.5 10a1.5 1.5 0 0 1 3 0" stroke="#6AA9FF" stroke-width="1.5" stroke-linecap="round"/>
	                  </svg>
	                </button>
                <div class="segmented" role="group" aria-label="Depth actions">
	                  <button type="button" class="ghost depth-btn" data-depth="1" data-help="Collapse to 1 level">1</button>
	                  <button type="button" class="ghost depth-btn" data-depth="2" data-help="Collapse to 2 levels">2</button>
	                  <button type="button" class="ghost depth-btn" data-depth="3" data-help="Collapse to 3 levels">3</button>
                  <button type="button" class="ghost depth-btn" data-depth="4" data-help="Collapse to 4 levels">4</button>
                  <button type="button" class="ghost depth-btn" data-depth="5" data-help="Collapse to 5 levels">5</button>
                  <button type="button" class="ghost depth-btn" data-depth="n" data-help="Expand all / collapse to last depth">‚àû</button>
                </div>
                <div class="tree-search" role="search">
                  <input id="tree-search-input" type="text" autocomplete="off" placeholder="Search tree..." aria-label="Search doc tree">
                  <span id="tree-search-count" class="tree-search-count" aria-live="polite"></span>
                  <button id="tree-search-prev" type="button" class="ghost" data-help="Previous match (Shift+Enter)" aria-label="Previous match">Prev</button>
                  <button id="tree-search-next" type="button" class="ghost" data-help="Next match (Enter)" aria-label="Next match">Next</button>
                  <button id="tree-search-clear" type="button" class="ghost" data-help="Clear search" aria-label="Clear search">X</button>
                </div>
                </div>
                <div class="tree-actions-row">
                  <button id="new-folder-btn" type="button" data-help="Create a new section under selection" data-shortcut="Opt(Alt)+Shift+N">
                    üóÇÔ∏è New Section
                  </button>
                  <button id="new-page-btn" type="button" data-help="Create a new page under selection" data-shortcut="Opt(Alt)+N">
                    üìÑ New Page
                  </button>
                  <button id="new-page-with-folder-btn" type="button"
                    data-help="Create a page (nav only) and store it inside a same-named folder on disk" data-shortcut="Opt(Alt)+Shift+P">
                    üìÅ Page w/ Folder
                  </button>
                  <button id="normalize-names-btn" type="button" class="ghost"
                    data-help="Normalize file/folder names to lower_snake; keep subfolders, skip HOME/JOURNAL, allow CJK">
                    üî§ Normalize Files
                  </button>
                  <button id="delete-btn" type="button" data-help="Delete selected node (tree only)" data-shortcut="Del/Backspace">
                    üóëÔ∏è Delete
                  </button>
                  <button id="tree-locate-btn" type="button" class="ghost" data-help="Locate selection in Source" data-shortcut="Opt(Alt)+L">
                    üß≠ Locate
                  </button>
                  <button id="open-file-btn" type="button" class="ghost" data-help="Open selected page in editor or default viewer" data-shortcut="Opt(Alt)+O">
                    üìÇ Open
                  </button>
                  <button id="open-doc-web-btn" type="button" class="ghost" data-help="Open selected page in rendered MkDocs site (make sure run MkDocs server first)" data-shortcut="Opt(Alt)+R">
                    üåê Rendered Page
                  </button>
                  <button id="simple-edit-btn" type="button" class="ghost" data-help="Open selected page in Simple Edit" data-shortcut="Opt(Alt)+E">
                    üìù Edit
                  </button>
                </div>
              </div>
          </div>
          <div id="tree" class="list-shell">Loading...</div>
        </section>
      </div>

      <div class="splitter splitter-h" id="split-bottom" title="Drag to resize"></div>

      <div class="bottom-stack debug-hidden" id="bottom-stack">
        <section class="card panel" id="panel-info">
          <div class="card-head">
            <h2>‚ÑπÔ∏è Info</h2>
            <div class="inline-actions">
            </div>
          </div>
          <div class="list-shell info-body">
            <div class="info-grid">
              <div class="info-col info-left">
                <div class="info-top">
                  <div id="status" class="status-box" data-type="info"></div>
                  <div class="info-pills">
                    <div id="info-meta-pill" class="info-pill" title=""></div>
                    <div id="info-selection-pill" class="info-pill" title=""></div>
                    <div id="info-search-pill" class="info-pill" title=""></div>
                  </div>
                </div>
              </div>
              <div class="info-col info-right">
                <details id="mkdocs-monitor" class="info-details info-section">
                  <summary class="info-summary">MkDocs Monitor</summary>
                  <pre id="mkdocs-log" class="mkdocs-log"></pre>
                </details>
                <details id="info-details" class="info-details info-section">
                  <summary class="info-summary">More</summary>
                  <div id="info-meta" class="info-line"></div>
                  <div id="info-selection" class="info-line"></div>
                  <div id="info-search" class="info-line"></div>
                  <div id="info-errors" class="info-errors" hidden></div>
                </details>
              </div>
            </div>
            <div id="info-hover" class="info-hint" hidden></div>
          </div>
        </section>

        <div class="splitter splitter-h" id="split-info-debug" title="Drag to resize debug height"></div>

        <section id="debug-panel" class="card panel debug-panel" hidden>
          <div class="debug-head">
            <div class="debug-title">DnD Debug</div>
            <div class="debug-actions">
              <button id="debug-clear" type="button" class="ghost">Clear</button>
              <button id="debug-copy" type="button" class="ghost">Copy</button>
            </div>
          </div>
          <pre id="debug-log" class="debug-log"></pre>
        </section>
      </div>

      <section class="card panel simple-editor" id="simple-editor" hidden>
        <div class="card-head">
          <h2>‚úèÔ∏è Simple Edit</h2>
          <div class="inline-actions">
            <span id="simple-edit-file" class="muted"></span>
            <span id="simple-edit-diff" class="muted"></span>
            <button id="simple-edit-abort" type="button" class="ghost" data-help="Abort edit (discard changes)">‚ü≤ Abort</button>
            <button id="simple-edit-save" type="button" class="ghost" data-help="Save file" data-shortcut="Ctrl/Cmd+S">
              <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                <rect x="2" y="2" width="12" height="12" rx="1.5" fill="#6AA9FF" stroke="#4A89DF" stroke-width="1.2"/>
                <rect x="4" y="4" width="8" height="6" fill="white"/>
                <rect x="5" y="11" width="6" height="3" fill="#4A89DF"/>
              </svg>
              Save
            </button>
            <button id="simple-edit-close" type="button" class="ghost" data-help="Close">‚úï</button>
          </div>
        </div>
        <div class="simple-edit-body">
          <pre id="simple-edit-lines" class="simple-edit-lines"></pre>
          <pre id="simple-edit-highlight" class="simple-edit-highlight"></pre>
          <textarea id="simple-edit-input" class="simple-edit-input" spellcheck="false"></textarea>
        </div>
      </section>

      <section class="card panel icons-panel" id="icons-panel" hidden>
        <div class="card-head">
          <h2>Icons & Emojis</h2>
          <div class="inline-actions">
            <span id="icons-status" class="muted"></span>
            <button id="icons-reload" type="button" class="ghost" data-help="Reload icon data" aria-label="Reload">
              <svg width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
                <path d="M3 8a5 5 0 1 0 2-4"/>
                <path d="M3 3v3h3"/>
              </svg>
            </button>
            <button id="icons-close" type="button" class="ghost" data-help="Close" aria-label="Close">‚úï</button>
          </div>
        </div>
        <div class="icons-body">
          <div class="icons-search-row">
            <input id="icons-search-input" class="icons-search-input" type="text" autocomplete="off"
              placeholder="Search icons or emojis... (e.g. home, smile, fontawesome)" aria-label="Search icons or emojis">
            <span id="icons-match-count" class="icons-match-count" aria-live="polite"></span>
            <div class="segmented icons-filters" role="group" aria-label="Icon filters">
              <button id="icons-filter-all" type="button" class="ghost active" data-filter="all">All</button>
              <button id="icons-filter-icons" type="button" class="ghost" data-filter="icon">Icons</button>
              <button id="icons-filter-emojis" type="button" class="ghost" data-filter="emoji">Emojis</button>
            </div>
          </div>
          <div id="icons-hint" class="icons-hint">Type to search. Click a result to copy its MkDocs shortcode.</div>
          <div id="icons-results" class="icons-results" aria-live="polite"></div>
        </div>
      </section>

      <div class="modal" id="modal" hidden>
        <div class="modal-backdrop"></div>
        <div class="modal-card" role="dialog" aria-modal="true">
          <div class="modal-title" id="modal-title"></div>
          <div class="modal-message" id="modal-message"></div>
          <div class="modal-input-wrap" id="modal-input-wrap" hidden>
            <label class="modal-checkbox">
              <input id="modal-input" class="modal-input" type="text" />
              <span id="modal-input-label" class="modal-input-label"></span>
            </label>
          </div>
          <div class="modal-actions" id="modal-actions"></div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let els = {};
    let stateTree = [];
    let sourceTree = [];
    let sourceView = 'list';
    let sourceCollapsed = new Set();
    let selectedId = '';
    let selectedIds = new Set();
    let selectionAnchorId = '';
    let selectionParentKey = '';
    let draggedId = '';
		    let draggedIds = [];
		    let dropHint = { mode: null, targetId: null };
		    let dropLineEl = null;
    let debugEnabled = false;
    let debugLog = [];
    let lastDropHintSignature = '';
    let lastDragoverLogAt = 0;
    let historyPast = [];
    let historyFuture = [];
    let lastPersistedSignature = '';
    let treeCollapsed = new Set();
    let lastDepthAction = '';
    let lastDepthValue = 5;
    let toolTipEl = null;
    let uiStateLoaded = false;
    let uiStateSaveTimer = null;
    let uiStateLastSavedAt = 0;
    let uiStateSaving = false;
    let uiStateSavePending = false;
    let uiState = {};
    let pendingTreeRestore = false;
    let pendingSourceRestore = false;
    let maybeLoadEditorFromSelection = () => {};
		    let activeInlineEdit = null;
		    let autoSyncTimer = null;
    let statusHistory = [];
    let statusExpanded = false;
    let mkdocsStream = null;
    let mkdocsLogLines = [];
    const mkdocsLogLimit = 200;
    let mkdocsLastState = '';
    let skipEmptyDeleteConfirmSession = false;
    let showChoice = async () => 'cancel';
    let showConfirm = async () => false;
    let showPrompt = async () => null;
    let showAlert = async () => {};
    let dragMode = 'sync_files'; // sync_files | nav_only
		    let selectedDisplaySlotFolderId = '';
		    let showTools = false;
    let showSource = false;
    let showTree = true;
    let showInfo = false;
    let theme = 'dark';
    let treeContextOpen = false;
    let treeSearchQuery = '';
    let treeSearchMatches = [];
    let treeSearchIndex = -1;
    let updateTreeActionButtons = () => {};
    let docsRoot = '';
    const mkdocsServeUrl = 'http://127.0.0.1:8000/';
    const iconsearchIndexUrl = '/api/icons_index';
    const svgCache = new Map();
    let iconsPanelVisible = false;
    let iconsFilter = 'all';
    let iconsQuery = '';
    const iconsBatchSize = 200;
    let iconsMatchStats = { total: 0, displayed: 0, truncated: false };
    let iconsResultState = { entries: [], rendered: 0 };
    let iconsCache = {
      loaded: false,
      loading: false,
      error: '',
      entries: [],
      counts: { icons: 0, emojis: 0 }
    };
    // Registry for one-time global handlers that clear the persistent located highlight
    let locatedClearHandlers = [];
    // Suppress clearing for a short window right after installing handlers
    let locatedSuppressUntil = 0;

	    document.addEventListener('DOMContentLoaded', async () => {
      els = {
        meta: document.getElementById('meta'),
        mkdocsStatus: document.getElementById('mkdocs-status'),
        status: document.getElementById('status'),
        source: document.getElementById('source'),
        tree: document.getElementById('tree'),
        workspace: document.getElementById('workspace'),
        panelTools: document.getElementById('panel-tools'),
        panelSource: document.getElementById('panel-source'),
        panelTree: document.getElementById('panel-tree'),
        panelInfo: document.getElementById('panel-info'),
        bottomStack: document.getElementById('bottom-stack'),
        infoMeta: document.getElementById('info-meta'),
	        infoMetaPill: document.getElementById('info-meta-pill'),
        infoHover: document.getElementById('info-hover'),
        infoSelection: document.getElementById('info-selection'),
	        infoSelectionPill: document.getElementById('info-selection-pill'),
        infoSearch: document.getElementById('info-search'),
        infoSearchPill: document.getElementById('info-search-pill'),
	        infoDetails: document.getElementById('info-details'),
        infoErrors: document.getElementById('info-errors'),
        mkdocsMonitor: document.getElementById('mkdocs-monitor'),
        mkdocsLog: document.getElementById('mkdocs-log'),
        sourceViewBtn: document.getElementById('source-view-btn'),
        newFolderBtn: document.getElementById('new-folder-btn'),
        newPageBtn: document.getElementById('new-page-btn'),
        newPageWithFolderBtn: document.getElementById('new-page-with-folder-btn'),
        normalizeNamesBtn: document.getElementById('normalize-names-btn'),
        deleteBtn: document.getElementById('delete-btn'),
        toolUndoBtn: document.getElementById('tool-undo'),
	        toolRedoBtn: document.getElementById('tool-redo'),
		        toolImportBtn: document.getElementById('tool-import'),
		        toolBeautifyNavBtn: document.getElementById('tool-beautify-nav'),
		        dragModeToggle: document.getElementById('drag-mode-toggle'),
		        dragModeSwitch: document.getElementById('drag-mode-switch'),
		        dragModeText: document.getElementById('drag-mode-text'),
		        toolDebugBtn: document.getElementById('tool-debug'),
        debugPanel: document.getElementById('debug-panel'),
        debugLog: document.getElementById('debug-log'),
        debugClear: document.getElementById('debug-clear'),
        debugCopy: document.getElementById('debug-copy'),
        splitMainLeft: document.getElementById('split-main-left'),
        splitBottom: document.getElementById('split-bottom'),
        splitInfoDebug: document.getElementById('split-info-debug'),
        splitTools: document.getElementById('split-tools'),
        toggleTools: document.getElementById('toggle-tools'),
        toggleSource: document.getElementById('toggle-source'),
        toggleTree: document.getElementById('toggle-tree'),
        toggleInfo: document.getElementById('toggle-info'),
        toggleIconsPanel: document.getElementById('toggle-icons-panel'),
        toggleSimpleEditor: document.getElementById('toggle-simple-editor'),
        toggleTheme: document.getElementById('toggle-theme'),
        mkdocsStartBtn: document.getElementById('mkdocs-start-btn'),
        mkdocsStopBtn: document.getElementById('mkdocs-stop-btn'),
        mkdocsOpenBtn: document.getElementById('mkdocs-open-btn'),
        rainbowToggleBtn: document.getElementById('rainbow-toggle-btn'),
        treeSearchInput: document.getElementById('tree-search-input'),
        treeSearchCount: document.getElementById('tree-search-count'),
        treeSearchPrev: document.getElementById('tree-search-prev'),
        treeSearchNext: document.getElementById('tree-search-next'),
        treeSearchClear: document.getElementById('tree-search-clear'),
        treeLocateBtn: document.getElementById('tree-locate-btn'),
        openFileBtn: document.getElementById('open-file-btn'),
        openDocWebBtn: document.getElementById('open-doc-web-btn'),
        simpleEditBtn: document.getElementById('simple-edit-btn'),
        treeContext: document.getElementById('tree-context'),
        simpleEditor: document.getElementById('simple-editor'),
        iconsPanel: document.getElementById('icons-panel'),
        iconsClose: document.getElementById('icons-close'),
        iconsReload: document.getElementById('icons-reload'),
        iconsSearchInput: document.getElementById('icons-search-input'),
        iconsResults: document.getElementById('icons-results'),
        iconsHint: document.getElementById('icons-hint'),
        iconsStatus: document.getElementById('icons-status'),
        iconsMatchCount: document.getElementById('icons-match-count'),
        iconsFilterAll: document.getElementById('icons-filter-all'),
        iconsFilterIcons: document.getElementById('icons-filter-icons'),
        iconsFilterEmojis: document.getElementById('icons-filter-emojis'),
        simpleEditFile: document.getElementById('simple-edit-file'),
        simpleEditDiff: document.getElementById('simple-edit-diff'),
        simpleEditAbort: document.getElementById('simple-edit-abort'),
        simpleEditSave: document.getElementById('simple-edit-save'),
        simpleEditClose: document.getElementById('simple-edit-close'),
        simpleEditLines: document.getElementById('simple-edit-lines'),
        simpleEditHighlight: document.getElementById('simple-edit-highlight'),
        simpleEditInput: document.getElementById('simple-edit-input'),
        modal: document.getElementById('modal'),
        modalTitle: document.getElementById('modal-title'),
        modalMessage: document.getElementById('modal-message'),
        modalInputWrap: document.getElementById('modal-input-wrap'),
        modalInput: document.getElementById('modal-input'),
        modalInputLabel: document.getElementById('modal-input-label'),
        modalActions: document.getElementById('modal-actions'),
      };

		      // Load mkdocs.yml from disk, overwrite current draft tree, and beautify nav formatting.
		      els.toolImportBtn.addEventListener('click', () => importFromMkdocs({ confirm: true, beautify: true }));
		      if (els.toolBeautifyNavBtn) els.toolBeautifyNavBtn.addEventListener('click', beautifyNav);

      els.newFolderBtn.addEventListener('click', () => createNode('folder'));
      els.newPageBtn.addEventListener('click', () => createNode('page'));
      if (els.newPageWithFolderBtn) els.newPageWithFolderBtn.addEventListener('click', createPageWithFolder);
      if (els.normalizeNamesBtn) els.normalizeNamesBtn.addEventListener('click', normalizeTreeNames);
      els.deleteBtn.addEventListener('click', deleteSelected);
	      els.toolUndoBtn.addEventListener('click', undo);
	      els.toolRedoBtn.addEventListener('click', redo);
	      if (els.dragModeToggle) els.dragModeToggle.addEventListener('change', onDragModeToggle);

      els.toolDebugBtn.addEventListener('click', toggleDebug);
      els.debugClear.addEventListener('click', () => {
        debugLog = [];
        renderDebug();
      });
      els.debugCopy.addEventListener('click', () => {
        const text = (debugLog || []).join('\n');
        copyToClipboard(text);
        setStatus('Debug log copied.', 'info');
      });

      if (els.panelInfo) {
        els.panelInfo.addEventListener('dblclick', (e) => {
          const target = e.target;
          if (!target || !target.closest('.info-body')) return;
          toggleStatusExpanded();
        });
      }
      if (els.treeSearchInput) {
        els.treeSearchInput.addEventListener('input', (e) => {
          const value = e && e.target ? e.target.value : '';
          refreshTreeSearch({ query: value, selectMatch: true });
        });
        els.treeSearchInput.addEventListener('keydown', (e) => {
          const key = e.key || '';
          if (key === 'Enter') {
            e.preventDefault();
            if (e.shiftKey) selectTreeSearchMatch(treeSearchIndex - 1);
            else selectTreeSearchMatch(treeSearchIndex + 1);
            return;
          }
          if (key === 'ArrowDown') {
            e.preventDefault();
            selectTreeSearchMatch(treeSearchIndex + 1);
            return;
          }
          if (key === 'ArrowUp') {
            e.preventDefault();
            selectTreeSearchMatch(treeSearchIndex - 1);
            return;
          }
          if (key === 'Escape') {
            e.preventDefault();
            clearTreeSearch();
          }
        });
      }
      if (els.treeSearchPrev) els.treeSearchPrev.addEventListener('click', () => selectTreeSearchMatch(treeSearchIndex - 1));
      if (els.treeSearchNext) els.treeSearchNext.addEventListener('click', () => selectTreeSearchMatch(treeSearchIndex + 1));
      if (els.treeSearchClear) els.treeSearchClear.addEventListener('click', clearTreeSearch);

      sourceView = localStorage.getItem('page_tree_source_view') || 'list';
      sourceCollapsed = new Set(JSON.parse(localStorage.getItem('page_tree_source_collapsed') || '[]'));
      els.sourceViewBtn.addEventListener('click', toggleSourceView);
      updateSourceViewButton();
      treeCollapsed = new Set(JSON.parse(localStorage.getItem('page_tree_tree_collapsed') || '[]'));
      normalizeTreeCollapsed();
      bindDepthButtons();
      updateDepthButtons();
      if (els.tree) els.tree.addEventListener('scroll', () => persistScrollPosition('page_tree_scroll_tree', els.tree), { passive: true });
      if (els.source) els.source.addEventListener('scroll', () => persistScrollPosition('page_tree_scroll_source', els.source), { passive: true });

      // Unified DnD handlers on the tree container (mouse-position detector).
      els.tree.addEventListener('dragover', onTreeDragOver);
      els.tree.addEventListener('drop', onTreeDrop);
      els.tree.addEventListener('dragleave', onTreeDragLeave);
      dropLineEl = document.createElement('div');
      dropLineEl.className = 'drop-line';
      els.tree.appendChild(dropLineEl);
      hideDropLine();

      // Default: hidden each session.
      debugEnabled = false;
      debugLog = [];
      if (els.debugPanel) els.debugPanel.hidden = true;
      updateDebugVisibility();

		      initSplitters();
		      bindToolHoverHints();

      // Default visible: Tools/Source/Doc Tree/Info (user can toggle).
      showTools = localStorage.getItem('page_tree_show_tools') !== 'false';
      showSource = localStorage.getItem('page_tree_show_source') !== 'false';
      showTree = localStorage.getItem('page_tree_show_tree') !== 'false';
      showInfo = localStorage.getItem('page_tree_show_info') !== 'false';
      initTheme();
      applyPanelVisibility();
      initStatusExpanded();
      renderStatusHistory();
      if (els.status) {
        if (window.ResizeObserver) {
          const statusObserver = new ResizeObserver(() => renderStatusHistory());
          statusObserver.observe(els.status);
        } else {
          window.addEventListener('resize', renderStatusHistory);
        }
      }
      if (els.toggleTools) els.toggleTools.addEventListener('click', () => {
        showTools = !showTools;
        localStorage.setItem('page_tree_show_tools', String(showTools));
        applyPanelVisibility();
      });
      if (els.toggleSource) els.toggleSource.addEventListener('click', () => {
        showSource = !showSource;
        localStorage.setItem('page_tree_show_source', String(showSource));
        applyPanelVisibility();
      });
      if (els.toggleTree) els.toggleTree.addEventListener('click', () => {
        showTree = !showTree;
        localStorage.setItem('page_tree_show_tree', String(showTree));
        applyPanelVisibility();
      });
      if (els.toggleInfo) els.toggleInfo.addEventListener('click', () => {
        showInfo = !showInfo;
        localStorage.setItem('page_tree_show_info', String(showInfo));
        applyPanelVisibility();
      });
      if (els.toggleTheme) els.toggleTheme.addEventListener('click', toggleTheme);
      if (els.rainbowToggleBtn) els.rainbowToggleBtn.addEventListener('click', toggleRainbowColors);

      document.addEventListener('keydown', (e) => {
        if (!e) return;
        const target = e.target;
        const tag = target && target.tagName ? target.tagName.toLowerCase() : '';
        const isInput = !!(target && (target.isContentEditable || tag === 'input' || tag === 'textarea' || tag === 'select'));
        const inModal = els.modal && !els.modal.hidden && els.modal.contains(target);
        const meta = e.metaKey || e.ctrlKey;
        const alt = e.altKey;
        const shift = e.shiftKey;
        const key = e.key || '';
        const code = e.code || '';
        const isSave = meta && (key.toLowerCase() === 's');

        if (inModal || activeInlineEdit) return;
        if (isInput && !(isSave && target === els.simpleEditInput)) return;

        if (alt && shift && code === 'KeyN') {
          e.preventDefault();
          return createNode('folder');
        }
        if (alt && !shift && code === 'KeyN') {
          e.preventDefault();
          return createNode('page');
        }
        if (alt && shift && code === 'KeyP') {
          e.preventDefault();
          return createPageWithFolder();
        }
        if (key === 'F2') {
          e.preventDefault();
          return renameSelected();
        }
        if ((key === 'Delete' || key === 'Backspace') && !isInput) {
          e.preventDefault();
          return deleteSelected();
        }
        if (alt && code === 'KeyL') {
          e.preventDefault();
          return locateSelectedInSource();
        }
        if (alt && code === 'KeyO') {
          e.preventDefault();
          return openSelectedFile();
        }
        if (alt && code === 'KeyR') {
          e.preventDefault();
          return openSelectedDocWeb();
        }
        if (alt && code === 'KeyW') {
          e.preventDefault();
          return openSelectedDocWeb();
        }
        if (alt && code === 'KeyE') {
          e.preventDefault();
          return openSimpleEditorFromSelection();
        }
        if (isSave && els.simpleEditor && !els.simpleEditor.hidden) {
          e.preventDefault();
          return saveSimpleEditor();
        }
      });

      // Click tree panel background to deselect (go back to root)
      els.tree.addEventListener('click', (e) => {
        // Only trigger if clicking directly on tree container (not on children)
        if (e.target === els.tree || e.target.classList.contains('tree-root')) {
          selectedId = '';
          selectedIds = new Set();
          selectionAnchorId = '';
          selectionParentKey = '';
          selectedDisplaySlotFolderId = '';
          syncSelectionClasses();
          updateInfo();
        }
      });

      // Click outside tree to deselect (go back to root)
      document.addEventListener('click', (e) => {
        const target = e.target;
        const inTree = els.tree.contains(target) || els.panelTree.contains(target);
        const inEditor = els.simpleEditor && !els.simpleEditor.hidden && els.simpleEditor.contains(target);
        const inIconsPanel = els.iconsPanel && !els.iconsPanel.hidden && els.iconsPanel.contains(target);
        const inEditorControl = target && target.closest
          ? target.closest('#toggle-simple-editor, #simple-edit-btn, #simple-edit-save, #simple-edit-abort, #simple-edit-close')
          : null;
        const inIconsControl = target && target.closest
          ? target.closest('#toggle-icons-panel, #icons-close, #icons-reload')
          : null;
        const inModal = els.modal && !els.modal.hidden && els.modal.contains(target);
        // Check if click is outside tree panel and not part of the simple editor flow
        if (!inTree && !inEditor && !inEditorControl && !inIconsPanel && !inIconsControl && !inModal) {
          // Deselect all
          selectedId = '';
          selectedIds = new Set();
          selectionAnchorId = '';
          selectionParentKey = '';
          selectedDisplaySlotFolderId = '';
          selectionClearedManual = true;
          syncSelectionClasses();
          if (typeof updateInfo === 'function') updateInfo();
        }
      });

      // Locate button in the Doc Tree header: locate selected page/overview in Source pane
      const locateSelectedInSource = () => {
        // Determine selection id: prefer single selectedId, then first of selectedIds
        const id = selectedId || (selectedIds && selectedIds.size ? Array.from(selectedIds)[0] : '');
        // Helper to open source panel and call locateByFile
        const openAndLocate = (filePath) => {
          showSource = true;
          localStorage.setItem('page_tree_show_source', String(true));
          applyPanelVisibility();
          locateByFile(filePath);
        };

        if (!id) {
          // If no explicit selection, but a display slot folder selected, try to locate its overview
          if (selectedDisplaySlotFolderId) {
            const found = findNode(stateTree, selectedDisplaySlotFolderId);
            if (found && found.node && found.node.type === 'folder') {
              const overview = (found.node.children || []).find(c => c && c.type === 'page' && c.is_overview && c.file);
              if (overview && overview.file) return openAndLocate(overview.file);
            }
          }
          return setStatus('‚ö†Ô∏è No page selected to locate.', 'info');
        }

        const found = findNode(stateTree, id);
        if (!found) return setStatus('‚ö†Ô∏è Selected node not in tree.', 'info');
        const node = found.node;
        if (node.type === 'page' && node.file) return openAndLocate(node.file);
        if (node.type === 'folder') {
          const overview = (node.children || []).find(c => c && c.type === 'page' && c.is_overview && c.file);
          if (overview && overview.file) return openAndLocate(overview.file);
        }
        setStatus('‚ö†Ô∏è Selected node has no associated file to locate.', 'info');
      };
      if (els.treeLocateBtn) els.treeLocateBtn.addEventListener('click', locateSelectedInSource);

      function getFileForNode(node) {
        if (!node) return '';
        if (node.type === 'page' && node.file) return node.file;
        if (node.type === 'folder') {
          const overview = (node.children || []).find(c => c && c.type === 'page' && c.is_overview && c.file);
          if (overview && overview.file) return overview.file;
        }
        return '';
      }

      function resolveSelectedFile(forcedId) {
        let id = forcedId || selectedId || (selectedIds && selectedIds.size ? Array.from(selectedIds)[0] : '');
        if (!id && selectedDisplaySlotFolderId) {
          const found = findNode(stateTree, selectedDisplaySlotFolderId);
          const file = found && found.node ? getFileForNode(found.node) : '';
          if (file) id = found.node.id;
        }
        if (!id) return '';
        const found = findNode(stateTree, id);
        if (!found) return '';
        return getFileForNode(found.node);
      }

      const openSelectedFile = async () => {
        let id = selectedId || (selectedIds && selectedIds.size ? Array.from(selectedIds)[0] : '');
        const file = resolveSelectedFile(id);
        if (!file) return setStatus('‚ö†Ô∏è No page selected to open.', 'info');
        try {
          const data = await fetchJson('/api/open_file', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ file })
          });
          const mode = data && data.mode ? data.mode : 'default';
          setStatus(mode === 'vscode' ? '‚úÖ Opened in VS Code.' : '‚òëÔ∏è Opened in default viewer.', 'success');
        } catch (e) {
          setStatus(e.message || 'Open failed.', 'error');
        }
      };
      if (els.openFileBtn) els.openFileBtn.addEventListener('click', openSelectedFile);

      async function ensureMkdocsUrlAvailable(url) {
        if (!url) return false;
        try {
          const data = await fetchJson('/api/mkdocs/check', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ url })
          });
          return !!(data && data.reachable);
        } catch (e) {
          return false;
        }
      }

      function openMkdocsUrl(url) {
        if (!url) return;
        let win = null;
        try { win = window.open(url, '_blank', 'noopener'); } catch (e) { win = null; }
        if (!win) return;
        win.focus();
      }

      function buildMkdocsUrlForFile(file) {
        if (!file) return '';
        const cleaned = String(file).replace(/\\/g, '/').replace(/^\.\//, '');
        const normalizedRoot = String(docsRoot || '').replace(/\\/g, '/').replace(/\/+$/, '');
        let rel = cleaned;
        if (normalizedRoot && rel.startsWith(normalizedRoot)) {
          rel = rel.slice(normalizedRoot.length).replace(/^\/+/, '');
        }
        rel = rel.replace(/^\/+/, '');
        const isReadme = /(?:^|\/)(readme|index)\.md$/i.test(rel);
        let path = rel;
        if (isReadme) {
          path = rel.replace(/(?:^|\/)(readme|index)\.md$/i, '');
        } else {
          path = rel.replace(/\.(md|markdown)$/i, '');
        }
        path = path.replace(/^\/+/, '').replace(/\/+$/, '');
        if (!path) return mkdocsServeUrl;
        const encoded = path.split('/').map(seg => encodeURIComponent(seg)).join('/');
        return `${mkdocsServeUrl}${encoded}/`;
      }

      const openSelectedDocWeb = async () => {
        let id = selectedId || (selectedIds && selectedIds.size ? Array.from(selectedIds)[0] : '');
        const file = resolveSelectedFile(id);
        if (!file) return setStatus('‚ö†Ô∏è No page selected to open in web.', 'info');
        const url = buildMkdocsUrlForFile(file);
        if (!url) return setStatus('‚ö†Ô∏è Unable to build MkDocs URL.', 'error');
        const available = await ensureMkdocsUrlAvailable(mkdocsServeUrl);
        if (!available) {
          return setStatus('‚ö†Ô∏è MkDocs site not reachable. Please run `mkdocs serve` first.', 'info');
        }
        openMkdocsUrl(url);
      };
      if (els.openDocWebBtn) els.openDocWebBtn.addEventListener('click', openSelectedDocWeb);

      const editorState = {
        currentFile: '',
        dirty: false,
        originalLines: []
      };

      const modalState = { resolve: null, cleanup: null };

      const closeModal = (value) => {
        if (!modalState.resolve) return;
        const resolve = modalState.resolve;
        modalState.resolve = null;
        if (modalState.cleanup) {
          modalState.cleanup();
          modalState.cleanup = null;
        }
        if (els.modal) els.modal.hidden = true;
        resolve(value);
      };

      showChoice = (options) => {
        const opts = options || {};
        const title = String(opts.title || 'Confirm');
        const message = String(opts.message || '');
        const buttons = Array.isArray(opts.buttons) ? opts.buttons : [];
        const cancelValue = opts.cancelValue;
        const hasInput = !!opts.input;
        const defaultValue = opts.input && typeof opts.input.value === 'string' ? opts.input.value : '';
        const placeholder = opts.input && typeof opts.input.placeholder === 'string' ? opts.input.placeholder : '';
        const inputType = opts.input && typeof opts.input.type === 'string' ? opts.input.type : 'text';
        const inputLabel = opts.input && typeof opts.input.label === 'string' ? opts.input.label : '';
        return new Promise((resolve) => {
          modalState.resolve = resolve;
          if (els.modalTitle) els.modalTitle.textContent = title;
          if (els.modalMessage) els.modalMessage.textContent = message;
          if (els.modalInputWrap) {
            els.modalInputWrap.hidden = !hasInput;
            els.modalInputWrap.classList.toggle('is-checkbox', hasInput && inputType === 'checkbox');
          }
          if (els.modalInput) {
            if (hasInput) {
              els.modalInput.type = inputType === 'checkbox' ? 'checkbox' : 'text';
              if (inputType === 'checkbox') {
                els.modalInput.checked = !!opts.input.value;
                els.modalInput.placeholder = '';
              } else {
                els.modalInput.value = defaultValue;
                els.modalInput.placeholder = placeholder;
              }
            } else {
              els.modalInput.value = '';
              els.modalInput.placeholder = '';
            }
          }
          if (els.modalInputLabel) {
            els.modalInputLabel.textContent = inputLabel;
            els.modalInputLabel.hidden = !hasInput || !inputLabel;
          }
          if (els.modalActions) {
            els.modalActions.innerHTML = '';
            buttons.forEach((btn) => {
              const b = document.createElement('button');
              b.type = 'button';
              b.textContent = btn.label;
              if (btn.primary) b.classList.add('active');
              if (btn.ghost) b.classList.add('ghost');
              b.addEventListener('click', () => {
                const inputValue = hasInput && els.modalInput
                  ? (els.modalInput.type === 'checkbox' ? els.modalInput.checked : els.modalInput.value)
                  : '';
                closeModal({ value: btn.value, input: inputValue });
              });
              els.modalActions.appendChild(b);
            });
          }
          if (els.modal) els.modal.hidden = false;
          const primary = els.modalActions ? els.modalActions.querySelector('button.active') : null;
          if (primary) primary.focus();
          if (hasInput && els.modalInput) {
            els.modalInput.focus();
            if (els.modalInput.type !== 'checkbox') els.modalInput.select();
          }
          const onKey = (e) => {
            if (e.key === 'Escape' && modalState.resolve) {
              const inputValue = hasInput && els.modalInput
                ? (els.modalInput.type === 'checkbox' ? els.modalInput.checked : els.modalInput.value)
                : '';
              closeModal({ value: cancelValue, input: inputValue });
            }
            if (e.key === 'Enter' && hasInput && primary && modalState.resolve) {
              const inputValue = els.modalInput
                ? (els.modalInput.type === 'checkbox' ? els.modalInput.checked : els.modalInput.value)
                : '';
              closeModal({ value: buttons.find(b => b.primary)?.value ?? cancelValue, input: inputValue });
            }
          };
          const onBackdrop = (e) => {
            if (!els.modal || !modalState.resolve) return;
            if (e.target && e.target.classList && e.target.classList.contains('modal-backdrop')) {
              const inputValue = hasInput && els.modalInput
                ? (els.modalInput.type === 'checkbox' ? els.modalInput.checked : els.modalInput.value)
                : '';
              closeModal({ value: cancelValue, input: inputValue });
            }
          };
          modalState.cleanup = () => {
            window.removeEventListener('keydown', onKey);
            if (els.modal) els.modal.removeEventListener('click', onBackdrop);
          };
          window.addEventListener('keydown', onKey);
          if (els.modal) els.modal.addEventListener('click', onBackdrop);
        });
      };

      showConfirm = async (message, opts) => {
        const options = opts || {};
        const res = await showChoice({
          title: options.title || 'Confirm',
          message,
          cancelValue: false,
          buttons: [
            { label: options.okText || 'OK', value: true, primary: true },
            { label: options.cancelText || 'Cancel', value: false, ghost: true }
          ]
        });
        return !!(res && res.value);
      };

      showAlert = async (message, opts) => {
        const options = opts || {};
        await showChoice({
          title: options.title || 'Notice',
          message,
          cancelValue: true,
          buttons: [{ label: options.okText || 'OK', value: true, primary: true }]
        });
      };

      showPrompt = async (message, opts) => {
        const options = opts || {};
        const res = await showChoice({
          title: options.title || 'Input',
          message,
          cancelValue: null,
          input: {
            value: options.defaultValue || '',
            placeholder: options.placeholder || ''
          },
          buttons: [
            { label: options.okText || 'OK', value: 'ok', primary: true },
            { label: options.cancelText || 'Cancel', value: null, ghost: true }
          ]
        });
        if (!res || res.value === null) return null;
        return String(res.input || '');
      };

      function setSimpleEditorVisible(show) {
        if (!els.simpleEditor) return;
        els.simpleEditor.hidden = !show;
        if (els.toggleSimpleEditor) {
          if (show) els.toggleSimpleEditor.classList.add('active');
          else els.toggleSimpleEditor.classList.remove('active');
        }
      }

      function setIconsPanelVisible(show) {
        if (!els.iconsPanel) return;
        iconsPanelVisible = show;
        els.iconsPanel.hidden = !show;
        if (els.toggleIconsPanel) {
          if (show) els.toggleIconsPanel.classList.add('active');
          else els.toggleIconsPanel.classList.remove('active');
        }
      }

      function normalizeTextTokens(text) {
        return String(text || '')
          .toLowerCase()
          .trim()
          .replace(/[\s\-_/:\.]+/g, ' ')
          .split(' ')
          .filter(Boolean);
      }

      function normalizeIndexEntries(raw) {
        if (!Array.isArray(raw)) return [];
        const entries = [];
        raw.forEach((item) => {
          if (!item || typeof item !== 'object') return;
          const type = String(item.type || '').toLowerCase();
          if (type !== 'icon' && type !== 'emoji') return;
          const name = typeof item.name === 'string' ? item.name.trim() : '';
          const shortcode = typeof item.shortcode === 'string' ? item.shortcode.trim() : '';
          const keywords = Array.isArray(item.keywords)
            ? item.keywords.filter(k => typeof k === 'string' && k.trim()).map(k => k.trim())
            : [];
          const path = typeof item.path === 'string' ? item.path.trim() : '';
          const svg = typeof item.svg === 'string' ? item.svg.trim() : '';
          const unicode = typeof item.unicode === 'string' ? item.unicode : '';
          const searchParts = [];
          if (name) searchParts.push(name);
          if (shortcode) searchParts.push(shortcode);
          if (keywords.length) searchParts.push(keywords.join(' '));
          const searchText = searchParts.join(' ').toLowerCase();
          const searchTokens = normalizeTextTokens(searchText);
          const searchCompact = searchText.replace(/[^\p{L}\p{N}]+/gu, '');
          entries.push({ type, name, shortcode, keywords, path, svg, unicode, searchText, searchTokens, searchCompact });
        });
        return entries;
      }

      function resolveSvgPath(path) {
        if (!path) return '';
        if (/^https?:\/\//i.test(path)) return path;
        if (path.startsWith('/')) return path;
        return `/${path.replace(/^\.\//, '').replace(/^\./, '').replace(/^\/+/, '')}`;
      }

      async function loadSvg(path) {
        if (!path) return null;
        const resolved = resolveSvgPath(path);
        if (svgCache.has(resolved)) return svgCache.get(resolved);
        try {
          const res = await fetch(resolved, { credentials: 'same-origin' });
          if (!res.ok) throw new Error(`SVG fetch failed: ${res.status}`);
          const text = await res.text();
          svgCache.set(resolved, text);
          return text;
        } catch (err) {
          svgCache.set(resolved, null);
          return null;
        }
      }

      function setIconsHint(message, show) {
        if (!els.iconsHint) return;
        els.iconsHint.textContent = message || '';
        els.iconsHint.hidden = !show;
      }

      function updateIconsStatus(message) {
        if (!els.iconsStatus) return;
        if (els.iconsMatchCount) {
          els.iconsMatchCount.textContent = '';
        }
        if (message) {
          els.iconsStatus.textContent = message;
          return;
        }
        if (iconsCache.loading) {
          els.iconsStatus.textContent = 'Loading...';
          return;
        }
        if (iconsCache.error && !iconsCache.entries.length) {
          els.iconsStatus.textContent = 'Load failed';
          return;
        }
        if (iconsQuery.trim()) {
          const total = iconsMatchStats.total || 0;
          const shown = iconsMatchStats.displayed || 0;
          const truncated = iconsMatchStats.truncated;
          if (truncated) {
            els.iconsStatus.textContent = `Showing first ${shown} of ${total}`;
          } else {
            els.iconsStatus.textContent = `Matches: ${total}`;
          }
          if (els.iconsMatchCount) {
            els.iconsMatchCount.textContent = truncated ? `${shown}/${total}` : `${total} matches`;
          }
          return;
        }
        els.iconsStatus.textContent = `Icons: ${iconsCache.counts.icons} | Emojis: ${iconsCache.counts.emojis}`;
      }

      function filterIconsResults(query, filter) {
        const tokens = normalizeTextTokens(query);
        if (!tokens.length) return [];
        const queryText = tokens.join(' ');
        const queryCompact = queryText.replace(/[^\p{L}\p{N}]+/gu, '');
        const matches = [];
        iconsCache.entries.forEach((entry) => {
          if (filter === 'icon' && entry.type !== 'icon') return false;
          if (filter === 'emoji' && entry.type !== 'emoji') return false;
          const entryTokens = entry.searchTokens || [];
          const entryText = entry.searchText || '';
          const entryCompact = entry.searchCompact || '';
          let score = 0;
          const ok = tokens.every((token) => {
            if (entryText.includes(token)) {
              score += 3;
              return true;
            }
            if (entryTokens.some((t) => t.startsWith(token))) {
              score += 2;
              return true;
            }
            if (entryCompact && isSubsequence(token, entryCompact)) {
              score += 1;
              return true;
            }
            return false;
          });
          if (!ok) return;
          if (entryText.includes(queryText)) score += 6;
          if (queryCompact && entryCompact.includes(queryCompact)) score += 4;
          matches.push({ entry, score });
        });
        matches.sort((a, b) => {
          if (b.score !== a.score) return b.score - a.score;
          return (a.entry.name || '').localeCompare(b.entry.name || '');
        });
        return matches.map(item => item.entry);
      }

      function isSubsequence(needle, haystack) {
        if (!needle || !haystack) return false;
        let i = 0;
        let j = 0;
        while (i < needle.length && j < haystack.length) {
          if (needle[i] === haystack[j]) i += 1;
          j += 1;
        }
        return i === needle.length;
      }

      function renderIconPreview(preview, entry) {
        if (entry.type === 'emoji') {
          if (entry.unicode) {
            preview.textContent = entry.unicode;
            return;
          }
          if (entry.svg) {
            preview.innerHTML = entry.svg;
            return;
          }
          if (entry.path) {
            preview.textContent = 'üôÇ';
            const currentKey = entry.name;
            loadSvg(entry.path).then((svgText) => {
              if (!svgText) return;
              if (preview.closest('.icons-item')?.dataset?.name !== currentKey) return;
              preview.innerHTML = svgText;
              const svg = preview.querySelector('svg');
              if (svg) {
                svg.setAttribute('width', '20');
                svg.setAttribute('height', '20');
                svg.setAttribute('aria-hidden', 'true');
                svg.removeAttribute('fill');
              }
            });
            return;
          }
          preview.textContent = 'üôÇ';
          return;
        }
        if (entry.svg) {
          preview.innerHTML = entry.svg;
          return;
        }
        if (entry.path) {
          preview.textContent = '.';
          const currentKey = entry.name;
          loadSvg(entry.path).then((svgText) => {
            if (!svgText) return;
            if (preview.closest('.icons-item')?.dataset?.name !== currentKey) return;
            preview.innerHTML = svgText;
            const svg = preview.querySelector('svg');
            if (svg) {
              svg.setAttribute('width', '20');
              svg.setAttribute('height', '20');
              svg.setAttribute('aria-hidden', 'true');
              svg.removeAttribute('fill');
            }
          });
          return;
        }
        preview.textContent = '.';
      }

      function renderIconsResults(entries, limit, append) {
        if (!els.iconsResults) return;
        if (!append) els.iconsResults.innerHTML = '';
        const highlightTokens = normalizeTextTokens(iconsQuery);
        const fragment = document.createDocumentFragment();
        const max = Math.min(entries.length, limit);
        for (let i = 0; i < max; i += 1) {
          const entry = entries[i];
          const item = document.createElement('div');
          item.className = 'icons-item';
          item.dataset.name = entry.name;
          item.dataset.type = entry.type;
          item.dataset.markup = entry.shortcode || '';

          const preview = document.createElement('div');
          preview.className = 'icons-preview';
          renderIconPreview(preview, entry);

          const meta = document.createElement('div');
          meta.className = 'icons-meta';
          const nameEl = document.createElement('div');
          nameEl.className = 'icons-name';
          setHighlightedText(nameEl, entry.name, highlightTokens);
          const markupEl = document.createElement('div');
          markupEl.className = 'icons-markup';
          setHighlightedText(markupEl, entry.shortcode || '', highlightTokens);
          meta.appendChild(nameEl);
          meta.appendChild(markupEl);

          const copy = document.createElement('button');
          copy.type = 'button';
          copy.className = 'ghost icons-copy';
          copy.textContent = 'Copy';

          item.appendChild(preview);
          item.appendChild(meta);
          item.appendChild(copy);
          fragment.appendChild(item);
        }
        els.iconsResults.appendChild(fragment);
      }

      function setHighlightedText(el, text, tokens) {
        if (!el) return;
        el.textContent = '';
        const raw = String(text || '');
        if (!raw || !tokens.length) {
          el.textContent = raw;
          return;
        }
        const lower = raw.toLowerCase();
        const ranges = [];
        tokens.forEach((token) => {
          if (!token) return;
          let start = 0;
          while (true) {
            const idx = lower.indexOf(token, start);
            if (idx === -1) break;
            ranges.push([idx, idx + token.length]);
            start = idx + token.length;
          }
        });
        if (!ranges.length) {
          el.textContent = raw;
          return;
        }
        ranges.sort((a, b) => (a[0] - b[0]) || (a[1] - b[1]));
        const merged = [];
        ranges.forEach(([s, e]) => {
          const last = merged[merged.length - 1];
          if (!last || s > last[1]) merged.push([s, e]);
          else if (e > last[1]) last[1] = e;
        });
        let cursor = 0;
        merged.forEach(([s, e]) => {
          if (s > cursor) el.appendChild(document.createTextNode(raw.slice(cursor, s)));
          const span = document.createElement('span');
          span.className = 'icons-highlight';
          span.textContent = raw.slice(s, e);
          el.appendChild(span);
          cursor = e;
        });
        if (cursor < raw.length) {
          el.appendChild(document.createTextNode(raw.slice(cursor)));
        }
      }

      function renderNextIconsBatch() {
        const entries = iconsResultState.entries || [];
        if (!entries.length) return;
        const start = iconsResultState.rendered || 0;
        if (start >= entries.length) return;
        const slice = entries.slice(start, start + iconsBatchSize);
        renderIconsResults(slice, slice.length, true);
        iconsResultState.rendered = start + slice.length;
        iconsMatchStats.displayed = iconsResultState.rendered;
        iconsMatchStats.truncated = iconsResultState.rendered < iconsMatchStats.total;
        updateIconsStatus();
      }

      function updateIconsResults() {
        if (!els.iconsResults || !els.iconsHint) return;
        if (iconsCache.loading) {
          els.iconsResults.innerHTML = '';
          setIconsHint('Loading icon data...', true);
          updateIconsStatus();
          return;
        }
        if (iconsCache.error && !iconsCache.entries.length) {
          els.iconsResults.innerHTML = '';
          setIconsHint(`Failed to load icons: ${iconsCache.error}`, true);
          updateIconsStatus();
          return;
        }
        const trimmed = iconsQuery.trim();
        if (!trimmed) {
          els.iconsResults.innerHTML = '';
          setIconsHint('Type to search. Click a result to copy its MkDocs shortcode.', true);
          updateIconsStatus();
          return;
        }
        const matches = filterIconsResults(trimmed, iconsFilter);
        if (!matches.length) {
          iconsMatchStats = { total: 0, displayed: 0, truncated: false };
          iconsResultState = { entries: [], rendered: 0 };
          els.iconsResults.innerHTML = '';
          setIconsHint('No matches found.', true);
          updateIconsStatus(`Matches: 0`);
          return;
        }
        setIconsHint('', false);
        const total = matches.length;
        iconsMatchStats = { total, displayed: 0, truncated: total > 0 };
        iconsResultState = { entries: matches, rendered: 0 };
        els.iconsResults.innerHTML = '';
        renderNextIconsBatch();
      }

      async function loadIconsData(force) {
        if (iconsCache.loading) return;
        if (iconsCache.loaded && !force) return;
        iconsCache.loading = true;
        iconsCache.error = '';
        updateIconsResults();
        try {
          const data = await fetchJson(iconsearchIndexUrl);
          const entries = normalizeIndexEntries(data);
          iconsCache.entries = entries;
          iconsCache.loaded = entries.length > 0;
          iconsCache.counts.icons = entries.filter((entry) => entry.type === 'icon').length;
          iconsCache.counts.emojis = entries.filter((entry) => entry.type === 'emoji').length;
          if (!entries.length) iconsCache.error = 'Index empty or invalid.';
        } catch (e) {
          iconsCache.error = e.message || 'Index load failed.';
          iconsCache.entries = [];
          iconsCache.loaded = false;
        } finally {
          iconsCache.loading = false;
          updateIconsResults();
        }
      }

      async function confirmUnsavedClose() {
        if (!editorState.dirty) return true;
        return showConfirm('Unsaved changes in Simple Edit. Close without saving?', {
          title: 'Unsaved Changes',
          okText: 'Close',
          cancelText: 'Cancel'
        });
      }

      function escapeHtml(text) {
        return String(text || '')
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
      }

      function highlightMarkdown(source) {
        const lines = String(source || '').split('\n');
        const out = lines.map((line, idx) => {
          const escaped = escapeHtml(line);
          let rendered = escaped;
          const headingMatch = line.match(/^(\s{0,3})(#{1,6})\s+(.+)$/);
          if (headingMatch) {
            const lead = headingMatch[1] || '';
            const hashes = headingMatch[2] || '';
            const title = escapeHtml(headingMatch[3] || '');
            rendered = `${lead}<span class="md-hash">${hashes}</span> <span class="md-heading">${title}</span>`;
          } else {
            rendered = rendered.replace(/\*\*([^*]+)\*\*/g, '<span class="md-bold">**$1**</span>');
            rendered = rendered.replace(/`([^`]+)`/g, '<span class="md-code">`$1`</span>');
            rendered = rendered.replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<span class="md-link">[$1]($2)</span>');
            rendered = rendered.replace(/^\s*[-*+]\s+/, (m) => `<span class="md-list">${m}</span>`);
          }
          const cls = 'md-line';
          const body = rendered === '' ? '&nbsp;' : rendered;
          return `<div class="${cls}">${body}</div>`;
        });
        if (!out.length) return '';
        return out.join('');
      }

      function buildLineNumbers(lines, originals) {
        const total = Math.max(lines.length, 1);
        const out = [];
        let added = 0;
        let modified = 0;
        for (let i = 0; i < total; i += 1) {
          const no = i + 1;
          const line = lines[i] ?? '';
          const original = originals && typeof originals[i] === 'string' ? originals[i] : '';
          const isNew = originals && i >= originals.length;
          const isModified = !isNew && line !== original;
          const cls = isNew ? 'line-no added' : (isModified ? 'line-no modified' : 'line-no');
          const mark = isNew ? '+' : (isModified ? '~' : '');
          if (isNew) added += 1;
          if (isModified) modified += 1;
          out.push(
            `<div class="${cls}">` +
            `<span class="line-no-mark">${mark}</span>` +
            `<span class="line-no-label">${no}</span>` +
            `</div>`
          );
        }
        const deleted = originals && originals.length > lines.length ? originals.length - lines.length : 0;
        return { html: out.join(''), added, modified, deleted };
      }

      function syncEditorHighlight() {
        if (!els.simpleEditInput || !els.simpleEditHighlight) return;
        const lines = String(els.simpleEditInput.value || '').split('\n');
        const originals = Array.isArray(editorState.originalLines) ? editorState.originalLines : [];
        els.simpleEditHighlight.innerHTML = highlightMarkdown(els.simpleEditInput.value);
        if (els.simpleEditLines) {
          const info = buildLineNumbers(lines, originals);
          els.simpleEditLines.innerHTML = info.html;
          if (els.simpleEditDiff) {
            const add = info.added || 0;
            const mod = info.modified || 0;
            const del = info.deleted || 0;
            els.simpleEditDiff.textContent = add || mod || del ? `+${add} ~${mod} -${del}` : '';
          }
        }
      }

      function syncEditorScroll() {
        if (!els.simpleEditInput || !els.simpleEditHighlight) return;
        els.simpleEditHighlight.scrollTop = els.simpleEditInput.scrollTop;
        els.simpleEditHighlight.scrollLeft = els.simpleEditInput.scrollLeft;
        if (els.simpleEditLines) els.simpleEditLines.scrollTop = els.simpleEditInput.scrollTop;
      }

      function updateEditorControls() {
        if (els.simpleEditFile) els.simpleEditFile.textContent = editorState.currentFile || '(no file)';
      }

      function resetSimpleEditorState() {
        editorState.currentFile = '';
        editorState.dirty = false;
        editorState.originalLines = [];
        if (els.simpleEditInput) els.simpleEditInput.value = '';
        syncEditorHighlight();
        syncEditorScroll();
        updateEditorControls();
      }

      async function loadEditorFile(file) {
        if (!file) return;
        try {
          const data = await fetchJson('/api/read_file', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ file })
          });
          editorState.currentFile = data.file || file;
          editorState.dirty = false;
          editorState.originalLines = String(data.content || '').split('\n');
          if (els.simpleEditInput) {
            els.simpleEditInput.value = data.content || '';
            syncEditorHighlight();
            syncEditorScroll();
          }
          updateEditorControls();
        } catch (e) {
          setStatus(e.message || 'Failed to load file.', 'error');
        }
      }

      async function saveSimpleEditor() {
        if (!editorState.currentFile) {
          setStatus('‚ö†Ô∏è No file loaded.', 'info');
          return false;
        }
        try {
          await fetchJson('/api/write_file', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ file: editorState.currentFile, content: els.simpleEditInput.value })
          });
          editorState.dirty = false;
          editorState.originalLines = String(els.simpleEditInput.value || '').split('\n');
          syncEditorHighlight();
          setStatus('‚úÖ Saved.', 'success');
          return true;
        } catch (e) {
          setStatus(e.message || '‚õîÔ∏è Save failed.', 'error');
          return false;
        }
      }

      const maybeLoadEditorFromSelectionImpl = async () => {
        if (!els.simpleEditor || els.simpleEditor.hidden) return;
        const file = resolveSelectedFile('');
        if (!file || file === editorState.currentFile) return;
        if (editorState.dirty) {
          const choice = await showChoice({
            title: 'Unsaved Changes',
            message: 'You have unsaved changes. What would you like to do?',
            cancelValue: 'cancel',
            buttons: [
              { label: 'Save', value: 'save', primary: true },
              { label: 'Abort Edit', value: 'discard' },
              { label: 'Cancel', value: 'cancel', ghost: true }
            ]
          });
          const action = choice ? choice.value : 'cancel';
          if (action === 'save') {
            const ok = await saveSimpleEditor();
            if (!ok) return;
          } else if (action === 'discard') {
            editorState.dirty = false;
          } else {
            setStatus('Switch canceled.', 'info');
            return;
          }
        }
        loadEditorFile(file);
      };
      maybeLoadEditorFromSelection = maybeLoadEditorFromSelectionImpl;

      function openSimpleEditor(file) {
        if (!els.simpleEditor) return;
        setSimpleEditorVisible(true);
        loadEditorFile(file);
      }

      const openSimpleEditorFromSelection = () => {
        const id = selectedId || (selectedIds && selectedIds.size ? Array.from(selectedIds)[0] : '');
        if (!id && selectedDisplaySlotFolderId) {
          const found = findNode(stateTree, selectedDisplaySlotFolderId);
          const file = found && found.node ? getFileForNode(found.node) : '';
          if (file) return openSimpleEditor(file);
        }
        if (!id) return setStatus('‚ö†Ô∏è No page selected to edit.', 'info');
        const found = findNode(stateTree, id);
        if (!found) return setStatus('‚ö†Ô∏è Selected node not in tree.', 'info');
        const file = getFileForNode(found.node);
        if (!file) return setStatus('‚ö†Ô∏è Selected node has no associated file to edit.', 'info');
        openSimpleEditor(file);
      };
      if (els.simpleEditBtn) els.simpleEditBtn.addEventListener('click', openSimpleEditorFromSelection);

      const hideTreeContext = () => {
        if (!els.treeContext) return;
        els.treeContext.hidden = true;
        treeContextOpen = false;
      };

      const positionTreeContext = (x, y) => {
        if (!els.treeContext) return;
        els.treeContext.hidden = false;
        treeContextOpen = true;
        const menu = els.treeContext;
        const padding = 12;
        const maxX = window.innerWidth - padding;
        const maxY = window.innerHeight - padding;
        menu.style.left = `${Math.min(x, maxX)}px`;
        menu.style.top = `${Math.min(y, maxY)}px`;
        const rect = menu.getBoundingClientRect();
        if (rect.right > maxX) menu.style.left = `${Math.max(padding, maxX - rect.width)}px`;
        if (rect.bottom > maxY) menu.style.top = `${Math.max(padding, maxY - rect.height)}px`;
      };

      const updateTreeContextState = () => {
        if (!els.treeContext) return;
        const hasSelection = !!selectedId || (selectedIds && selectedIds.size) || !!selectedDisplaySlotFolderId;
        const hasFile = !!resolveSelectedFile('');
        const buttons = Array.from(els.treeContext.querySelectorAll('button[data-action]'));
        buttons.forEach((btn) => {
          const action = btn.dataset.action || '';
          let enabled = true;
          if (action === 'rename') enabled = !!selectedId;
          if (action === 'delete') enabled = !!selectedId || (selectedIds && selectedIds.size);
          if (action === 'locate' || action === 'open' || action === 'open-web' || action === 'edit') enabled = hasFile;
          if (!hasSelection && (action === 'rename' || action === 'delete' || action === 'locate' || action === 'open' || action === 'open-web' || action === 'edit')) enabled = false;
          btn.disabled = !enabled;
        });
      };

      updateTreeActionButtons = () => {
        const hasSelection = !!selectedId || (selectedIds && selectedIds.size) || !!selectedDisplaySlotFolderId;
        const hasFile = !!resolveSelectedFile('');
        if (els.deleteBtn) els.deleteBtn.disabled = !(selectedId || (selectedIds && selectedIds.size));
        if (els.treeLocateBtn) els.treeLocateBtn.disabled = !hasFile;
        if (els.openFileBtn) els.openFileBtn.disabled = !hasFile;
        if (els.openDocWebBtn) els.openDocWebBtn.disabled = !hasFile;
        if (els.simpleEditBtn) els.simpleEditBtn.disabled = !hasFile;
        if (!hasSelection && els.deleteBtn) els.deleteBtn.disabled = true;
      };

      const selectContextTarget = (target) => {
        if (!target) return;
        if (target.classList.contains('overview-inline')) {
          const overviewId = target.dataset.overviewId || '';
          const folderId = target.dataset.folderId || '';
          if (overviewId) {
            if (!(selectedIds && selectedIds.size && selectedIds.has(overviewId))) selectNode(overviewId);
          } else if (folderId) {
            selectedId = '';
            selectedIds = new Set();
            selectionAnchorId = '';
            selectionParentKey = '';
            selectedDisplaySlotFolderId = folderId;
            syncSelectionClasses();
            if (typeof updateInfo === 'function') updateInfo();
          }
          return;
        }
        const id = target.dataset.id || '';
        if (!id) return;
        if (selectedIds && selectedIds.size && selectedIds.has(id)) return;
        selectNode(id);
      };

      if (els.tree) {
        els.tree.addEventListener('contextmenu', (e) => {
          const target = e.target.closest('#tree li.node, #tree .overview-inline');
          if (!target) return;
          e.preventDefault();
          if (activeInlineEdit) return;
          selectContextTarget(target);
          updateTreeContextState();
          positionTreeContext(e.clientX, e.clientY);
        });
      }

      if (els.treeContext) {
        els.treeContext.addEventListener('click', (e) => {
          const btn = e.target.closest('button[data-action]');
          if (!btn || btn.disabled) return;
          const action = btn.dataset.action || '';
          if (action === 'new-folder') createNode('folder');
          if (action === 'new-page') createNode('page');
          if (action === 'new-page-with-folder') createPageWithFolder();
          if (action === 'rename') renameSelected();
          if (action === 'delete') deleteSelected();
          if (action === 'locate') locateSelectedInSource();
          if (action === 'open') openSelectedFile();
          if (action === 'open-web') openSelectedDocWeb();
          if (action === 'edit') openSimpleEditorFromSelection();
          hideTreeContext();
        });
      }

      document.addEventListener('pointerdown', (e) => {
        if (!treeContextOpen) return;
        if (!els.treeContext) return;
        if (e.target && els.treeContext.contains(e.target)) return;
        hideTreeContext();
      });

      window.addEventListener('scroll', () => {
        if (treeContextOpen) hideTreeContext();
      }, { passive: true });

      window.addEventListener('keydown', (e) => {
        if (!treeContextOpen) return;
        if (e.key === 'Escape') hideTreeContext();
      });

      if (els.simpleEditClose) els.simpleEditClose.addEventListener('click', async () => {
        const ok = await confirmUnsavedClose();
        if (!ok) return;
        setSimpleEditorVisible(false);
        resetSimpleEditorState();
        clearSelection();
      });

      if (els.simpleEditAbort) els.simpleEditAbort.addEventListener('click', async () => {
        if (!editorState.currentFile) return setStatus('‚ö†Ô∏è No file loaded.', 'info');
        if (editorState.dirty) {
          const ok = await showConfirm('Discard changes and reload the file?', {
            title: 'Abort Edit',
            okText: 'Discard',
            cancelText: 'Cancel'
          });
          if (!ok) return;
        }
        loadEditorFile(editorState.currentFile);
      });

      if (els.simpleEditSave) els.simpleEditSave.addEventListener('click', saveSimpleEditor);

      if (els.simpleEditInput) {
        els.simpleEditInput.addEventListener('input', () => {
          editorState.dirty = true;
          syncEditorHighlight();
        });
        els.simpleEditInput.addEventListener('scroll', syncEditorScroll);
      }

      window.addEventListener('beforeunload', (e) => {
        if (!editorState.dirty) return;
        e.preventDefault();
        e.returnValue = '';
      });

      if (els.toggleSimpleEditor) els.toggleSimpleEditor.addEventListener('click', () => {
        if (!els.simpleEditor) return;
        const willShow = els.simpleEditor.hidden;
        setSimpleEditorVisible(willShow);
        if (!willShow) {
          resetSimpleEditorState();
          clearSelection();
          return;
        }
        if (editorState.currentFile) {
          updateEditorControls();
          return;
        }
        const id = selectedId || (selectedIds && selectedIds.size ? Array.from(selectedIds)[0] : '');
        if (id) {
          const found = findNode(stateTree, id);
          if (found && found.node) {
            const file = getFileForNode(found.node);
            if (file) return openSimpleEditor(file);
          }
        }
        setStatus('‚ö†Ô∏è Simple Edit opened. Select a page and click üßæ Edit to load it.', 'info');
      });

      if (els.toggleIconsPanel) els.toggleIconsPanel.addEventListener('click', async () => {
        if (!els.iconsPanel) return;
        const willShow = els.iconsPanel.hidden;
        setIconsPanelVisible(willShow);
        if (!willShow) return;
        await loadIconsData(false);
        if (els.iconsSearchInput) {
          els.iconsSearchInput.focus();
          els.iconsSearchInput.select();
        }
      });

      if (els.iconsClose) els.iconsClose.addEventListener('click', () => {
        setIconsPanelVisible(false);
      });

      if (els.iconsReload) els.iconsReload.addEventListener('click', async () => {
        iconsCache.loaded = false;
        iconsCache.entries = [];
        await loadIconsData(true);
        if (els.iconsSearchInput) {
          els.iconsSearchInput.focus();
          els.iconsSearchInput.select();
        }
      });

      if (els.iconsSearchInput) {
        els.iconsSearchInput.addEventListener('input', (e) => {
          iconsQuery = e.target && typeof e.target.value === 'string' ? e.target.value : '';
          updateIconsResults();
        });
      }

      const iconsFilterButtons = [els.iconsFilterAll, els.iconsFilterIcons, els.iconsFilterEmojis].filter(Boolean);
      iconsFilterButtons.forEach((btn) => {
        btn.addEventListener('click', () => {
          iconsFilter = btn.dataset.filter || 'all';
          iconsFilterButtons.forEach((b) => b.classList.toggle('active', b === btn));
          updateIconsResults();
        });
      });

      if (els.iconsResults) {
        els.iconsResults.addEventListener('click', async (e) => {
          const item = e.target && e.target.closest ? e.target.closest('.icons-item') : null;
          if (!item) return;
          const markup = item.dataset.markup || '';
          if (!markup) return;
          try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(markup);
              setStatus(`Copied ${markup}`, 'success');
            } else {
              setStatus('Clipboard unavailable.', 'info');
            }
          } catch (err) {
            setStatus('Copy failed.', 'error');
          }
        });
        els.iconsResults.addEventListener('scroll', () => {
          if (!iconsResultState.entries.length) return;
          const threshold = 120;
          if (els.iconsResults.scrollTop + els.iconsResults.clientHeight >= els.iconsResults.scrollHeight - threshold) {
            renderNextIconsBatch();
          }
        });
      }

      if (els.mkdocsStartBtn) {
        els.mkdocsStartBtn.addEventListener('click', async () => {
          try {
            const data = await fetchJson('/api/mkdocs/start', { method: 'POST' });
            setMkdocsStatus(data);
            setMkdocsLog(data);
          } catch (e) {
            setMkdocsStatus({ state: 'error', running: false, message: e.message || 'MkDocs start failed' });
            setMkdocsLog({ logs: [e.message || 'MkDocs start failed'] });
          }
        });
      }
      if (els.mkdocsStopBtn) {
        els.mkdocsStopBtn.addEventListener('click', async () => {
          try {
            const data = await fetchJson('/api/mkdocs/stop', { method: 'POST' });
            setMkdocsStatus(data);
            setMkdocsLog(data);
          } catch (e) {
            setMkdocsStatus({ state: 'error', running: false, message: e.message || 'MkDocs stop failed' });
            setMkdocsLog({ logs: [e.message || 'MkDocs stop failed'] });
          }
        });
      }
      if (els.mkdocsOpenBtn) {
        els.mkdocsOpenBtn.addEventListener('click', async () => {
          const available = await ensureMkdocsUrlAvailable(mkdocsServeUrl);
          if (!available) {
            return setStatus('‚ö†Ô∏è MkDocs site not reachable. Please run `mkdocs serve` first.', 'info');
          }
          openMkdocsUrl(mkdocsServeUrl);
        });
      }

      if (els.simpleEditor) {
        const header = els.simpleEditor.querySelector('.card-head');
        let drag = null;
        const onMove = (e) => {
          if (!drag || !els.simpleEditor) return;
          const x = e.clientX - drag.offsetX;
          const y = e.clientY - drag.offsetY;
          const maxX = window.innerWidth - drag.width - 8;
          const maxY = window.innerHeight - drag.height - 8;
          const clampedX = Math.min(Math.max(x, 8), Math.max(8, maxX));
          const clampedY = Math.min(Math.max(y, 8), Math.max(8, maxY));
          els.simpleEditor.style.left = `${clampedX}px`;
          els.simpleEditor.style.top = `${clampedY}px`;
        };
        const onUp = () => {
          if (!drag) return;
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('pointerup', onUp);
          drag = null;
        };
        if (header) {
          header.addEventListener('pointerdown', (e) => {
            if (e.button !== 0) return;
            if (e.target && e.target.closest('button')) return;
            if (!els.simpleEditor) return;
            const rect = els.simpleEditor.getBoundingClientRect();
            els.simpleEditor.style.left = `${rect.left}px`;
            els.simpleEditor.style.top = `${rect.top}px`;
            els.simpleEditor.style.right = 'auto';
            els.simpleEditor.style.bottom = 'auto';
            drag = {
              offsetX: e.clientX - rect.left,
              offsetY: e.clientY - rect.top,
              width: rect.width,
              height: rect.height
            };
            window.addEventListener('pointermove', onMove);
            window.addEventListener('pointerup', onUp);
          });
        }
      }

      if (els.iconsPanel) {
        const header = els.iconsPanel.querySelector('.card-head');
        let drag = null;
        const onMove = (e) => {
          if (!drag || !els.iconsPanel) return;
          const x = e.clientX - drag.offsetX;
          const y = e.clientY - drag.offsetY;
          const maxX = window.innerWidth - drag.width - 8;
          const maxY = window.innerHeight - drag.height - 8;
          const clampedX = Math.min(Math.max(x, 8), Math.max(8, maxX));
          const clampedY = Math.min(Math.max(y, 8), Math.max(8, maxY));
          els.iconsPanel.style.left = `${clampedX}px`;
          els.iconsPanel.style.top = `${clampedY}px`;
        };
        const onUp = () => {
          if (!drag) return;
          window.removeEventListener('pointermove', onMove);
          window.removeEventListener('pointerup', onUp);
          drag = null;
        };
        if (header) {
          header.addEventListener('pointerdown', (e) => {
            if (e.button !== 0) return;
            if (e.target && e.target.closest('button, input')) return;
            if (!els.iconsPanel) return;
            const rect = els.iconsPanel.getBoundingClientRect();
            els.iconsPanel.style.left = `${rect.left}px`;
            els.iconsPanel.style.top = `${rect.top}px`;
            els.iconsPanel.style.right = 'auto';
            els.iconsPanel.style.bottom = 'auto';
            drag = {
              offsetX: e.clientX - rect.left,
              offsetY: e.clientY - rect.top,
              width: rect.width,
              height: rect.height
            };
            window.addEventListener('pointermove', onMove);
            window.addEventListener('pointerup', onUp);
          });
        }
      }

      window.addEventListener('keydown', (e) => {
        if (activeInlineEdit) return;
        // Clear located highlight on navigation keys or when selection changes
        const navKeys = ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Enter','Delete','Backspace','PageUp','PageDown','Home','End'];
        if (navKeys.includes(e.key)) clearLocatedSource();
        if (e.key === 'Escape') {
          clearSelection();
        }
      });

      initMkdocsStream();

	      dragMode = localStorage.getItem('page_tree_drag_mode') || 'sync_files';
	      updateDragModeSwitch();
	      loadMeta();
	      await loadUiState();
	      // Default: auto-load mkdocs.yml on entry. If invalid, block rendering.
	      await bootstrap();
		    });

		    function onDragModeToggle() {
		      if (!els.dragModeToggle) return;
		      dragMode = els.dragModeToggle.checked ? 'sync_files' : 'nav_only';
		      localStorage.setItem('page_tree_drag_mode', dragMode);
		      updateDragModeSwitch();
		      setStatus(dragMode === 'nav_only' ? '‚õìÔ∏è‚Äçüí• Drag: Nav only' : '‚õìÔ∏è Drag: Nav + Files', 'info');
		    }

		    function updateDragModeSwitch() {
		      const isFiles = dragMode === 'sync_files';
		      if (els.dragModeToggle) els.dragModeToggle.checked = isFiles;
		      if (els.dragModeText) els.dragModeText.textContent = isFiles ? 'Drag: Files' : 'Drag: Nav';
		      if (els.dragModeSwitch) {
		        els.dragModeSwitch.dataset.help = isFiles
		          ? 'Drag & drop updates mkdocs.yml and moves files on disk'
		          : 'Drag & drop updates mkdocs.yml nav only (no file moves)';
		        els.dragModeSwitch.title = els.dragModeSwitch.dataset.help;
		      }
		    }

		    async function bootstrap() {
		      setStatus('‚è≥ Loading mkdocs.yml...', 'info');
		      try {
		        const data = await fetchJson('/api/import', { method: 'POST' });
	        stateTree = Array.isArray(data.tree) ? data.tree : [];
	        const warnings = Array.isArray(data.warnings) ? data.warnings : [];
	        lastPersistedSignature = treeSignature(stateTree);
	        resetHistory();
	        renderTree();
	        updateHistoryButtons();
	        await loadSource();
	        setStatus(warnings.length ? `‚ö†Ô∏è Loaded with warnings (${warnings.length}).` : '‚úÖ Loaded from mkdocs.yml.', warnings.length ? 'info' : 'success');
		      } catch (e) {
		        const data = e && e.data ? e.data : null;
		        if (data && Array.isArray(data.errors)) {
		          const count = data.errors.length;
		          setStatus(`‚õîÔ∏è Import blocked: ${count} invalid/missing doc path(s).`, 'error');
		          pushDebug('import.blocked', { errors: data.errors });
		          showImportErrors(data);
		          if (els.tree) els.tree.textContent = 'Blocked: invalid mkdocs.yml paths.';
		          if (els.source) els.source.textContent = 'Blocked.';
		          clearSelection();
		          return;
		        }
		        setStatus(`‚õîÔ∏è ${e.message || 'Import failed.'}`, 'error');
		        if (els.tree) els.tree.textContent = 'Failed to load tree.';
		      }
		    }

    function initTheme() {
      theme = localStorage.getItem('page_tree_theme') || 'dark';
      applyTheme();
      
      // Initialize rainbow colors state
      const rainbowEnabled = localStorage.getItem('page_tree_rainbow_colors') === 'true';
      document.body.classList.toggle('rainbow-colors', rainbowEnabled);
      if (els.rainbowToggleBtn) {
        els.rainbowToggleBtn.style.opacity = rainbowEnabled ? '1' : '0.5';
      }
    }

    function toggleTheme() {
      theme = theme === 'light' ? 'dark' : 'light';
      localStorage.setItem('page_tree_theme', theme);
      applyTheme();
    }

    function applyTheme() {
      document.body.classList.toggle('theme-light', theme === 'light');
      pushDebug('theme.set', { theme });
    }

    function toggleRainbowColors() {
      const rainbowEnabled = document.body.classList.toggle('rainbow-colors');
      localStorage.setItem('page_tree_rainbow_colors', rainbowEnabled ? 'true' : 'false');
      if (els.rainbowToggleBtn) {
        els.rainbowToggleBtn.style.opacity = rainbowEnabled ? '1' : '0.5';
      }
      pushDebug('rainbow.toggle', { enabled: rainbowEnabled });
    }

    function applyPanelVisibility() {
      if (els.panelTools) els.panelTools.hidden = !showTools;
      if (els.panelSource) els.panelSource.hidden = !showSource;
      if (els.panelTree) els.panelTree.hidden = !showTree;
      if (els.panelInfo) els.panelInfo.hidden = !showInfo;
      if (els.splitMainLeft) els.splitMainLeft.style.display = (showSource && showTree) ? '' : 'none';
      if (els.splitBottom) els.splitBottom.style.display = showInfo ? '' : 'none';
      if (els.bottomStack) els.bottomStack.hidden = !showInfo;

      if (els.workspace) {
        els.workspace.classList.toggle('no-tools', !showTools);
        els.workspace.classList.toggle('no-source', !showSource);
        els.workspace.classList.toggle('no-tree', !showTree);
        els.workspace.classList.toggle('no-bottom', !showInfo);
        const singleMain = (showSource ? 1 : 0) + (showTree ? 1 : 0) === 1;
        els.workspace.classList.toggle('single-main', singleMain);
      }

      if (els.toggleTools) els.toggleTools.classList.toggle('active', showTools);
      if (els.toggleSource) els.toggleSource.classList.toggle('active', showSource);
      if (els.toggleTree) els.toggleTree.classList.toggle('active', showTree);
      if (els.toggleInfo) els.toggleInfo.classList.toggle('active', showInfo);
    }

    function bindToolHoverHints() {
      toolTipEl = document.getElementById('tool-tooltip');
      const buttons = document.querySelectorAll('[data-help]');
      buttons.forEach(btn => {
        btn.addEventListener('mouseenter', (e) => {
          const text = btn.dataset.help || '';
          const shortcut = btn.dataset.shortcut || '';
          setInfoHover(text);
          showToolTip(text, shortcut, e);
        });
        btn.addEventListener('mousemove', (e) => {
          moveToolTip(e);
        });
        btn.addEventListener('mouseleave', () => {
          setInfoHover('');
          hideToolTip();
        });
      });
    }

	    function scheduleAutoSync(reason, modeOverride) {
	      if (autoSyncTimer) clearTimeout(autoSyncTimer);
	      const mode = modeOverride || 'sync_files';
	      autoSyncTimer = setTimeout(async () => {
	        autoSyncTimer = null;
	        pushDebug('auto_sync.run', { mode, reason });
	        await sync(mode, { confirm: false, silent: true });
	      }, 250);
	    }

	    function scheduleNavOnly(reason) {
	      return scheduleAutoSync(reason, 'nav_only');
	    }

    function showToolTip(text, shortcut, e) {
      if (!toolTipEl) return;
      const value = (text || '').trim();
      if (!value) return;
      toolTipEl.textContent = shortcut ? `${value} (${shortcut})` : value;
      toolTipEl.hidden = false;
      moveToolTip(e);
    }

    function moveToolTip(e) {
      if (!toolTipEl || toolTipEl.hidden) return;
      const pad = 12;
      const maxLeft = window.innerWidth - toolTipEl.offsetWidth - pad;
      const maxTop = window.innerHeight - toolTipEl.offsetHeight - pad;
      const left = Math.min(e.clientX + pad, Math.max(pad, maxLeft));
      const top = Math.min(e.clientY + pad, Math.max(pad, maxTop));
      toolTipEl.style.left = `${left}px`;
      toolTipEl.style.top = `${top}px`;
    }

    function hideToolTip() {
      if (!toolTipEl) return;
      toolTipEl.hidden = true;
      toolTipEl.textContent = '';
    }

    function toggleSourceView() {
      sourceView = sourceView === 'ascii' ? 'list' : 'ascii';
      localStorage.setItem('page_tree_source_view', sourceView);
      updateSourceViewButton();
      renderSource();
    }

    function bindDepthButtons() {
      const buttons = document.querySelectorAll('.depth-btn');
      buttons.forEach(btn => {
        btn.addEventListener('click', () => {
          const depth = btn.dataset.depth || 'n';
          if (depth === 'n') {
            toggleExpandAll();
          } else {
            const maxLevel = parseInt(String(depth), 10);
            if (Number.isFinite(maxLevel) && maxLevel > 0) {
              lastDepthValue = maxLevel;
              applyDepthLimitToCollapsed(maxLevel);
              lastDepthAction = String(maxLevel);
            }
          }
          updateDepthButtons();
          renderTree();
          scheduleUiStateSave();
        });
      });
    }

    function updateDepthButtons() {
      const buttons = document.querySelectorAll('.depth-btn');
      buttons.forEach(btn => {
        btn.classList.toggle('active', (btn.dataset.depth || '') === String(lastDepthAction || ''));
      });
    }

    function applyDepthLimitToCollapsed(maxLevel) {
      const level = parseInt(String(maxLevel), 10);
      if (!Number.isFinite(level) || level <= 0) return;
      const next = new Set();
      const walk = (nodes, depth, segs, titles) => {
        for (const node of (nodes || [])) {
          if (!node || node.type !== 'folder') continue;
          const collapseKey = collapseKeyForNode(node, segs, titles);
          if (collapseKey && depth >= level - 1) next.add(collapseKey);
          const nextSegs = String((node.segment || '')).trim()
            ? segs.concat([String(node.segment).trim()])
            : segs;
          const nextTitles = titles.concat([displayTitleForNode(node)]);
          if (Array.isArray(node.children)) walk(node.children, depth + 1, nextSegs, nextTitles);
        }
      };
      walk(stateTree, 0, [], []);
      treeCollapsed = next;
      persistTreeCollapsed();
    }

    function toggleExpandAll() {
      const baseDepth = parseInt(String(lastDepthValue || 5), 10);
      const targetDepth = Number.isFinite(baseDepth) && baseDepth > 0 ? baseDepth : 5;
      if (String(lastDepthAction || '') === String(targetDepth)) {
        treeCollapsed = new Set();
        persistTreeCollapsed();
        lastDepthAction = 'n';
        return;
      }
      if (String(lastDepthAction || '') === 'n') {
        applyDepthLimitToCollapsed(targetDepth);
        lastDepthAction = String(targetDepth);
        return;
      }
      treeCollapsed = new Set();
      persistTreeCollapsed();
      lastDepthAction = 'n';
    }

    function updateSourceViewButton() {
      if (!els.sourceViewBtn) return;
      els.sourceViewBtn.classList.toggle('active', sourceView === 'ascii');
      // Show the view you can switch to.
      els.sourceViewBtn.textContent = sourceView === 'ascii' ? 'üóÇ Explorer' : 'üßæ ASCII';
    }

    function deepClone(value) {
      return JSON.parse(JSON.stringify(value));
    }

    function persistScrollPosition(key, el) {
      if (!el || !key) return;
      localStorage.setItem(key, String(el.scrollTop || 0));
      scheduleUiStateSave();
    }

    function restoreScrollPosition(key, el) {
      if (!el || !key) return;
      const raw = localStorage.getItem(key);
      const value = parseInt(String(raw || '0'), 10);
      if (!Number.isFinite(value)) return;
      el.scrollTop = value;
    }

    function scheduleUiStateSave() {
      if (!uiStateLoaded) return;
      if (uiStateSaving) {
        uiStateSavePending = true;
        return;
      }
      const now = Date.now();
      const elapsed = now - uiStateLastSavedAt;
      if (elapsed >= 3000) {
        if (uiStateSaveTimer) {
          clearTimeout(uiStateSaveTimer);
          uiStateSaveTimer = null;
        }
        saveUiState();
        return;
      }
      const delay = Math.max(3000 - elapsed, 50);
      if (uiStateSaveTimer) return;
      uiStateSaveTimer = setTimeout(() => {
        uiStateSaveTimer = null;
        saveUiState();
      }, delay);
    }

    async function saveUiState() {
      if (!uiStateLoaded) return;
      if (uiStateSaving) {
        uiStateSavePending = true;
        return;
      }
      uiStateSaving = true;
      uiStateLastSavedAt = Date.now();
      const payload = buildUiState();
      try {
        await fetchJson('/api/ui_state', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
      } catch (e) {
        // Ignore UI state save failures.
      } finally {
        uiStateSaving = false;
        if (uiStateSavePending) {
          uiStateSavePending = false;
          scheduleUiStateSave();
        }
      }
    }

    async function loadUiState() {
      try {
        const data = await fetchJson('/api/ui_state');
        if (data && typeof data === 'object') {
          uiState = data;
          applyUiState(uiState);
        }
      } catch (e) {
        uiState = {};
      }
      uiStateLoaded = true;
    }

    function applyUiState(state) {
      if (!state || typeof state !== 'object') return;
      if (Array.isArray(state.tree_collapsed)) {
        treeCollapsed = new Set(state.tree_collapsed);
        normalizeTreeCollapsed();
        persistTreeCollapsed();
      }
      if (Array.isArray(state.source_collapsed)) {
        sourceCollapsed = new Set(state.source_collapsed);
        persistSourceCollapsed();
      }
      if (Number.isFinite(state.last_depth_value)) {
        lastDepthValue = state.last_depth_value;
      }
      if (typeof state.last_depth_action === 'string') {
        lastDepthAction = state.last_depth_action;
        updateDepthButtons();
      }
      if (state.tree_anchor || Number.isFinite(state.tree_scroll)) {
        pendingTreeRestore = true;
      }
      if (state.source_anchor || Number.isFinite(state.source_scroll)) {
        pendingSourceRestore = true;
      }
    }

    function treeSignature(tree) {
      try {
        return JSON.stringify(tree || []);
      } catch (e) {
        return String(Date.now());
      }
    }

    function isDirty() {
      return treeSignature(stateTree) !== lastPersistedSignature;
    }

    function updateHistoryButtons() {
      if (els.toolUndoBtn) els.toolUndoBtn.disabled = historyPast.length === 0;
      if (els.toolRedoBtn) els.toolRedoBtn.disabled = historyFuture.length === 0;
    }

    function resetHistory() {
      historyPast = [];
      historyFuture = [];
      updateHistoryButtons();
    }

    function makeSnapshot(tree, mode) {
      return { tree: deepClone(tree), dragMode: mode || dragMode || 'sync_files' };
    }

    function snapshotTree(snapshot) {
      // Back-compat: older history entries stored the tree array directly.
      if (Array.isArray(snapshot)) return snapshot;
      if (snapshot && Array.isArray(snapshot.tree)) return snapshot.tree;
      return [];
    }

    function snapshotDragMode(snapshot) {
      if (snapshot && typeof snapshot === 'object' && typeof snapshot.dragMode === 'string') return snapshot.dragMode;
      return null;
    }

    function applySnapshot(snapshot) {
      stateTree = deepClone(snapshotTree(snapshot));
      const mode = snapshotDragMode(snapshot);
      if (mode === 'nav_only' || mode === 'sync_files') {
        dragMode = mode;
        localStorage.setItem('page_tree_drag_mode', dragMode);
        updateDragModeSwitch();
      }
    }

    function pushHistorySnapshot(snapshot) {
      historyPast.push(snapshot);
      if (historyPast.length > 5) historyPast.shift();
      historyFuture = [];
      updateHistoryButtons();
      persistHistory();
    }

    function withHistory(label, mutator) {
      const before = makeSnapshot(stateTree, dragMode);
      pushHistorySnapshot(before);
      mutator();
      pushDebug('history.commit', { label });
      persistHistory();
    }

    async function withHistoryAsync(label, mutator) {
      const before = makeSnapshot(stateTree, dragMode);
      pushHistorySnapshot(before);
      await mutator();
      pushDebug('history.commit', { label });
      persistHistory();
    }

    function buildFileMap(tree) {
      const map = new Map();
      const walk = (nodes) => {
        for (const n of (nodes || [])) {
          if (!n) continue;
          if (n.type === 'page') {
            if (n.id) map.set(n.id, n.file || '');
          } else if (n.type === 'folder') {
            walk(n.children || []);
          }
        }
      };
      walk(tree || []);
      return map;
    }

    function applyFilePrevFromCurrent(targetTree, currentFileMap) {
      const walk = (nodes) => {
        for (const n of (nodes || [])) {
          if (!n) continue;
          if (n.type === 'page') {
            const cur = currentFileMap.get(n.id) || '';
            const next = n.file || '';
            if (cur && next && cur !== next) {
              n.file_prev = cur;
            } else {
              n.file_prev = null;
            }
          } else if (n.type === 'folder') {
            walk(n.children || []);
          }
        }
      };
      walk(targetTree || []);
    }

    async function undo() {
      if (!historyPast.length) {
        setStatus('Nothing to undo.', 'info');
        return;
      }
      const beforeTree = deepClone(stateTree);
      const beforePast = historyPast.slice();
      const beforeFuture = historyFuture.slice();

      const current = makeSnapshot(stateTree, dragMode);
      const previous = historyPast.pop();
      historyFuture.push(current);
      applySnapshot(previous);
      applyFilePrevFromCurrent(stateTree, buildFileMap(beforeTree));
      ensureSelectedValid();
      renderTree();
      updateHistoryButtons();
      pushDebug('history.undo', {});
      setStatus('Undoing...', 'info');
      const res = await fetchJson('/api/apply_history_step', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ before_tree: beforeTree, after_tree: stateTree }),
      });
      if (res && res.error) {
        setStatus(res.error, 'error');
      } else {
        setStatus('Undid last action.', 'success');
      }

      // If blocked, keep history consistent by rolling back.
      if (els.status && els.status.dataset.type === 'error' && String(els.status.textContent || '').includes('Sync blocked')) {
        stateTree = beforeTree;
        historyPast = beforePast;
        historyFuture = beforeFuture;
        ensureSelectedValid();
        renderTree();
        updateHistoryButtons();
        setStatus('Undo blocked by file conflict.', 'error');
        return;
      }
      persistHistory();
    }

    async function redo() {
      if (!historyFuture.length) {
        setStatus('Nothing to redo.', 'info');
        return;
      }
      const beforeTree = deepClone(stateTree);
      const beforePast = historyPast.slice();
      const beforeFuture = historyFuture.slice();

      const current = makeSnapshot(stateTree, dragMode);
      const next = historyFuture.pop();
      historyPast.push(current);
      applySnapshot(next);
      applyFilePrevFromCurrent(stateTree, buildFileMap(beforeTree));
      ensureSelectedValid();
      renderTree();
      updateHistoryButtons();
      pushDebug('history.redo', {});
      setStatus('Redoing...', 'info');
      const res = await fetchJson('/api/apply_history_step', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ before_tree: beforeTree, after_tree: stateTree }),
      });
      if (res && res.error) {
        setStatus(res.error, 'error');
      } else {
        setStatus('Redid last action.', 'success');
      }

      if (els.status && els.status.dataset.type === 'error' && String(els.status.textContent || '').includes('Sync blocked')) {
        stateTree = beforeTree;
        historyPast = beforePast;
        historyFuture = beforeFuture;
        ensureSelectedValid();
        renderTree();
        updateHistoryButtons();
        setStatus('Redo blocked by file conflict.', 'error');
        return;
      }
      persistHistory();
    }

    function persistHistory() {
      try {
        const payload = {
          version: 1,
          at: Date.now(),
          currentSig: treeSignature(stateTree),
          past: historyPast.slice(-5),
          future: historyFuture.slice(-5),
        };
        localStorage.setItem('page_tree_history', JSON.stringify(payload));
      } catch {
        // ignore
      }
    }

    function restoreHistoryIfMatching() {
      try {
        const raw = localStorage.getItem('page_tree_history');
        if (!raw) return;
        const data = JSON.parse(raw);
        if (!data || data.version !== 1) return;
        if (data.currentSig && data.currentSig === treeSignature(stateTree) && Array.isArray(data.past)) {
          historyPast = data.past.slice(-5);
          historyFuture = Array.isArray(data.future) ? data.future.slice(-5) : [];
        }
      } catch {
        // ignore
      }
    }

    function toggleDebug() {
      debugEnabled = !debugEnabled;
      updateDebugVisibility();
      pushDebug('debug.toggle', { enabled: debugEnabled });
    }

    function updateDebugVisibility() {
      if (!els.debugPanel) return;
      els.debugPanel.hidden = !debugEnabled;
      if (els.splitInfoDebug) els.splitInfoDebug.style.display = debugEnabled ? '' : 'none';
      if (els.bottomStack) els.bottomStack.classList.toggle('debug-hidden', !debugEnabled);
      if (els.toolDebugBtn) els.toolDebugBtn.classList.toggle('active', debugEnabled);
      renderDebug();
    }

    function renderDebug() {
      if (!debugEnabled) return;
      const lines = (debugLog || []).slice(-300);
      els.debugLog.textContent = lines.join('\n');
      // Always keep the latest line visible.
      requestAnimationFrame(() => {
        els.debugLog.scrollTop = els.debugLog.scrollHeight;
      });
    }

    function pushDebug(tag, payload) {
      if (!debugEnabled) return;
      const ts = new Date().toISOString().slice(11, 23);
      let detail = '';
      try {
        detail = payload === undefined ? '' : ' ' + JSON.stringify(payload);
      } catch (e) {
        detail = ' ' + String(payload);
      }
      debugLog.push(`[${ts}] ${tag}${detail}`);
      if (debugLog.length > 800) debugLog = debugLog.slice(-800);
      renderDebug();
    }

    async function copyToClipboard(text) {
      try {
        await navigator.clipboard.writeText(text);
      } catch (e) {
        const ta = document.createElement('textarea');
        ta.value = text;
        ta.style.position = 'fixed';
        ta.style.left = '-9999px';
        document.body.appendChild(ta);
        ta.focus();
        ta.select();
        document.execCommand('copy');
        ta.remove();
      }
    }

    function initSplitters() {
      if (!els.workspace) return;

      const defaults = {
        left: 360,
        bottom: 180,
        debug: 180,
        toolsLeft: 520,
      };

      const readNum = (key, fallback) => {
        const raw = localStorage.getItem(key);
        const n = raw ? parseFloat(raw) : NaN;
        return Number.isFinite(n) ? n : fallback;
      };

      const clampNum = (v, min, max) => Math.min(Math.max(v, min), max);
      const left = clampNum(readNum('page_tree_layout_left', defaults.left), 240, 820);
      const bottom = clampNum(readNum('page_tree_layout_bottom', defaults.bottom), 120, 360);
      const debugHeight = clampNum(readNum('page_tree_layout_debug', defaults.debug), 120, 360);
      const toolsLeft = clampNum(readNum('page_tree_layout_tools_left', defaults.toolsLeft), 320, 920);

      els.workspace.style.setProperty('--left-width', `${left}px`);
      els.workspace.style.setProperty('--bottom-height', `${bottom}px`);
      els.workspace.style.setProperty('--debug-height', `${debugHeight}px`);
      els.workspace.style.setProperty('--tools-left-width', `${toolsLeft}px`);

      const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
      let drag = null;

      const onMove = (e) => {
        if (!drag) return;
        const x = e.clientX;
        const y = e.clientY;

        if (drag.kind === 'left') {
          const width = clamp(x - drag.rect.left, 240, drag.max);
          els.workspace.style.setProperty('--left-width', `${width}px`);
          return;
        }
        if (drag.kind === 'bottom') {
          const height = clamp(drag.bottom - y, 120, drag.max);
          els.workspace.style.setProperty('--bottom-height', `${height}px`);
          return;
        }
        if (drag.kind === 'debug') {
          const height = clamp(drag.bottom - y, 120, drag.max);
          els.workspace.style.setProperty('--debug-height', `${height}px`);
          return;
        }
        if (drag.kind === 'tools') {
          const width = clamp(x - drag.left, 320, drag.max);
          els.workspace.style.setProperty('--tools-left-width', `${width}px`);
        }
      };

      const onUp = () => {
        if (!drag) return;
        const style = getComputedStyle(els.workspace);
        localStorage.setItem('page_tree_layout_left', parseFloat(style.getPropertyValue('--left-width')) || defaults.left);
        localStorage.setItem('page_tree_layout_bottom', parseFloat(style.getPropertyValue('--bottom-height')) || defaults.bottom);
        localStorage.setItem('page_tree_layout_debug', parseFloat(style.getPropertyValue('--debug-height')) || defaults.debug);
        localStorage.setItem('page_tree_layout_tools_left', parseFloat(style.getPropertyValue('--tools-left-width')) || defaults.toolsLeft);
        drag = null;
        document.body.classList.remove('is-resizing');
        window.removeEventListener('pointermove', onMove);
        window.removeEventListener('pointerup', onUp);
      };

      const start = (kind) => (e) => {
        e.preventDefault();
        if (kind === 'left') {
          const rect = els.workspace.querySelector('.main-grid').getBoundingClientRect();
          drag = { kind, rect, max: Math.max(240, rect.width - 520) };
        } else if (kind === 'bottom') {
          const rect = els.workspace.getBoundingClientRect();
          drag = { kind, bottom: rect.bottom, max: Math.max(120, rect.height - 320) };
        } else if (kind === 'debug') {
          const rect = els.bottomStack.getBoundingClientRect();
          drag = { kind, bottom: rect.bottom, max: Math.max(120, rect.height - 120) };
        } else if (kind === 'tools') {
          const panel = document.getElementById('panel-tools');
          const rect = panel ? panel.getBoundingClientRect() : els.workspace.getBoundingClientRect();
          drag = { kind, left: rect.left, max: Math.max(320, rect.width - 360) };
        } else {
          drag = { kind };
        }
        document.body.classList.add('is-resizing');
        window.addEventListener('pointermove', onMove);
        window.addEventListener('pointerup', onUp);
      };

      if (els.splitMainLeft) els.splitMainLeft.addEventListener('pointerdown', start('left'));
      if (els.splitBottom) els.splitBottom.addEventListener('pointerdown', start('bottom'));
      if (els.splitInfoDebug) els.splitInfoDebug.addEventListener('pointerdown', start('debug'));
      if (els.splitTools) els.splitTools.addEventListener('pointerdown', start('tools'));
    }

    async function fetchJson(url, options) {
      const response = await fetch(url, options);
      const text = await response.text();
      let data = null;
      try { data = text ? JSON.parse(text) : null; } catch (e) { data = null; }
      if (!response.ok) {
        const msg = data && typeof data.error === 'string' ? data.error : 'Request failed.';
        const err = new Error(msg);
        err.data = data;
        err.status = response.status;
        throw err;
      }
      return data;
    }

    function setMkdocsStatus(data) {
      if (!els.mkdocsStatus) return;
      const state = data && typeof data.state === 'string' ? data.state : 'stopped';
      const running = !!(data && data.running);
      const message = data && typeof data.message === 'string' ? data.message : '';
      const labelMap = {
        stopped: 'stopped',
        starting: 'rendering',
        rendering: 'rendering',
        ready: 'ready',
        error: 'error'
      };
      const label = labelMap[state] || state;
      const displayLabel = state === 'error' ? 'error' : (running ? label : 'stopped');
      els.mkdocsStatus.textContent = `MkDocs: ${displayLabel}`;
      els.mkdocsStatus.dataset.state = state === 'starting' ? 'rendering' : state;
      els.mkdocsStatus.title = message || '';
      if (els.mkdocsStartBtn) {
        els.mkdocsStartBtn.disabled = running || state === 'error' && message.includes('not found');
      }
      if (els.mkdocsStopBtn) {
        els.mkdocsStopBtn.disabled = !running;
      }
      if (state !== mkdocsLastState) {
        mkdocsLastState = state;
        const statusMap = {
          starting: ['üöÄ MkDocs starting‚Ä¶', 'info'],
          rendering: ['üåÄ MkDocs rendering‚Ä¶', 'info'],
          ready: ['‚úÖ MkDocs ready', 'success'],
          error: ['‚ùå MkDocs error', 'error'],
          stopped: ['üñ≤Ô∏è MkDocs stopped', 'info']
        };
        const entry = statusMap[state] || ['MkDocs status updated', 'info'];
        setStatus(entry[0], entry[1]);
      }
    }

    function setMkdocsLog(data) {
      if (!els.mkdocsLog) return;
      const logs = data && Array.isArray(data.logs) ? data.logs : [];
      mkdocsLogLines = logs.slice(-mkdocsLogLimit);
      const shouldStick = Math.abs(els.mkdocsLog.scrollHeight - els.mkdocsLog.scrollTop - els.mkdocsLog.clientHeight) < 8;
      els.mkdocsLog.textContent = mkdocsLogLines.join('\n');
      if (shouldStick) {
        els.mkdocsLog.scrollTop = els.mkdocsLog.scrollHeight;
      }
    }

    function appendMkdocsLog(line) {
      if (!els.mkdocsLog) return;
      const text = String(line || '').trim();
      if (!text) return;
      const shouldStick = Math.abs(els.mkdocsLog.scrollHeight - els.mkdocsLog.scrollTop - els.mkdocsLog.clientHeight) < 8;
      mkdocsLogLines.push(text);
      if (mkdocsLogLines.length > mkdocsLogLimit) mkdocsLogLines = mkdocsLogLines.slice(-mkdocsLogLimit);
      els.mkdocsLog.textContent = mkdocsLogLines.join('\n');
      if (shouldStick) {
        els.mkdocsLog.scrollTop = els.mkdocsLog.scrollHeight;
      }
    }

    function handleMkdocsEvent(raw) {
      if (!raw) return;
      if (raw.kind === 'snapshot') {
        setMkdocsStatus(raw);
        setMkdocsLog(raw);
        return;
      }
      if (raw.kind === 'status') {
        setMkdocsStatus(raw);
        return;
      }
      if (raw.kind === 'log') {
        appendMkdocsLog(raw.line);
      }
    }

    function initMkdocsStream() {
      if (mkdocsStream) return;
      try {
        mkdocsStream = new EventSource('/api/mkdocs/stream');
      } catch (e) {
        mkdocsStream = null;
        return;
      }
      mkdocsStream.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data || '{}');
          handleMkdocsEvent(data);
        } catch (e) {
          // ignore malformed events
        }
      };
      mkdocsStream.onerror = () => {
        if (mkdocsStream) mkdocsStream.close();
        mkdocsStream = null;
        setMkdocsStatus({ state: 'error', running: false, message: 'MkDocs stream disconnected' });
      };
    }

    function renderStatusHistory() {
      if (!els.status) return;
      if (statusExpanded) {
        els.status.textContent = statusHistory.join('\n');
      } else {
        els.status.textContent = statusHistory[statusHistory.length - 1] || '';
      }
    }

    function setStatus(message, type) {
      const text = String(message || '').trim();
      if (text) {
        statusHistory.push(text);
        if (statusHistory.length > 20) statusHistory = statusHistory.slice(-20);
      }
      els.status.dataset.type = type || 'info';
      renderStatusHistory();
    }

    function setStatusExpanded(next) {
      statusExpanded = !!next;
      if (els.status) els.status.classList.toggle('is-expanded', statusExpanded);
      renderStatusHistory();
    }

    function toggleStatusExpanded() {
      setStatusExpanded(!statusExpanded);
    }

    function setInfoMeta(text) {
      const value = (text || '').trim();
      if (els.infoMeta) els.infoMeta.textContent = value;
      if (els.infoMetaPill) {
        els.infoMetaPill.textContent = '';
        els.infoMetaPill.title = '';
      }
    }

    function formatSelectionPill(value) {
      const raw = (value || '').replace(/^Selection:\s*/i, '').trim();
      if (!raw) return '';
      if (raw.toLowerCase() === '(none)') return 'No selection';
      if (/^\\d+\\s+items$/i.test(raw)) return raw;
      const parts = raw.split('|').map(s => s.trim()).filter(Boolean);
      if (!parts.length) return raw;
      const kind = parts[0] || '';
      let title = '';
      let file = '';
      for (const part of parts.slice(1)) {
        if (!file && /^file:/i.test(part)) {
          file = part.replace(/^file:\s*/i, '');
          if (file.startsWith('./')) file = file.slice(2);
          continue;
        }
        if (!title) title = part;
      }
      const fileBase = file ? (file.replace(/\\\\/g, '/').split('/').pop() || file) : '';
      const out = [kind];
      if (title) out.push(title);
      if (fileBase) out.push(fileBase);
      return out.join(' ¬∑ ');
    }

    function setInfoSelection(text) {
      const value = (text || '').trim();
      if (els.infoSelection) els.infoSelection.textContent = value;
      if (els.infoSelectionPill) {
        const short = formatSelectionPill(value);
        els.infoSelectionPill.textContent = short;
        els.infoSelectionPill.title = value;
      }
    }

    function setInfoSearch(text) {
      const value = (text || '').trim();
      if (els.infoSearch) els.infoSearch.textContent = value;
      if (els.infoSearchPill && !value) {
        els.infoSearchPill.textContent = '';
        els.infoSearchPill.title = '';
      }
    }

    function updateTreeSearchInfo() {
      const query = String(treeSearchQuery || '').trim();
      if (!query) {
        setInfoSearch('');
        if (els.treeSearchCount) els.treeSearchCount.textContent = '';
        return;
      }
      const total = Array.isArray(treeSearchMatches) ? treeSearchMatches.length : 0;
      const pos = total && treeSearchIndex >= 0 ? treeSearchIndex + 1 : 0;
      const msg = total
        ? `Search: ${total} matches (${pos}/${total}) | "${query}"`
        : `Search: 0 matches | "${query}"`;
      setInfoSearch(msg);
      if (els.treeSearchCount) els.treeSearchCount.textContent = `${pos}/${total}`;
      if (els.infoSearchPill) {
        els.infoSearchPill.textContent = total ? `Search: ${pos}/${total}` : 'Search: 0/0';
        els.infoSearchPill.title = msg;
      }
    }

    function setInfoHover(text) {
      if (!els.infoHover) return;
      const value = (text || '').trim();
      if (!value) {
        els.infoHover.hidden = true;
        els.infoHover.textContent = '';
        return;
      }
      els.infoHover.hidden = false;
      els.infoHover.textContent = value;
    }

    function clearInfoErrors() {
      if (!els.infoErrors) return;
      els.infoErrors.hidden = true;
      els.infoErrors.textContent = '';
    }

    function normalizeSearchQuery(value) {
      return String(value || '').trim().toLowerCase();
    }

    function buildSearchHaystack(node) {
      if (!node) return '';
      const parts = [
        displayTitleForNode(node),
        node.title || '',
        node.segment || '',
        node.file || '',
      ];
      return parts.join(' ').toLowerCase();
    }

    function collectTreeSearchMatches(query) {
      const matches = [];
      const needle = normalizeSearchQuery(query);
      if (!needle) return matches;
      const walk = (nodes) => {
        for (const node of (nodes || [])) {
          if (!node || !node.id) continue;
          const hay = buildSearchHaystack(node);
          if (hay.includes(needle)) matches.push(node.id);
          if (node.type === 'folder' && Array.isArray(node.children)) walk(node.children);
        }
      };
      walk(stateTree || []);
      return matches;
    }

    function updateTreeSearchControls() {
      const hasQuery = !!String(treeSearchQuery || '').trim();
      const hasMatches = Array.isArray(treeSearchMatches) && treeSearchMatches.length > 0;
      if (els.treeSearchPrev) els.treeSearchPrev.disabled = !hasMatches;
      if (els.treeSearchNext) els.treeSearchNext.disabled = !hasMatches;
      if (els.treeSearchClear) els.treeSearchClear.disabled = !hasQuery;
    }

    function refreshTreeSearch({ query, preserveIndex = false, selectMatch = false } = {}) {
      const raw = typeof query === 'string' ? query : treeSearchQuery;
      treeSearchQuery = raw;
      const normalized = normalizeSearchQuery(raw);
      if (!normalized) {
        treeSearchMatches = [];
        treeSearchIndex = -1;
        applyTreeSearchHighlights();
        updateTreeSearchInfo();
        updateTreeSearchControls();
        return;
      }
      const matches = collectTreeSearchMatches(normalized);
      let nextIndex = -1;
      if (preserveIndex && treeSearchIndex >= 0 && treeSearchIndex < treeSearchMatches.length) {
        const currentId = treeSearchMatches[treeSearchIndex];
        const idx = matches.indexOf(currentId);
        if (idx >= 0) nextIndex = idx;
      }
      if (nextIndex < 0 && matches.length) nextIndex = 0;
      treeSearchMatches = matches;
      treeSearchIndex = nextIndex;
      if (selectMatch && nextIndex >= 0) {
        selectTreeSearchMatch(nextIndex);
        return;
      }
      applyTreeSearchHighlights();
      updateTreeSearchInfo();
      updateTreeSearchControls();
    }

    function clearTreeSearch() {
      if (els.treeSearchInput) els.treeSearchInput.value = '';
      treeSearchQuery = '';
      treeSearchMatches = [];
      treeSearchIndex = -1;
      applyTreeSearchHighlights();
      updateTreeSearchInfo();
      updateTreeSearchControls();
    }

    function selectTreeSearchMatch(index) {
      if (!Array.isArray(treeSearchMatches) || treeSearchMatches.length === 0) {
        treeSearchIndex = -1;
        applyTreeSearchHighlights();
        updateTreeSearchInfo();
        updateTreeSearchControls();
        return;
      }
      const total = treeSearchMatches.length;
      const next = ((index % total) + total) % total;
      treeSearchIndex = next;
      const id = treeSearchMatches[next];
      ensureTreeMatchVisible(id);
      selectNode(id);
      applyTreeSearchHighlights();
      updateTreeSearchInfo();
      updateTreeSearchControls();
    }

    function findNodePath(nodes, targetId, parentSegs = [], parentTitles = []) {
      for (const node of (nodes || [])) {
        const entry = { node, parentSegs, parentTitles };
        if (node.id === targetId) return [entry];
        if (node.type === 'folder' && Array.isArray(node.children)) {
          const nextSegs = String((node.segment || '')).trim()
            ? parentSegs.concat([String(node.segment).trim()])
            : parentSegs;
          const nextTitles = parentTitles.concat([displayTitleForNode(node)]);
          const child = findNodePath(node.children, targetId, nextSegs, nextTitles);
          if (child) return [entry, ...child];
        }
      }
      return null;
    }

    function ensureTreeMatchVisible(id) {
      if (!id) return;
      const path = findNodePath(stateTree || [], id, [], []);
      if (!path || path.length < 2) return;
      let changed = false;
      const ancestors = path.slice(0, -1);
      for (const entry of ancestors) {
        if (!entry || !entry.node || entry.node.type !== 'folder') continue;
        const key = collapseKeyForNode(entry.node, entry.parentSegs, entry.parentTitles);
        if (key && treeCollapsed.has(key)) {
          treeCollapsed.delete(key);
          changed = true;
        }
      }
      if (changed) {
        persistTreeCollapsed();
        renderTree();
      }
    }

    function applyTreeSearchHighlights() {
      if (!els.tree) return;
      document.querySelectorAll('#tree .search-hit, #tree .search-current').forEach(el => {
        el.classList.remove('search-hit', 'search-current');
      });
      if (!Array.isArray(treeSearchMatches) || !treeSearchMatches.length) return;
      for (const id of treeSearchMatches) {
        const li = document.querySelector(`#tree li.node[data-id="${CSS.escape(id)}"]`);
        if (li) li.classList.add('search-hit');
        const slot = document.querySelector(`#tree .overview-inline[data-overview-id="${CSS.escape(id)}"]`);
        if (slot) slot.classList.add('search-hit');
      }
      if (treeSearchIndex >= 0 && treeSearchIndex < treeSearchMatches.length) {
        const currentId = treeSearchMatches[treeSearchIndex];
        const li = document.querySelector(`#tree li.node[data-id="${CSS.escape(currentId)}"]`);
        if (li) li.classList.add('search-current');
        const slot = document.querySelector(`#tree .overview-inline[data-overview-id="${CSS.escape(currentId)}"]`);
        if (slot) slot.classList.add('search-current');
      }
    }

    function showSyncWarnings(warnings) {
      if (!els.infoErrors || !els.infoDetails) return;
      if (!Array.isArray(warnings) || !warnings.length) {
        clearInfoErrors();
        return;
      }
      const parts = [];
      parts.push(`Sync warnings (${warnings.length})`);
      for (const warn of warnings) {
        if (!warn || typeof warn !== 'object') continue;
        const kind = warn.type || 'warning';
        const details = [];
        const order = ['title', 'file', 'from', 'to', 'target', 'path', 'error'];
        for (const key of order) {
          if (warn[key] != null && String(warn[key]).trim() !== '') {
            details.push(`${key}=${warn[key]}`);
          }
        }
        for (const key of Object.keys(warn)) {
          if (key === 'type' || order.includes(key)) continue;
          if (warn[key] != null && String(warn[key]).trim() !== '') {
            details.push(`${key}=${warn[key]}`);
          }
        }
        parts.push(`- ${kind}${details.length ? ' ' + details.join(' ') : ''}`);
      }
      els.infoErrors.hidden = false;
      els.infoErrors.textContent = parts.join('\n');
      els.infoDetails.open = true;
    }

    function showInfoDetails(title, lines) {
      if (!els.infoErrors || !els.infoDetails) return;
      if (!Array.isArray(lines) || !lines.length) {
        clearInfoErrors();
        return;
      }
      const parts = [];
      if (title) parts.push(String(title));
      for (const line of lines) {
        if (line == null) continue;
        const text = String(line).trim();
        if (!text) continue;
        parts.push(`- ${text}`);
      }
      if (parts.length <= (title ? 1 : 0)) {
        clearInfoErrors();
        return;
      }
      els.infoErrors.hidden = false;
      els.infoErrors.textContent = parts.join('\n');
      els.infoDetails.open = true;
    }

    function showSyncErrors(message, details) {
      if (!els.infoErrors || !els.infoDetails) return;
      const parts = [];
      if (message) parts.push(String(message));
      if (Array.isArray(details) && details.length) {
        parts.push(`Details (${details.length})`);
        for (const item of details) {
          if (!item || typeof item !== 'object') {
            parts.push(`- ${String(item)}`);
            continue;
          }
          const kind = item.type || 'error';
          const info = [];
          const order = ['title', 'file', 'from', 'to', 'target', 'path', 'error'];
          for (const key of order) {
            if (item[key] != null && String(item[key]).trim() !== '') {
              info.push(`${key}=${item[key]}`);
            }
          }
          for (const key of Object.keys(item)) {
            if (key === 'type' || order.includes(key)) continue;
            if (item[key] != null && String(item[key]).trim() !== '') {
              info.push(`${key}=${item[key]}`);
            }
          }
          parts.push(`- ${kind}${info.length ? ' ' + info.join(' ') : ''}`);
        }
      }
      els.infoErrors.hidden = false;
      els.infoErrors.textContent = parts.join('\n');
      els.infoDetails.open = true;
    }

    function shortenPathLine(line) {
      if (!line) return '';
      const parts = line.split('|').map(s => s.trim()).filter(Boolean);
      if (parts.length < 2) return line;
      const mk = parts[0].replace(/\\\\/g, '/').split('/').pop() || parts[0];
      const docs = parts[1].replace(/\\\\/g, '/').split('/').pop() || parts[1];
      return `${mk} ‚Ä¢ ${docs}`;
    }

    function findNode(nodes, id, parent = null) {
      for (const node of (nodes || [])) {
        if (node.id === id) return { node, parent, siblings: nodes };
        if (node.type === 'folder' && Array.isArray(node.children)) {
          const found = findNode(node.children, id, node);
          if (found) return found;
        }
      }
      return null;
    }

    function ensureSelectedValid() {
      if (selectedIds && selectedIds.size) {
        const next = new Set();
        for (const id of selectedIds) {
          if (findNode(stateTree, id)) next.add(id);
        }
        selectedIds = next;
      }
      if (selectedId && !findNode(stateTree, selectedId)) selectedId = '';
      if (selectedId && selectedIds && selectedIds.size && !selectedIds.has(selectedId)) {
        selectedId = Array.from(selectedIds)[0] || '';
      }
      if (!selectedId && selectedIds && selectedIds.size) selectedId = Array.from(selectedIds)[0] || '';
    }

    async function loadMeta() {
      try {
        const data = await fetchJson('/api/meta');
        const text = `${data.mkdocs_path} | ${data.docs_root}`;
        docsRoot = data.docs_root || '';
        els.meta.textContent = shortenPathLine(text);
        els.meta.title = text;
        setInfoMeta(text);
      } catch (e) {
        els.meta.textContent = '(meta unavailable)';
        setInfoMeta('(meta unavailable)');
      }
    }

    async function loadState(options) {
      const reset = options && options.reset;
      const silentStatus = options && options.silentStatus;
      if (!silentStatus) setStatus('Loading tree...', 'info');
      try {
        const data = await fetchJson('/api/state');
        stateTree = Array.isArray(data.tree) ? data.tree : [];
        lastPersistedSignature = treeSignature(stateTree);
        if (reset) resetHistory();
        else restoreHistoryIfMatching();
        ensureSelectedValid();
        renderTree();
        updateHistoryButtons();
        if (!silentStatus) setStatus('üå≥ Tree loaded.', 'success');
      } catch (e) {
        els.tree.textContent = 'Failed to load tree.';
        if (!silentStatus) setStatus(e.message || 'Failed to load tree.', 'error');
      }
    }

    async function loadSource() {
      try {
        const data = await fetchJson('/api/source');
        sourceTree = Array.isArray(data) ? data : [];
        renderSource();
      } catch (e) {
        els.source.textContent = 'Failed to load source.';
      }
    }

	    async function importFromMkdocs(options) {
	      const opts = options || {};
	      const shouldConfirm = opts.confirm !== false;
	      const shouldBeautify = opts.beautify === true;
	      if (shouldConfirm) {
	        const ok = await showConfirm('Import will overwrite current tree state. Continue?', {
            title: 'Import mkdocs.yml',
            okText: 'Import',
            cancelText: 'Cancel'
          });
	        if (!ok) return;
	      }
	      setStatus('Importing...', 'info');
	      try {
	        const data = await fetchJson('/api/import', { method: 'POST' });
	        stateTree = Array.isArray(data.tree) ? data.tree : [];
	        const warnings = Array.isArray(data.warnings) ? data.warnings : [];
	        lastPersistedSignature = treeSignature(stateTree);
	        resetHistory();
	        selectedId = '';
	        renderTree();
	        updateHistoryButtons();
	        setStatus(warnings.length ? `Imported with warnings (${warnings.length}).` : 'Imported from mkdocs.yml.', warnings.length ? 'info' : 'success');
	        await loadSource();
	        if (shouldBeautify) {
	          // Re-write mkdocs.yml nav with normalized 2-space indentation (nav block only; no file moves).
	          pushDebug('import.beautify', {});
	          await sync('nav_only', { confirm: false, silent: true });
	          setStatus('üñ≤Ô∏è Loaded and beautified mkdocs.yml nav.', 'success');
	        }
	      } catch (e) {
	        const data = e && e.data ? e.data : null;
	        if (data && Array.isArray(data.errors)) {
	          setStatus(`Import blocked: ${data.errors.length} invalid/missing doc path(s).`, 'error');
	          pushDebug('import.blocked', { errors: data.errors });
	          showImportErrors(data);
	          return;
	        }
	        setStatus(e.message || 'Import failed.', 'error');
	      }
	    }

	    async function beautifyNav() {
	      setStatus('Beautifying nav...', 'info');
	      pushDebug('beautify.nav', {});
	      await sync('nav_only', { confirm: false, silent: false });
	    }

	    function showImportErrors(payload) {
	      if (!els.infoErrors || !els.infoDetails) return;
	      const lines = Array.isArray(payload && payload.lines) ? payload.lines : [];
	      const errors = Array.isArray(payload && payload.errors) ? payload.errors : [];
	      const parts = [];
	      parts.push(`mkdocs.yml import blocked (${errors.length})`);
	      for (const err of errors) {
	        if (!err) continue;
	        const kind = err.type || 'error';
	        const file = err.file ? ` file=${err.file}` : '';
	        const path = err.path ? ` path=${err.path}` : '';
	        const msg = err.error ? ` error=${err.error}` : '';
	        parts.push(`- ${kind}${file}${path}${msg}`);
	      }
	      if (lines.length) {
	        parts.push('');
	        parts.push('Matched mkdocs.yml lines:');
	        for (const l of lines) {
	          if (!l) continue;
	          const no = (l.no != null) ? String(l.no) : '';
	          const text = (l.text || '').trimEnd();
	          parts.push(`${no.padStart(4, ' ')} | ${text}`);
	        }
	      }
	      els.infoErrors.hidden = false;
	      els.infoErrors.textContent = parts.join('\n');
	      els.infoDetails.open = true;
	    }

    async function sync(mode, options) {
      const opts = options || {};
      const shouldConfirm = opts.confirm !== false;
      const silent = !!opts.silent;

      if (shouldConfirm) {
        const msg = mode === 'sync_files'
          ? 'This will move .md files (and sibling asset folders) on disk. Continue?'
          : 'This will write mkdocs.yml nav. Continue?';
        const ok = await showConfirm(msg, {
          title: mode === 'sync_files' ? 'Sync Files' : 'Sync Nav',
          okText: 'Continue',
          cancelText: 'Cancel'
        });
        if (!ok) return;
      }
      if (!silent) setStatus('Syncing...', 'info');
      try {
        const payload = { mode, tree: stateTree };
        if (opts.payload && typeof opts.payload === 'object') {
          Object.assign(payload, opts.payload);
        }
        const data = await fetchJson('/api/sync', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        const moves = Array.isArray(data.moves) ? data.moves : [];
        const warnings = Array.isArray(data.warnings) ? data.warnings : [];
        const extra = moves.length ? ` moved:${moves.length}` : '';
        const warn = warnings.length ? ` warnings:${warnings.length}` : '';
        if (!silent) setStatus(`Sync ok.${extra}${warn}`, warnings.length ? 'info' : 'success');
        showSyncWarnings(warnings);
        await loadState({ reset: false, silentStatus: silent });
        await loadSource();
        lastPersistedSignature = treeSignature(stateTree);
      } catch (e) {
        const data = e && e.data ? e.data : null;
        if (data && Array.isArray(data.collisions) && data.collisions.length) {
          setStatus(`Sync blocked: file name conflict (${data.collisions.length}). No changes applied.`, 'error');
          pushDebug('sync.blocked', { collisions: data.collisions });
          showSyncErrors('Sync blocked: file name conflict.', data.collisions);
          await loadState({ reset: true, silentStatus: silent });
          await loadSource();
          return;
        }
        setStatus(e.message || 'Sync failed.', 'error');
        showSyncErrors(e.message || 'Sync failed.', data && data.errors ? data.errors : null);
      }
    }

    function renderSource() {
      els.source.innerHTML = '';
      if (!Array.isArray(sourceTree) || !sourceTree.length) {
        els.source.textContent = '(no markdown files found)';
        if (pendingSourceRestore) restoreSourceFromUiState();
        else restoreScrollPosition('page_tree_scroll_source', els.source);
        return;
      }
      els.source.appendChild(sourceView === 'ascii' ? buildSourceAscii(sourceTree) : buildSourceList(sourceTree));
      if (pendingSourceRestore) restoreSourceFromUiState();
      else restoreScrollPosition('page_tree_scroll_source', els.source);
    }

    function persistSourceCollapsed() {
      localStorage.setItem('page_tree_source_collapsed', JSON.stringify(Array.from(sourceCollapsed)));
      scheduleUiStateSave();
    }

    function toggleSourceDir(path) {
      if (!path) return;
      if (sourceCollapsed.has(path)) sourceCollapsed.delete(path);
      else sourceCollapsed.add(path);
      persistSourceCollapsed();
      renderSource();
    }

    function buildSourceList(nodes, depth = 0) {
      const ul = document.createElement('ul');
      ul.className = depth === 0 ? 'source-explorer' : 'source-children';
      for (const node of (nodes || [])) {
        const li = document.createElement('li');
        li.className = 'source-item';
        li.dataset.kind = node.kind || '';
        li.dataset.path = node.path || '';

        const row = document.createElement('div');
        row.className = 'source-row ' + (node.kind === 'dir' ? 'kind-dir' : 'kind-file');
        row.title = node.path ? `./${node.path}` : '';

        const twist = document.createElement('span');
        twist.className = 'source-twist';
        const isDir = node.kind === 'dir';
        const isCollapsed = isDir && node.path && sourceCollapsed.has(node.path);
        twist.textContent = isDir ? (isCollapsed ? '‚ñ∏' : '‚ñæ') : '';
        row.appendChild(twist);

        const icon = document.createElement('span');
        icon.className = 'source-icon';
        icon.textContent = isDir ? 'üóÇÔ∏è' : 'üìù';
        row.appendChild(icon);

        const name = document.createElement('span');
        name.className = 'source-name';
        name.textContent = node.name || '(unnamed)';
        row.appendChild(name);

        li.appendChild(row);

        if (node.kind === 'file') {
          row.classList.add('clickable');
          row.addEventListener('click', (e) => {
            e.stopPropagation();
            // If this file is a section README/index and we can find its overview page, select the overview
            const overview = findOverviewBySourcePath(node.path || '');
            if (overview) {
              selectNode(overview.id);
              return;
            }
            // Default: select the page nav element corresponding to this file
            // Shift+click: select the containing section (folder) instead
            const info = findNodeByFile(node.path || '');
            if (e.shiftKey && info && info.parent && info.parent.id) {
              // select the parent folder's nav element
              selectNode(info.parent.id);
            } else if (info && info.node && info.node.id) {
              // select the page nav element
              locateInTree(node.path || '', { markSourceLocated: false });
            } else {
              // fallback: try locate by path without marking source
              locateInTree(node.path || '', { markSourceLocated: false });
            }
          });
        } else if (node.kind === 'dir') {
          row.classList.add('clickable');
          row.addEventListener('click', (e) => {
            e.stopPropagation();
            toggleSourceDir(node.path || '');
          });
        }

        if (node.kind === 'dir' && Array.isArray(node.children) && node.children.length) {
          const collapsed = node.path && sourceCollapsed.has(node.path);
          if (!collapsed) {
            li.appendChild(buildSourceList(node.children, depth + 1));
          }
        }
        ul.appendChild(li);
      }
      return ul;
    }

    function buildSourceAscii(nodes) {
      const container = document.createElement('div');
      container.className = 'source-ascii';
      const lines = [];

      function walk(items, prefixParts) {
        (items || []).forEach((node, index) => {
          const isLast = index === items.length - 1;
          const branch = isLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ';
          const prefix = (prefixParts || []).join('') + branch;

          const line = document.createElement('div');
          line.className = 'source-line';
          if (node.path) line.dataset.path = node.path || '';

          const pre = document.createElement('span');
          pre.className = 'source-prefix';
          pre.textContent = prefix;
          line.appendChild(pre);

          const name = document.createElement('span');
          name.className = 'source-name ' + (node.kind === 'dir' ? 'kind-dir' : 'kind-file');
          const ext = node.kind === 'file' ? (String(node.name || '').split('.').pop() || '').toLowerCase() : '';
          if (ext) name.dataset.ext = ext;
          name.textContent = node.name || '(unnamed)';
          line.appendChild(name);

          if (node.kind === 'file' && node.path) {
            line.classList.add('clickable');
            line.addEventListener('click', (e) => {
              e.stopPropagation();
              // If this file is a section README/index and we can find its overview page, select the overview
              const overview = findOverviewBySourcePath(node.path || '');
              if (overview) { selectNode(overview.id); return; }
              // Default: select the page nav element corresponding to this file
              // Shift+click: select the containing section (folder) instead
              const info = findNodeByFile(node.path || '');
              if (e.shiftKey && info && info.parent && info.parent.id) {
                selectNode(info.parent.id);
              } else if (info && info.node && info.node.id) {
                locateInTree(node.path || '', { markSourceLocated: false });
              } else {
                locateInTree(node.path || '', { markSourceLocated: false });
              }
            });
          }

          lines.push(line);

          const nextPrefixParts = (prefixParts || []).slice();
          nextPrefixParts.push(isLast ? '    ' : '‚îÇ   ');
          if (Array.isArray(node.children) && node.children.length) {
            walk(node.children, nextPrefixParts);
          }
        });
      }

      walk(nodes || [], []);
      lines.forEach(l => container.appendChild(l));
      return container;
    }

    function locateByFile(file) {
      // Keep legacy tree-locate behavior but prefer locating inside Source explorer
      const normalized = normalizePath(file);
      if (!normalized) return;
      const foundInSource = locateInSource(file);
      if (foundInSource) return;
      // Fallback: highlight in tree if not found in source
      const all = Array.from(document.querySelectorAll('#tree li[data-file]'));
      all.forEach(el => el.classList.remove('flash'));
      const hit = all.find(el => normalizePath(el.dataset.file || '') === normalized);
      if (!hit) {
        setStatus('Not found in tree or source.', 'info');
        return;
      }
      hit.classList.add('flash');
      hit.scrollIntoView({ behavior: 'smooth', block: 'center' });
      setTimeout(() => hit.classList.remove('flash'), 900);
    }

    // Ensure the source explorer has the directory path expanded and scroll/highlight the file item.
    function ensureSourcePathVisible(path) {
      const normalized = normalizePath(path);
      if (!normalized) return null;
      const items = Array.from(document.querySelectorAll('#source .source-item, #source .source-line'));
      // Find matching file element by data-path
      const hit = items.find(el => normalizePath(el.dataset.path || el.dataset.path || el.dataset.file || '') === normalized || normalizePath(el.dataset.path || el.dataset.file || '') === normalized);
      if (!hit) return null;
      // If this is an ASCII line (no nested children), simply mark and scroll
      if (hit.classList && hit.classList.contains('source-line')) {
        clearLocatedSource();
        hit.classList.add('located');
        hit.scrollIntoView({ behavior: 'smooth', block: 'center' });
        // Install one-time global clear handlers so any user action clears .located
        attachLocatedClearHandlers();
        return hit;
      }

      // For the tree-like explorer, expand ancestor directories by triggering their twist toggle (simulate click on their row)
      let parent = hit.parentElement;
      while (parent && parent.id !== 'source') {
        if (parent.classList && (parent.classList.contains('source-children') || parent.classList.contains('source-explorer'))) {
          const prev = parent.previousElementSibling;
          if (prev && prev.classList && prev.classList.contains('source-row') && prev.querySelector('.source-twist')) {
            const twist = prev.querySelector('.source-twist');
            if (twist && twist.textContent === '‚ñ∏') prev.click();
          }
        }
        parent = parent.parentElement;
      }
      // Now scroll the hit into view within the source panel and mark it as located (persist until next action)
      clearLocatedSource();
      hit.classList.add('located');
      hit.scrollIntoView({ behavior: 'smooth', block: 'center' });
      // Install one-time global clear handlers so any user action clears .located
      attachLocatedClearHandlers();
      return hit;
    }

    function clearLocatedSource() {
      const prev = document.querySelectorAll('#source .source-item.located, #source .source-line.located');
      prev && prev.forEach(el => el.classList.remove('located'));
      // Remove any registered global handlers
      if (Array.isArray(locatedClearHandlers) && locatedClearHandlers.length) {
        for (const h of locatedClearHandlers) {
          try { document.removeEventListener(h.event, h.fn, h.opts || false); } catch (e) { /* ignore */ }
        }
        locatedClearHandlers = [];
      }
    }

    function attachLocatedClearHandlers() {
      // Clear any existing handlers first to avoid duplicates
      if (Array.isArray(locatedClearHandlers) && locatedClearHandlers.length) {
        for (const h of locatedClearHandlers) {
          try { document.removeEventListener(h.event, h.fn, h.opts || false); } catch (e) { /* ignore */ }
        }
        locatedClearHandlers = [];
      }
      const events = ['click', 'pointerdown', 'wheel', 'keydown', 'touchstart', 'contextmenu', 'focusin'];
      locatedSuppressUntil = Date.now() + 160; // ignore immediate originating event
      for (const ev of events) {
        const fn = function one(e) {
          if (Date.now() < locatedSuppressUntil) return;
          clearLocatedSource();
        };
        // Use capture for click/pointerdown to catch early
        const opts = (ev === 'click' || ev === 'pointerdown') ? true : false;
        document.addEventListener(ev, fn, opts);
        locatedClearHandlers.push({ event: ev, fn: fn, opts: opts });
      }
    }

    function locateInSource(file) {
      if (!file) return null;
      const path = (file || '').replace(/^\.\//, '');
      // Ensure source panel visible
      showSource = true;
      localStorage.setItem('page_tree_show_source', String(true));
      applyPanelVisibility();
      // Render may be synchronous; attempt to ensure the source DOM exists
      // Try immediate lookup; if not found, wait a short delay for renderSource completion
      let hit = ensureSourcePathVisible(path);
      if (hit) return hit;
      // If not found immediately, try re-render and retry after a tick
      renderSource();
      hit = ensureSourcePathVisible(path);
      if (hit) return hit;
      // Final attempt after small delay
      setTimeout(() => ensureSourcePathVisible(path), 120);
      return null;
    }

    // Locate and select the corresponding nav element in the tree for a given source file
    function locateInTree(file, opts) {
      opts = opts || {};
      const normalized = normalizePath(file || '');
      if (!normalized) return null;
      const all = Array.from(document.querySelectorAll('#tree li[data-file]'));
      all.forEach(el => el.classList.remove('flash'));

      // Matching strategies in order:
      // 1) exact normalized path
      // 2) compare basenames
      // 3) README/index mapping: if source is docs/foo/README.md, match nav file docs/foo.md or docs/foo/README.md or docs/foo/index.md
      // 4) directory-level mapping: if nav has docs/foo/ then match docs/foo/README.md

      const tryNormalize = p => normalizePath(p || '');
      const basename = p => (String(p || '').split('/').pop() || '').toLowerCase();

      let hit = all.find(el => tryNormalize(el.dataset.file) === normalized);
      if (!hit) {
          // 2) basename match but only when it yields a unique candidate
          const name = basename(normalized);
          if (name) {
            const cand = all.filter(el => basename(el.dataset.file) === name);
            if (cand.length === 1) hit = cand[0];
          }
      }
      if (!hit) {
        // 3) README/index mapping
          const dir = normalized;
        const altCandidates = [];
        // if path ends with README.md or index.md, try both forms
        const withoutFile = normalized.replace(/(?:readme|index)\.md$/i, '').replace(/\/$/, '');
        if (withoutFile && withoutFile !== normalized) {
          altCandidates.push(withoutFile + '.md');
          altCandidates.push(withoutFile + '/README.md');
          altCandidates.push(withoutFile + '/index.md');
        }
        // if path is a dir (no .md), try dir/README.md
        if (!/\.md$/i.test(normalized)) {
          altCandidates.push(normalized.replace(/\/$/, '') + '/README.md');
          altCandidates.push(normalized.replace(/\/$/, '') + '/index.md');
        }
        // Try matching candidates exactly first
        for (const c of altCandidates) {
          const n = tryNormalize(c);
          hit = all.find(el => tryNormalize(el.dataset.file) === n);
          if (hit) break;
        }
        // If still not found and this is a README/index, try finding the folder's overview page via stateTree
        if (!hit && /(?:readme|index)\.md$/i.test(normalized)) {
          const folderSegment = dir.replace(/(?:readme|index)\.md$/i, '').replace(/\/$/, '');
          // find folder node in stateTree by segment
          function findFolderBySegment(seg, nodes) {
            for (const n of (nodes || [])) {
              if (!n) continue;
              if (n.type === 'folder' && (n.segment || '') === seg) return n;
              if (Array.isArray(n.children)) {
                const f = findFolderBySegment(seg, n.children);
                if (f) return f;
              }
            }
            return null;
          }
          const folder = findFolderBySegment(folderSegment, stateTree);
          if (folder) {
            const overview = (Array.isArray(folder.children) ? folder.children : []).find(c => c && c.type === 'page' && c.is_overview);
            if (overview && overview.id) {
              const el = document.querySelector(`#tree li.node[data-id="${String(overview.id)}"]`);
              if (el) hit = el;
            }
          }
        }
      }
      if (!hit) return null;

      // Select the node
      const id = hit.dataset.id;
      if (id) {
        selectedId = id;
        selectedIds = new Set([id]);
        selectionAnchorId = id;
        selectionParentKey = selectionKeyForId(id);
        selectedDisplaySlotFolderId = '';
        syncSelectionClasses();
      }
      // Flash and scroll
      hit.classList.add('flash');
      hit.scrollIntoView({ behavior: 'smooth', block: 'center' });
      setTimeout(() => hit.classList.remove('flash'), 900);
      // Also mark the source explorer item as located (persistent) if present
      if (opts.markSourceLocated !== false) {
        try { ensureSourcePathVisible(file); } catch (e) { /* ignore */ }
      }
      return hit;
    }

    // Find a node in stateTree by its file path, return {node, parent} or null
    function findNodeByFile(file, nodes = stateTree, parent = null) {
      const nfile = normalizePath(file || '');
      for (const node of (nodes || [])) {
        if (!node) continue;
        if (node.type === 'page' && normalizePath(node.file || '') === nfile) return { node, parent };
        if (node.type === 'folder' && Array.isArray(node.children)) {
          const found = findNodeByFile(file, node.children, node);
          if (found) return found;
        }
      }
      return null;
    }

    // Find an overview page node by source path (README/index mapping), return node or null
    function findOverviewBySourcePath(file) {
      const nfile = normalizePath(file || '');
      // Direct match to any overview page
      function walk(nodes) {
        for (const node of (nodes || [])) {
          if (!node) continue;
          if (node.type === 'page' && node.is_overview && normalizePath(node.file || '') === nfile) return node;
          if (Array.isArray(node.children)) {
            const found = walk(node.children);
            if (found) return found;
          }
        }
        return null;
      }
      const direct = walk(stateTree);
      if (direct) return direct;
      // If path ends with README.md or index.md, try matching by folder path
      if (/(?:readme|index)\.md$/i.test(nfile)) {
        const folderPath = nfile.replace(/(?:readme|index)\.md$/i, '').replace(/\/$/, '');
        function walkFolder(nodes) {
          for (const node of (nodes || [])) {
            if (!node) continue;
            if (node.type === 'folder') {
              // check children for overview
              const overview = (Array.isArray(node.children) ? node.children : []).find(c => c && c.type === 'page' && c.is_overview && normalizePath(c.file || '').startsWith(folderPath));
              if (overview) return overview;
            }
            if (Array.isArray(node.children)) {
              const found = walkFolder(node.children);
              if (found) return found;
            }
          }
          return null;
        }
        const byFolder = walkFolder(stateTree);
        if (byFolder) return byFolder;
      }
      return null;
    }

    function normalizePath(path) {
      return (path || '').trim().replace(/^\.\//, '').replace(/\\/g, '/').replace(/\/+/g, '/').toLowerCase();
    }

    function buildUiState() {
      return {
        tree_collapsed: Array.from(treeCollapsed),
        source_collapsed: Array.from(sourceCollapsed),
        tree_scroll: els.tree ? els.tree.scrollTop : 0,
        source_scroll: els.source ? els.source.scrollTop : 0,
        tree_anchor: buildTreeAnchor(),
        source_anchor: buildSourceAnchor(),
        last_depth_value: lastDepthValue,
        last_depth_action: lastDepthAction
      };
    }

    function findTreeElementByFile(file) {
      const info = findNodeByFile(file);
      if (info && info.node && info.node.id) {
        const el = document.querySelector(`#tree li.node[data-id="${CSS.escape(info.node.id)}"]`);
        if (el) return el;
      }
      const normalized = normalizePath(file || '');
      if (!normalized) return null;
      const all = Array.from(document.querySelectorAll('#tree li.node[data-file]'));
      return all.find(el => normalizePath(el.dataset.file || '') === normalized) || null;
    }

    function findFolderByDirPath(dirPath) {
      const target = normalizePath(dirPath || '');
      if (!target) return null;
      let hit = null;
      const walk = (nodes, segs) => {
        for (const node of (nodes || [])) {
          if (!node || node.type !== 'folder') continue;
          const selfSeg = String((node.segment || '')).trim();
          const nextSegs = selfSeg ? segs.concat([selfSeg]) : segs;
          if (nextSegs.length) {
            const joined = normalizePath(nextSegs.join('/'));
            if (joined === target) {
              hit = node;
              return;
            }
          }
          if (Array.isArray(node.children)) walk(node.children, nextSegs);
          if (hit) return;
        }
      };
      walk(stateTree, []);
      if (!hit || !hit.id) return null;
      return document.querySelector(`#tree li.node[data-id="${CSS.escape(hit.id)}"]`);
    }

    function findFolderByTitlePath(titlePath) {
      const target = String(titlePath || '').trim();
      if (!target) return null;
      const parts = target.split('/').map(s => s.trim()).filter(Boolean);
      if (!parts.length) return null;
      let hit = null;
      const walk = (nodes, titles) => {
        for (const node of (nodes || [])) {
          if (!node || node.type !== 'folder') continue;
          const name = displayTitleForNode(node);
          const nextTitles = titles.concat([name]);
          if (nextTitles.join('/') === parts.join('/')) {
            hit = node;
            return;
          }
          if (Array.isArray(node.children)) walk(node.children, nextTitles);
          if (hit) return;
        }
      };
      walk(stateTree, []);
      if (!hit || !hit.id) return null;
      return document.querySelector(`#tree li.node[data-id="${CSS.escape(hit.id)}"]`);
    }

    function findTreeElementByAnchor(anchor) {
      if (!anchor || typeof anchor !== 'object') return null;
      if (anchor.type === 'page' && anchor.file) {
        let path = String(anchor.file);
        while (path) {
          const el = findTreeElementByFile(path);
          if (el) return el;
          if (!path.includes('/')) break;
          path = path.replace(/\/[^/]+$/, '');
        }
        return null;
      }
      if (anchor.type === 'folder') {
        let dir = String(anchor.dir || '');
        while (dir) {
          const el = findFolderByDirPath(dir);
          if (el) return el;
          if (!dir.includes('/')) break;
          dir = dir.replace(/\/[^/]+$/, '');
        }
        let titlePath = String(anchor.title_path || '');
        while (titlePath) {
          const el = findFolderByTitlePath(titlePath);
          if (el) return el;
          if (!titlePath.includes('/')) break;
          titlePath = titlePath.replace(/\/[^/]+$/, '');
        }
      }
      return null;
    }

    function findSourceElementByPath(path) {
      const target = normalizePath(path || '');
      if (!target) return null;
      const all = Array.from(document.querySelectorAll('#source li.source-item[data-path]'));
      return all.find(el => normalizePath(el.dataset.path || '') === target) || null;
    }

    function restoreTreeFromUiState() {
      if (!pendingTreeRestore) return;
      pendingTreeRestore = false;
      if (uiState && uiState.tree_anchor) {
        const el = findTreeElementByAnchor(uiState.tree_anchor);
        if (el) {
          el.scrollIntoView({ behavior: 'auto', block: 'center' });
          return;
        }
      }
      if (uiState && Number.isFinite(uiState.tree_scroll) && els.tree) {
        els.tree.scrollTop = uiState.tree_scroll;
      }
    }

    function restoreSourceFromUiState() {
      if (!pendingSourceRestore) return;
      pendingSourceRestore = false;
      if (uiState && uiState.source_anchor) {
        let path = String(uiState.source_anchor.path || '');
        while (path) {
          const el = findSourceElementByPath(path);
          if (el) {
            el.scrollIntoView({ behavior: 'auto', block: 'center' });
            return;
          }
          if (!path.includes('/')) break;
          path = path.replace(/\/[^/]+$/, '');
        }
      }
      if (uiState && Number.isFinite(uiState.source_scroll) && els.source) {
        els.source.scrollTop = uiState.source_scroll;
      }
    }

    function renderTree() {
      els.tree.innerHTML = '';
      dropLineEl = dropLineEl || document.createElement('div');
      dropLineEl.className = 'drop-line';
      const list = buildTreeList(Array.isArray(stateTree) ? stateTree : [], true, 0);
      els.tree.appendChild(list);
      els.tree.appendChild(dropLineEl);
      hideDropLine();
      updateSelectionInfo();
      updateTreeActionButtons();
      if (!stateTree.length) {
        const hint = document.createElement('div');
        hint.className = 'empty-hint';
        hint.textContent = '(empty)';
        els.tree.appendChild(hint);
      }
      refreshTreeSearch({ preserveIndex: true, selectMatch: false });
      if (pendingTreeRestore) restoreTreeFromUiState();
      else restoreScrollPosition('page_tree_scroll_tree', els.tree);
    }

    function initStatusExpanded() {
      setStatusExpanded(false);
    }

    function updateSelectionInfo() {
      if (selectedIds && selectedIds.size > 1) {
        setInfoSelection(`Selection: ${selectedIds.size} items`);
        return;
      }
      if (!selectedId && selectedDisplaySlotFolderId) {
        const found = findNode(stateTree, selectedDisplaySlotFolderId);
        const title = found && found.node ? found.node.title : '(section)';
        setInfoSelection(`Selection: display | ${title}`);
        return;
      }
      if (!selectedId) {
        setInfoSelection('Selection: (none)');
        return;
      }
      const found = findNode(stateTree, selectedId);
      if (!found) {
        setInfoSelection('Selection: (none)');
        return;
      }
      const kind = found.node.type === 'folder' ? 'section' : 'page';
      const file = found.node.file ? ` | file: ./${found.node.file}` : '';
      const segment = found.node.segment ? ` | dir: ${found.node.segment}` : '';
      setInfoSelection(`Selection: ${kind} | ${found.node.title}${segment}${file}`);
    }

	    function selectNode(id) {
	      // Any selection change clears located highlight
	      clearLocatedSource();
	      selectedId = id || '';
	      selectedIds = new Set(selectedId ? [selectedId] : []);
	      selectionAnchorId = selectedId;
	      selectionParentKey = selectionKeyForId(selectedId);
	      selectedDisplaySlotFolderId = '';
	      syncSelectionClasses();
        // Scroll selection into view: prefer page li, otherwise overview slot
        if (selectedId) {
          const el = document.querySelector(`#tree li.node[data-id="${CSS.escape(selectedId)}"]`);
          if (el) {
            el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            return;
          }
          const ov = document.querySelector(`#tree .overview-inline[data-overview-id="${CSS.escape(selectedId)}"]`);
          if (ov) ov.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
	    }

	    function clearSelection() {
	      clearLocatedSource();
	      selectedId = '';
	      selectedIds = new Set();
	      selectionAnchorId = '';
	      selectionParentKey = '';
	      selectedDisplaySlotFolderId = '';
	      syncSelectionClasses();
	    }

    function selectionKeyForId(id) {
      if (!id) return '';
      const info = findNode(stateTree, id);
      if (!info) return '';
      return info.parent ? `p:${info.parent.id}` : 'root';
    }

	    function syncSelectionClasses() {
	      document.querySelectorAll('#tree li.node.selected').forEach(el => el.classList.remove('selected'));
	      document.querySelectorAll('#tree .overview-inline.selected').forEach(el => el.classList.remove('selected'));
	      for (const id of (selectedIds || [])) {
	        const el = document.querySelector(`#tree li.node[data-id="${CSS.escape(id)}"]`);
	        if (el) el.classList.add('selected');
	        const ov = document.querySelector(`#tree .overview-inline[data-overview-id="${CSS.escape(id)}"]`);
	        if (ov) ov.classList.add('selected');
	      }
	      if (selectedDisplaySlotFolderId) {
	        const slot = document.querySelector(`#tree .overview-inline[data-folder-id="${CSS.escape(selectedDisplaySlotFolderId)}"]`);
	        if (slot) slot.classList.add('selected');
	      }
	      updateSelectionInfo();
        maybeLoadEditorFromSelection();
        updateTreeActionButtons();
	    }

    function selectWithModifiers(id, e) {
      const isMeta = !!(e && (e.metaKey || e.ctrlKey));
      const isShift = !!(e && e.shiftKey);
      const key = selectionKeyForId(id);
      if (!id) return;

      // Clear located highlight when user changes selection via mouse modifiers
      clearLocatedSource();

      // First selection.
      if (!selectedIds || selectedIds.size === 0) {
        selectedId = id;
        selectedIds = new Set([id]);
        selectionAnchorId = id;
        selectionParentKey = key;
        syncSelectionClasses();
        return;
      }

      // Restrict multi-select to the same parent (same siblings list).
      if (selectionParentKey && key && selectionParentKey !== key) {
        selectedId = id;
        selectedIds = new Set([id]);
        selectionAnchorId = id;
        selectionParentKey = key;
        syncSelectionClasses();
        return;
      }

      if (isShift && selectionAnchorId) {
        const anchorInfo = findNode(stateTree, selectionAnchorId);
        const targetInfo = findNode(stateTree, id);
        if (!anchorInfo || !targetInfo) return;
        const sameParent = (anchorInfo.parent ? anchorInfo.parent.id : 'root') === (targetInfo.parent ? targetInfo.parent.id : 'root');
        if (!sameParent) {
          selectedId = id;
          selectedIds = new Set([id]);
          selectionAnchorId = id;
          selectionParentKey = key;
          syncSelectionClasses();
          return;
        }
        const siblings = anchorInfo.siblings || [];
        const a = siblings.findIndex(n => n.id === selectionAnchorId);
        const b = siblings.findIndex(n => n.id === id);
        if (a < 0 || b < 0) return;
        const lo = Math.min(a, b);
        const hi = Math.max(a, b);
        const next = new Set();
        for (let i = lo; i <= hi; i++) next.add(siblings[i].id);
        selectedIds = next;
        selectedId = id;
        selectionParentKey = key;
        syncSelectionClasses();
        return;
      }

      if (isMeta) {
        const next = new Set(selectedIds || []);
        if (next.has(id)) next.delete(id);
        else next.add(id);
        selectedIds = next;
        selectedId = id;
        selectionAnchorId = id;
        selectionParentKey = key;
        if (!selectedIds.size) {
          selectedId = '';
          selectionAnchorId = '';
          selectionParentKey = '';
        }
        syncSelectionClasses();
        return;
      }

      // Plain click: single select.
      selectedId = id;
      selectedIds = new Set([id]);
      selectionAnchorId = id;
      selectionParentKey = key;
      syncSelectionClasses();
    }

    function persistTreeCollapsed() {
      localStorage.setItem('page_tree_tree_collapsed', JSON.stringify(Array.from(treeCollapsed)));
      scheduleUiStateSave();
    }

    function normalizeTreeCollapsed() {
      const next = new Set();
      for (const key of treeCollapsed) {
        if (typeof key !== 'string') continue;
        if (key.startsWith('dir:') || key.startsWith('title:')) next.add(key);
      }
      if (next.size !== treeCollapsed.size) {
        treeCollapsed = next;
        persistTreeCollapsed();
      }
    }

    function toggleTreeDir(key) {
      if (!key) return;
      lastDepthAction = '';
      updateDepthButtons();
      if (treeCollapsed.has(key)) treeCollapsed.delete(key);
      else treeCollapsed.add(key);
      persistTreeCollapsed();
      renderTree();
    }

    function displayTitleForNode(node) {
      const title = String((node && node.title) || '').trim();
      if (!title) return '(untitled)';
      if (title.includes('/') || title.includes('\\')) {
        const looksLikePath = /[\\/]/.test(title) && (
          /(^|\/|\.)\.\.\//.test(title) ||
          title.includes('./') ||
          /\.[a-z0-9]{1,6}$/i.test(title)
        );
        if (looksLikePath) {
          const parts = title.replace(/\\/g, '/').split('/');
          return parts[parts.length - 1] || title;
        }
      }
      return title;
    }

    function collapseKeyForNode(node, parentSegs, parentTitles) {
      if (!node || node.type !== 'folder') return '';
      const seg = String((node.segment || '')).trim();
      const missingAncestorSeg = (parentSegs || []).length !== (parentTitles || []).length;
      if (seg && !missingAncestorSeg) {
        const parts = parentSegs && parentSegs.length ? parentSegs.concat([seg]) : [seg];
        return `dir:${parts.join('/')}`;
      }
      const title = displayTitleForNode(node);
      const tparts = parentTitles && parentTitles.length ? parentTitles.concat([title]) : [title];
      return `title:${tparts.join('/')}`;
    }

    function titlePathForId(id) {
      if (!id) return '';
      const info = findNode(stateTree, id);
      if (!info || !info.node) return '';
      const parts = [displayTitleForNode(info.node)];
      let p = info.parent;
      while (p) {
        parts.push(displayTitleForNode(p));
        const parentInfo = findNode(stateTree, p.id);
        p = parentInfo ? parentInfo.parent : null;
      }
      return parts.reverse().join('/');
    }

    function getTopVisibleRow(container, selector) {
      if (!container) return null;
      const rect = container.getBoundingClientRect();
      const rows = Array.from(container.querySelectorAll(selector));
      for (const row of rows) {
        const r = row.getBoundingClientRect();
        if (r.bottom > rect.top + 6) return row;
      }
      return rows[0] || null;
    }

    function buildTreeAnchor() {
      if (!els.tree) return null;
      const row = getTopVisibleRow(els.tree, '.tree-row');
      if (!row) return null;
      const li = row.closest('li.node');
      if (!li) return null;
      const type = li.dataset.type || '';
      if (type === 'page' && li.dataset.file) {
        return { type: 'page', file: String(li.dataset.file) };
      }
      if (type === 'folder') {
        const dir = folderDirForId(li.dataset.id || '');
        const titlePath = titlePathForId(li.dataset.id || '');
        return { type: 'folder', dir: dir || '', title_path: titlePath || '' };
      }
      return null;
    }

    function buildSourceAnchor() {
      if (!els.source) return null;
      const row = getTopVisibleRow(els.source, '.source-row');
      if (!row) return null;
      const li = row.closest('li.source-item');
      if (!li || !li.dataset.path) return null;
      return { path: String(li.dataset.path) };
    }

	    function buildTreeList(nodes, isRoot = false, depth = 0, parentSegs = [], parentTitles = []) {
	      const ul = document.createElement('ul');
	      ul.className = isRoot ? 'tree-root tree-explorer' : 'tree-children tree-explorer';
	      for (const node of (nodes || [])) {
        const li = document.createElement('li');
        li.className = 'node tree-item ' + (node.type === 'folder' ? 'dir' : 'page');
        li.draggable = true;
        li.dataset.id = node.id || '';
        li.dataset.type = node.type || 'page';
        li.dataset.title = node.title || '';
        li.dataset.segment = node.segment || '';
        li.dataset.file = node.file || '';
        li.dataset.depth = String(depth);

        if ((selectedIds && selectedIds.has(li.dataset.id)) || li.dataset.id === selectedId) li.classList.add('selected');

	        const row = document.createElement('div');
	        row.className = 'row tree-row ' + (node.type === 'folder' ? 'kind-dir' : 'kind-file');
	        row.style.paddingLeft = `${8 + depth * 8}px`;
        row.addEventListener('click', (e) => {
          e.stopPropagation();
          if (activeInlineEdit) return;
          selectWithModifiers(li.dataset.id, e);
        });

	        const left = document.createElement('div');
	        left.className = 'row-left';

	        const twist = document.createElement('span');
	        twist.className = 'tree-twist';
	        const isFolder = node.type === 'folder';
	        const collapseKey = isFolder ? collapseKeyForNode(node, parentSegs, parentTitles) : '';
	        const collapsed = isFolder && collapseKey && treeCollapsed.has(collapseKey);
	        const canExpand = isFolder;
	        twist.textContent = isFolder ? (collapsed ? '‚ñ∏' : '‚ñæ') : '';
        twist.addEventListener('click', (e) => {
          e.stopPropagation();
          if (!isFolder) return;
          toggleTreeDir(collapseKey);
        });
	        left.appendChild(twist);

	        const icon = document.createElement('span');
	        icon.className = 'tree-icon';
	        icon.textContent = isFolder ? 'üóÉÔ∏è' : 'üóíÔ∏è';
	        left.appendChild(icon);

		        const title = document.createElement('span');
		        title.className = 'node-title';
		        title.textContent = node && node.is_overview ? '' : displayTitleForNode(node);
	        title.addEventListener('dblclick', (e) => {
	          e.stopPropagation();
	          selectedId = li.dataset.id;
	          if (node && node.is_overview) return;
	          beginInlineEdit(li.dataset.id, 'title', title);
	        });
		        left.appendChild(title);

	        row.appendChild(left);

	        // Section overview slot (title-less): inline with section header.
	        if (isFolder) {
	          const children = Array.isArray(node.children) ? node.children : [];
	          const overview = children.find(c => c && c.type === 'page' && c.is_overview) || null;
	          const slot = document.createElement('div');
	          slot.className = 'overview-inline';
	          slot.dataset.overviewId = overview && overview.id ? String(overview.id) : '';
	          slot.dataset.folderId = li.dataset.id || '';
	          // Prevent row click/drag handlers from swallowing slot interactions.
	          slot.addEventListener('pointerdown', (e) => e.stopPropagation());
	          const label = document.createElement('span');
	          label.className = 'overview-label';
	          label.textContent = 'Display';
	          slot.appendChild(label);

	          const value = document.createElement('span');
	          value.className = 'overview-value';
	          slot.appendChild(value);

          if (overview && overview.file) {
            slot.classList.add('has-overview');
            slot.draggable = true;
            slot.dataset.id = overview && overview.id ? String(overview.id) : '';
            slot.dataset.type = 'page';
            slot.dataset.title = overview && overview.title ? String(overview.title) : '';
            slot.dataset.file = overview && overview.file ? String(overview.file) : '';
            if ((selectedIds && selectedIds.has(overview.id)) || selectedId === overview.id) slot.classList.add('selected');
            value.textContent = String(overview.file).replace(/^\.\//, '');
            slot.title = value.textContent;
            slot.addEventListener('dragstart', onDragStart);
            slot.addEventListener('dragend', onDragEnd);
            slot.addEventListener('click', (e) => {
              e.stopPropagation();
              if (activeInlineEdit) return;
              selectedDisplaySlotFolderId = '';
              selectNode(overview.id);
            });
	            slot.addEventListener('dblclick', (e) => {
	              e.stopPropagation();
	              if (activeInlineEdit) return;
	              selectedId = overview.id;
	              beginInlineEdit(overview.id, 'file', value);
	            });
		          } else {
		            slot.classList.add('empty');
		            value.textContent = '(none)';
		            slot.addEventListener('click', (e) => {
		              e.stopPropagation();
		              if (activeInlineEdit) return;
		              const folderId = li.dataset.id || '';
		              // Select the display slot itself (no page exists yet).
		              selectedId = '';
		              selectedIds = new Set();
		              selectionAnchorId = '';
		              selectionParentKey = '';
		              selectedDisplaySlotFolderId = folderId;
		              syncSelectionClasses();
		            });
		          }
	          row.appendChild(slot);
	        }

	        // Pages show file location; folders don't need to show "path/meta".
	        const meta = document.createElement('span');
	        meta.className = 'node-meta';
        if (isFolder) {
          meta.textContent = folderDirForId(li.dataset.id) || (node.segment ? `${node.segment}` : '');
          meta.addEventListener('dblclick', (e) => {
            e.stopPropagation();
            selectedId = li.dataset.id;
            beginInlineEdit(li.dataset.id, 'segment', meta);
          });
          row.appendChild(meta);
        } else {
          meta.textContent = node.file ? String(node.file).replace(/^\.\//, '') : '';
          meta.addEventListener('dblclick', (e) => {
            e.stopPropagation();
            selectedId = li.dataset.id;
            beginInlineEdit(li.dataset.id, 'file', meta);
          });
          row.appendChild(meta);
        }

        li.appendChild(row);

	        li.addEventListener('dragstart', onDragStart);
		        li.addEventListener('dragend', onDragEnd);

		        if (node.type === 'folder') {
		          const children = Array.isArray(node.children) ? node.children : [];
		          // Overview page is rendered in the header slot, not in the list.
		          const rest = children.filter(c => !(c && c.type === 'page' && c.is_overview));
		          const collapsed = collapseKey && treeCollapsed.has(collapseKey);
		          if (!collapsed && canExpand) {
		            const nextSegs = String((node.segment || '')).trim()
		              ? parentSegs.concat([String(node.segment).trim()])
		              : parentSegs;
		            const nextTitles = parentTitles.concat([displayTitleForNode(node)]);
		            li.appendChild(buildTreeList(rest, false, depth + 1, nextSegs, nextTitles));
		          } else {
	            // Keep an empty children container so folder still shows as a folder
	            // but without large nested blocks.
	            const emptyUl = document.createElement('ul');
	            emptyUl.className = 'tree-children tree-explorer is-collapsed';
            li.appendChild(emptyUl);
          }
        }
        ul.appendChild(li);
      }
      return ul;
    }

    function onDragStart(e) {
      // dragstart bubbles: prevent parent <li> handlers from overwriting draggedId
      e.stopPropagation();
      if (activeInlineEdit) {
        e.preventDefault();
        return;
      }
      if (e.currentTarget && e.currentTarget.classList && e.currentTarget.classList.contains('is-editing')) {
        e.preventDefault();
        return;
      }
      const id = e.currentTarget.dataset.id || '';
      if (selectedIds && selectedIds.size > 1 && selectedIds.has(id)) {
        draggedIds = Array.from(selectedIds);
      } else {
        draggedIds = id ? [id] : [];
        if (id && (!selectedIds || !selectedIds.has(id))) selectNode(id);
      }
      draggedId = draggedIds[0] || id || '';
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', draggedId);
      e.currentTarget.classList.add('dragging');
      pushDebug('drag.start', { draggedId, draggedIds, type: e.currentTarget.dataset.type || '', title: e.currentTarget.dataset.title || '' });
    }

    function onDragEnd(e) {
      // dragend bubbles too; keep state consistent
      e.stopPropagation();
      if (e && e.currentTarget) e.currentTarget.classList.remove('dragging');
      draggedId = '';
      draggedIds = [];
      clearDropVisual();
      pushDebug('drag.end', {});
    }

    function onTreeDragLeave(e) {
      if (!e) return;
      const related = e.relatedTarget;
      if (related && els.tree.contains(related)) {
        return;
      }
      clearDropVisual();
    }

    function onTreeDragOver(e) {
      if (!draggedId) return;
      e.preventDefault();
      updateDropHintFromPointer(e.clientX, e.clientY);
    }

    async function onTreeDrop(e) {
      if (!draggedId) return;
      e.preventDefault();
      pushDebug('drop.before', { draggedId, dropHint });
      await applyDrop();
      clearDropVisual();
      renderTree();
      if (dragMode === 'nav_only') {
        scheduleNavOnly('drag.drop.nav_only');
	      } else {
	        scheduleDragFilesSync('drag.drop.files');
	      }
	    }

	    function collectDraggedIdsForSync() {
	      const ids = (draggedIds && draggedIds.length) ? draggedIds : (draggedId ? [draggedId] : []);
	      return Array.from(new Set((ids || []).filter(Boolean)));
	    }

	    async function scheduleDragFilesSync(reason) {
	      if (autoSyncTimer) clearTimeout(autoSyncTimer);
	      const movedIds = collectDraggedIdsForSync();
	      autoSyncTimer = setTimeout(async () => {
	        autoSyncTimer = null;
	        pushDebug('auto_sync.run', { mode: 'drag_files', reason, movedIds });
	        setStatus('Syncing drag...', 'info');
	        try {
	          const data = await fetchJson('/api/sync_drag_files', {
	            method: 'POST',
	            headers: { 'Content-Type': 'application/json' },
	            body: JSON.stringify({ tree: stateTree, moved_ids: movedIds })
	          });
	          const moves = Array.isArray(data.moves) ? data.moves : [];
	          setStatus(`Drag synced.${moves.length ? ` moved:${moves.length}` : ''}`, 'success');
	          await loadState({ reset: false, silentStatus: true });
	          await loadSource();
	        } catch (e) {
	          const data = e && e.data ? e.data : null;
	          if (data && Array.isArray(data.collisions) && data.collisions.length) {
	            setStatus(`Drag blocked: file conflict (${data.collisions.length}). No changes applied.`, 'error');
	            pushDebug('drag.sync.blocked', { collisions: data.collisions });
	            await loadState({ reset: true, silentStatus: true });
	            await loadSource();
	            return;
	          }
	          setStatus(e.message || 'Drag sync failed.', 'error');
	        }
	      }, 250);
	    }

    function updateDropHintFromPointer(clientX, clientY) {
      const el = document.elementFromPoint(clientX, clientY);
      if (!el) {
        dropHint = { mode: 'root', targetId: '' };
        showRootDrop();
        logDropHint('root', '');
        return;
      }

      const li = el.closest('#tree li.node');
      if (!li) {
        // Over whitespace: if inside a folder's children box, treat as inside; otherwise root.
        const ul = el.closest('#tree ul');
        const parentFolder = ul ? ul.closest('li[data-type="folder"]') : null;
        if (parentFolder) {
          const folderId = parentFolder.dataset.id || '';
          dropHint = { mode: 'inside', targetId: folderId };
          showInside(parentFolder);
          logDropHint('inside', folderId);
        } else {
          dropHint = { mode: 'root', targetId: '' };
          showRootDrop();
          logDropHint('root', '');
        }
        return;
      }

      const targetId = li.dataset.id || '';
      const type = li.dataset.type || 'page';
      const row = li.querySelector(':scope > .row') || li;
      const rowRect = row.getBoundingClientRect();
      const ratio = rowRect.height ? ((clientY - rowRect.top) / rowRect.height) : 0.5;

      const inChildrenBox = type === 'folder' && (() => {
        const childUl = li.querySelector(':scope > ul');
        return childUl && childUl.contains(el) && !row.contains(el);
      })();

      if (inChildrenBox) {
        dropHint = { mode: 'inside', targetId };
        showInside(li);
        logDropHint('inside', targetId);
        return;
      }

      let mode = 'inside';
      if (ratio <= 0.25) mode = 'before';
      else if (ratio >= 0.75) mode = 'after';
      if (type === 'page' && mode === 'inside') mode = ratio < 0.5 ? 'before' : 'after';

      dropHint = { mode, targetId };
      if (mode === 'inside') showInside(li);
      else showLineAt(rowRect, mode === 'after');
      logDropHint(mode, targetId);
    }

    function logDropHint(mode, targetId) {
      const sig = `${mode}::${targetId}::${draggedId}::${(draggedIds || []).join(',')}`;
      const now = Date.now();
      if (sig === lastDropHintSignature && now - lastDragoverLogAt < 120) return;
      lastDropHintSignature = sig;
      lastDragoverLogAt = now;
      const target = targetId ? findNode(stateTree, targetId) : null;
      pushDebug('drag.over', {
        draggedId,
        draggedIds,
        mode,
        targetId,
        targetTitle: target ? target.node.title : null,
        targetType: target ? target.node.type : null
      });
    }

    async function applyDrop() {
      const { mode, targetId } = dropHint || {};
      if (!mode) return;

      // Never allow moving into/self/descendant; treat as no-op (keeps detector free).
      const ids = (draggedIds && draggedIds.length) ? draggedIds : (draggedId ? [draggedId] : []);
      const descendant = targetId ? ids.some(id => isDescendant(id, targetId)) : false;
      const selfHit = targetId ? ids.includes(targetId) : false;
      if (targetId && (selfHit || descendant)) {
        const dragged = findNode(stateTree, draggedId);
        const target = findNode(stateTree, targetId);
        pushDebug('drop.noop', {
          reason: selfHit ? 'self_or_group' : 'target_is_descendant',
          mode,
          draggedId,
          draggedIds: ids,
          draggedTitle: dragged ? dragged.node.title : null,
          draggedPath: nodePath(draggedId),
          targetId,
          targetTitle: target ? target.node.title : null,
          targetPath: nodePath(targetId),
        });
        setStatus(targetId === draggedId ? 'Invalid: dropped on itself.' : 'Invalid: cannot drop a parent into its child.', 'info');
        return;
      }

      if (mode === 'root') {
        pushDebug('drop.apply', { mode, targetId: '' });
        await withHistoryAsync('drop.root', () => moveNodes(ids, '', 'root'));
        setStatus('Moved.', 'success');
        return;
      }
      if (mode === 'inside') {
        pushDebug('drop.apply', { mode, targetId });
        await withHistoryAsync('drop.inside', () => moveNodes(ids, targetId, 'inside'));
        setStatus('Moved.', 'success');
        return;
      }
      if (mode === 'before' || mode === 'after') {
        pushDebug('drop.apply', { mode, targetId });
        await withHistoryAsync(`drop.${mode}`, () => moveNodes(ids, targetId, mode));
        setStatus('Moved.', 'success');
      }
    }

	    async function moveNodes(ids, targetId, mode) {
	      const list = Array.from(new Set((ids || []).filter(Boolean)));
	      if (!list.length) return;

	      // Overview pages are special:
	      // - Moving them converts to a normal page and prompts for a title.
	      const asNodes = list.map(id => {
	        const found = findNode(stateTree, id);
	        return found ? found.node : null;
	      }).filter(Boolean);

	      if (mode === 'root') {
	        const ctxs = detachManyWithContext(list);
	        const targetDir = targetFolderDirForMove('root', '');
	        for (const ctx of ctxs) {
	          if (!(await promptRenameForOverview(ctx, targetDir))) {
	            restoreAll(ctxs);
	            return;
	          }
	          stateTree.push(ctx.node);
	        }
	        return;
	      }

	      if (mode === 'inside') {
	        const targetInfo = findNode(stateTree, targetId);
	        if (!targetInfo || targetInfo.node.type !== 'folder') return;
	        targetInfo.node.children = Array.isArray(targetInfo.node.children) ? targetInfo.node.children : [];
	        const ctxs = detachManyWithContext(list);
	        const overviewIdx = targetInfo.node.children.findIndex(n => n && n.type === 'page' && n.is_overview);
	        const targetDir = targetFolderDirForMove('inside', targetId);
	        for (const ctx of ctxs) {
	          if (!(await promptRenameForOverview(ctx, targetDir))) {
	            restoreAll(ctxs);
	            return;
	          }
	          if (overviewIdx >= 0) targetInfo.node.children.splice(overviewIdx + 1, 0, ctx.node);
	          else targetInfo.node.children.push(ctx.node);
	        }
	        return;
	      }

	      if (mode === 'before' || mode === 'after') {
	        // Detach first, then re-find target to get correct index after removal.
	        const ctxs = detachManyWithContext(list);
	        const targetInfo = findNode(stateTree, targetId);
	        if (!targetInfo) return;
	        const siblings = targetInfo.siblings;
	        const idx = siblings.findIndex(n => n.id === targetId);
	        if (idx < 0) return;
	        let insertAt = mode === 'before' ? idx : idx + 1;
	        const overviewAt = siblings.findIndex(n => n && n.type === 'page' && n.is_overview);
	        if (overviewAt >= 0 && insertAt <= overviewAt + 0) {
	          // Never insert before the overview slot.
	          insertAt = overviewAt + 1;
	        }
	        const targetDir = targetFolderDirForMove(mode, targetId);
	        for (const ctx of ctxs) {
	          if (!(await promptRenameForOverview(ctx, targetDir))) {
	            restoreAll(ctxs);
	            return;
	          }
	          siblings.splice(insertAt, 0, ctx.node);
	          insertAt += 1;
	        }
	      }
	    }

    function isDescendant(dragId, targetId) {
      const drag = findNode(stateTree, dragId);
      const target = findNode(stateTree, targetId);
      if (!drag || !target) return false;
      let p = target.parent;
      while (p) {
        if (p.id === drag.node.id) return true;
        const parentInfo = findNode(stateTree, p.id);
        p = parentInfo ? parentInfo.parent : null;
      }
      return false;
    }

    function detachNode(id) {
      const found = findNode(stateTree, id);
      if (!found) return null;
      const idx = found.siblings.findIndex(n => n.id === id);
      if (idx < 0) return null;
      return found.siblings.splice(idx, 1)[0];
    }

    function detachNodeWithContext(id) {
      const found = findNode(stateTree, id);
      if (!found) return null;
      const idx = found.siblings.findIndex(n => n.id === id);
      if (idx < 0) return null;
      const node = found.siblings.splice(idx, 1)[0];
      return { node, siblings: found.siblings, index: idx };
    }

    function detachManyWithContext(ids) {
      const contexts = [];
      const byParent = new Map();
      for (const id of (ids || [])) {
        const found = findNode(stateTree, id);
        if (!found) continue;
        const idx = found.siblings.findIndex(n => n.id === id);
        if (idx < 0) continue;
        const parentKey = found.parent ? found.parent.id : 'root';
        if (!byParent.has(parentKey)) byParent.set(parentKey, []);
        byParent.get(parentKey).push({ id, siblings: found.siblings, index: idx, parentId: parentKey });
      }

      // Detach in descending index per parent to keep indices valid.
      for (const group of byParent.values()) {
        group.sort((a, b) => b.index - a.index);
        for (const item of group) {
          const node = item.siblings.splice(item.index, 1)[0];
          contexts.push({
            id: item.id,
            node,
            fromIndex: item.index,
            index: item.index,
            siblings: item.siblings,
            parentId: item.parentId
          });
        }
      }

      // Return in ascending original index order (stable visual order within parent).
      contexts.sort((a, b) => a.fromIndex - b.fromIndex);
      return contexts;
    }

    function slugifyFileBase(text) {
      const cleaned = String(text || '').trim().toLowerCase();
      const slug = cleaned.replace(/[^0-9a-z._-]+/g, '-').replace(/^-+|-+$/g, '');
      return slug || 'page';
    }

    function buildBasenameFromInput(input) {
      const raw = String(input || '').trim().replace(/\\/g, '/');
      if (!raw) return '';
      const name = raw.split('/').pop();
      if (!name) return '';
      const lower = name.toLowerCase();
      const allowed = ['.md', '.markdown', '.mdx'];
      if (allowed.some(ext => lower.endsWith(ext))) return name;
      if (name.includes('.')) return `${name}.md`;
      return `${slugifyFileBase(name)}.md`;
    }

    function normalizeTitleToSnake(text, fallbackWord) {
      let cleaned = String(text || '').normalize('NFKC').trim();
      cleaned = cleaned.replace(/c\+\+/gi, ' cpp ');
      cleaned = cleaned.replace(/c#/gi, ' csharp ');
      cleaned = cleaned.replace(/\+\+/g, ' plus plus ');
      cleaned = cleaned.replace(/\+/g, ' plus ');
      cleaned = cleaned.replace(/#/g, ' sharp ');
      cleaned = cleaned.replace(/[^\p{L}\p{N}_]+/gu, '_');
      cleaned = cleaned.replace(/_+/g, '_').replace(/^_+|_+$/g, '');
      if (!cleaned) return String(fallbackWord || 'item').toLowerCase();
      return cleaned.toLowerCase();
    }

    function formatNameByDepth(title, depth, fallbackWord) {
      return normalizeTitleToSnake(title, fallbackWord);
    }

    function fileExtForNode(node) {
      const name = String(node && node.file ? node.file : '').split('/').pop() || '';
      const lower = name.toLowerCase();
      if (lower.endsWith('.markdown')) return '.markdown';
      if (lower.endsWith('.mdx')) return '.mdx';
      if (lower.endsWith('.md')) return '.md';
      return '.md';
    }

    function overviewBasenameForNode(node) {
      const name = String(node && node.file ? node.file : '').split('/').pop() || '';
      const lower = name.toLowerCase();
      if (lower === 'readme.md' || lower === 'index.md') return name || 'README.md';
      return 'README.md';
    }

    function targetFolderDirForMove(mode, targetId) {
      if (mode === 'root') return '';
      if (mode === 'inside') return folderDirForId(targetId);
      const targetInfo = findNode(stateTree, targetId);
      if (targetInfo && targetInfo.parent && targetInfo.parent.type === 'folder') {
        return folderDirForId(targetInfo.parent.id);
      }
      return '';
    }

    async function promptRenameForOverview(ctx, targetDir) {
      if (!ctx || !ctx.node || !ctx.node.is_overview) return true;
      const currentTitle = String(ctx.node.title || '').trim() || 'Overview';
      const nextTitle = await showPrompt('Moving a section overview page. Enter a new title (used for filename):', {
        title: 'Rename Overview',
        okText: 'Rename',
        cancelText: 'Cancel',
        defaultValue: currentTitle
      });
      if (nextTitle === null) return false;
      const trimmedTitle = String(nextTitle).trim() || currentTitle;
      const basename = buildBasenameFromInput(trimmedTitle);
      if (!basename) return false;
      const desiredRel = targetDir ? `${targetDir}/${basename}` : basename;
      if (ctx.node.file && !ctx.node.file_prev) ctx.node.file_prev = ctx.node.file;
      ctx.node.title = trimmedTitle;
      ctx.node.file = desiredRel;
      ctx.node.is_overview = false;
      return true;
    }

    function restoreAll(ctxs) {
      const sorted = Array.from(ctxs || []).sort((a, b) => (b.index || 0) - (a.index || 0));
      sorted.forEach(restoreDetached);
    }

    function nodePath(id) {
      if (!id) return [];
      const found = findNode(stateTree, id);
      if (!found) return [];
      const parts = [found.node.title || found.node.id];
      let p = found.parent;
      while (p) {
        parts.push(p.title || p.id);
        const parentInfo = findNode(stateTree, p.id);
        p = parentInfo ? parentInfo.parent : null;
      }
      return parts.reverse();
    }

    function restoreDetached(ctx) {
      if (!ctx || !ctx.node || !ctx.siblings) return;
      const idx = typeof ctx.index === 'number' ? ctx.index : ctx.siblings.length;
      ctx.siblings.splice(Math.min(Math.max(idx, 0), ctx.siblings.length), 0, ctx.node);
    }

    function moveNodeToRoot(id) {
      const ctx = detachNodeWithContext(id);
      if (!ctx) return;
      pushDebug('move.root', { id, title: ctx.node.title, fromIndex: ctx.index, fromPath: nodePath(id) });
      stateTree.push(ctx.node);
      pushDebug('move.root.done', { rootCount: stateTree.length });
    }

    function moveIntoFolder(dragId, folderId) {
      const folder = findNode(stateTree, folderId);
      if (!folder || folder.node.type !== 'folder') return;
      const ctx = detachNodeWithContext(dragId);
      if (!ctx) return;
      folder.node.children = Array.isArray(folder.node.children) ? folder.node.children : [];
      pushDebug('move.inside', {
        dragId,
        folderId,
        fromPath: nodePath(dragId),
        toPath: nodePath(folderId),
        insertIndex: folder.node.children.length
      });
      folder.node.children.push(ctx.node);
    }

    function moveNode(dragId, targetId, mode) {
      const targetInfo = findNode(stateTree, targetId);
      if (!targetInfo) return;
      const ctx = detachNodeWithContext(dragId);
      if (!ctx) return;

      if (mode === 'inside' && targetInfo.node.type === 'folder') {
        targetInfo.node.children = Array.isArray(targetInfo.node.children) ? targetInfo.node.children : [];
        targetInfo.node.children.push(ctx.node);
        return;
      }
      const siblings = targetInfo.siblings;
      const idx = siblings.findIndex(n => n.id === targetId);
      if (idx < 0) {
        pushDebug('move.restore', { reason: 'target_missing', dragId, targetId });
        restoreDetached(ctx);
        return;
      }
      pushDebug('move.sibling', {
        dragId,
        targetId,
        mode,
        targetIndex: idx,
        insertIndex: mode === 'before' ? idx : idx + 1,
        toParent: targetInfo.parent ? (targetInfo.parent.title || targetInfo.parent.id) : null
      });
      siblings.splice(mode === 'before' ? idx : idx + 1, 0, ctx.node);
    }

    function clearDropVisual() {
      dropHint = { mode: null, targetId: null };
      els.tree.classList.remove('drop-root');
      hideDropLine();
      document.querySelectorAll('#tree .drop-before, #tree .drop-after, #tree .drop-inside')
        .forEach(el => el.classList.remove('drop-before', 'drop-after', 'drop-inside'));
    }

    function hideDropLine() {
      if (!dropLineEl) return;
      dropLineEl.style.display = 'none';
    }

    function showRootDrop() {
      els.tree.classList.add('drop-root');
      hideDropLine();
      document.querySelectorAll('#tree .drop-inside').forEach(el => el.classList.remove('drop-inside'));
    }

    function showInside(li) {
      els.tree.classList.remove('drop-root');
      hideDropLine();
      document.querySelectorAll('#tree .drop-inside').forEach(el => el.classList.remove('drop-inside'));
      if (li) li.classList.add('drop-inside');
    }

    function showLineAt(targetRect, placeAfter) {
      els.tree.classList.remove('drop-root');
      document.querySelectorAll('#tree .drop-inside').forEach(el => el.classList.remove('drop-inside'));
      if (!dropLineEl) return;
      const containerRect = els.tree.getBoundingClientRect();
      const y = (placeAfter ? targetRect.bottom : targetRect.top) - containerRect.top + els.tree.scrollTop;
      dropLineEl.style.top = (y - 1) + 'px';
      dropLineEl.style.display = 'block';
    }

	    async function createNode(type) {
	      const creatingDisplay = type === 'page' && !!selectedDisplaySlotFolderId;
	      const title = creatingDisplay
	        ? 'Overview'
	        : await showPrompt(type === 'folder' ? 'Section title:' : 'Page title:', {
	          title: type === 'folder' ? 'New Section' : 'New Page',
	          okText: 'Create',
	          cancelText: 'Cancel'
	        });
	      if (!title || !title.trim()) {
	        setStatus('‚ö†Ô∏è Title is required. Creation cancelled.', 'info');
	        return;
	      }

	      const parentDir = (() => {
	        if (selectedDisplaySlotFolderId) return folderDirForId(selectedDisplaySlotFolderId);
	        if (!selectedId) return '';
	        const info = findNode(stateTree, selectedId);
	        if (!info) return '';
	        if (info.node.type === 'folder') return folderDirForId(info.node.id);
	        if (info.parent && info.parent.type === 'folder') return folderDirForId(info.parent.id);
	        return '';
	      })();
	      {
	        const id = selectedId || selectedDisplaySlotFolderId;
	        const info = id ? findNode(stateTree, id) : null;
	        const meta = info && info.node ? {
	          id,
	          type: info.node.type,
	          title: info.node.title,
	          segment: info.node.segment,
	          file: info.node.file
	        } : { id };
	        console.warn('[createNode] parent_dir', { parentDir, meta, selectedId, selectedDisplaySlotFolderId });
	        if (!parentDir) {
	          setStatus('‚ö†Ô∏è parent_dir is empty; creation will go to root. Check selection/segment.', 'info');
	        }
	      }

	      let newId = '';
	      withHistory('create', () => {
	        const parentInfo = selectedDisplaySlotFolderId
	          ? findNode(stateTree, selectedDisplaySlotFolderId)
	          : (selectedId ? findNode(stateTree, selectedId) : null);
	        let container = stateTree;
	        if (parentInfo) {
	          if (parentInfo.node.type === 'folder') {
	            parentInfo.node.children = Array.isArray(parentInfo.node.children) ? parentInfo.node.children : [];
	            container = parentInfo.node.children;
	          } else if (parentInfo.parent && parentInfo.parent.type === 'folder') {
	            parentInfo.parent.children = Array.isArray(parentInfo.parent.children) ? parentInfo.parent.children : [];
	            container = parentInfo.parent.children;
	          }
	        }

	        const id = crypto && crypto.randomUUID ? crypto.randomUUID().replace(/-/g, '') : String(Date.now());
	        newId = id;
	        if (type === 'folder') {
	          container.push({ id, type: 'folder', title: title.trim(), segment: '', file: null, children: [] });
	        } else {
	          // If user clicked an empty Display slot, create a dedicated overview page (title-less, fixed slot).
	          if (creatingDisplay) {
	            const already = container.find(n => n && n.type === 'page' && n.is_overview);
	            if (!already) container.unshift({ id, type: 'page', title: '', is_overview: true, file: null, file_prev: null, segment: null, children: [] });
	          } else {
	            container.push({ id, type: 'page', title: title.trim(), file: null, file_prev: null, segment: null, children: [] });
	          }
	        }
	      });
	      renderTree();
	      updateHistoryButtons();

	      // Create on disk immediately.
	      if (type === 'folder') {
	        try {
	          const data = await fetchJson('/api/create_section', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ title: title.trim(), parent_dir: parentDir })
          });
	          const found = findNode(stateTree, newId);
	          if (found && found.node && found.node.type === 'folder') {
	            found.node.segment = data.segment || found.node.segment || '';
	          }
	          // Create default section README (overview) as the first page under this folder.
	          const newFolderDir = folderDirForId(newId);
	          const pageId = crypto && crypto.randomUUID ? crypto.randomUUID().replace(/-/g, '') : String(Date.now() + 1);
	          withHistory('create.section_overview', () => {
	            const info = findNode(stateTree, newId);
	            if (!info || !info.node || info.node.type !== 'folder') return;
	            info.node.children = Array.isArray(info.node.children) ? info.node.children : [];
	            info.node.children.unshift({ id: pageId, type: 'page', title: '', is_overview: true, file: null, file_prev: null, segment: null, children: [] });
	          });
	          renderTree();
	          updateHistoryButtons();
	          try {
	            const pageData = await fetchJson('/api/create_page', {
	              method: 'POST',
	              headers: { 'Content-Type': 'application/json' },
	              body: JSON.stringify({ title: 'Overview', parent_dir: newFolderDir, basename: 'README.md' })
	            });
	            const pageFound = findNode(stateTree, pageId);
	            if (pageFound && pageFound.node && pageFound.node.type === 'page') {
	              pageFound.node.file = pageData.file || pageFound.node.file;
	              pageFound.node.file_prev = null;
	            }
	          } catch (e) {
	            pushDebug('create.section_overview.failed', { error: e.message || String(e) });
	          }
	          renderTree();
	          await loadSource();
	          setStatus('Section created on disk.', 'success');
	          scheduleNavOnly('create.section');
	        } catch (e) {
          setStatus(e.message || 'Create section failed.', 'error');
        }
        return;
      }

	      try {
	        const data = await fetchJson('/api/create_page', {
	          method: 'POST',
	          headers: { 'Content-Type': 'application/json' },
	          body: JSON.stringify(creatingDisplay
	            ? { title: 'Overview', parent_dir: parentDir, basename: 'README.md' }
	            : { title: title.trim(), parent_dir: parentDir })
	        });
	        const found = findNode(stateTree, newId);
	        if (found && found.node && found.node.type === 'page') {
	          found.node.file = data.file || found.node.file;
	          found.node.file_prev = null;
	          if (creatingDisplay) found.node.is_overview = true;
	        }
	        renderTree();
	        await loadSource();
	        setStatus(creatingDisplay ? 'Display page created.' : 'Page created on disk.', 'success');
	        scheduleNavOnly(creatingDisplay ? 'create.display' : 'create.page');
	      } catch (e) {
	        setStatus(e.message || '‚õîÔ∏è Create page failed.', 'error');
	      }
	    }

	    async function createPageWithFolder() {
	      if (activeInlineEdit) return;
	      const title = await showPrompt('Page title (folder + file will use the same name):', {
	        title: 'New Page + Folder',
	        okText: 'Create',
	        cancelText: 'Cancel'
	      });
	      if (!title || !title.trim()) {
	        setStatus('‚ö†Ô∏è Title is required. Creation cancelled.', 'info');
	        return;
	      }
	      const cleanTitle = title.trim();

	      const parentDir = (() => {
	        if (selectedDisplaySlotFolderId) return folderDirForId(selectedDisplaySlotFolderId);
	        if (!selectedId) return '';
	        const info = findNode(stateTree, selectedId);
	        if (!info) return '';
	        if (info.node.type === 'folder') return folderDirForId(info.node.id);
	        if (info.parent && info.parent.type === 'folder') return folderDirForId(info.parent.id);
	        return '';
	      })();
	      {
	        const id = selectedId || selectedDisplaySlotFolderId;
	        const info = id ? findNode(stateTree, id) : null;
	        const meta = info && info.node ? {
	          id,
	          type: info.node.type,
	          title: info.node.title,
	          segment: info.node.segment,
	          file: info.node.file
	        } : { id };
	        console.warn('[createPageWithFolder] parent_dir', { parentDir, meta, selectedId, selectedDisplaySlotFolderId });
	        if (!parentDir) {
	          setStatus('‚ö†Ô∏è parent_dir is empty; creation will go to root. Check selection/segment.', 'info');
	        }
	      }

	      let pageId = '';
	      withHistory('create.page_with_folder', () => {
	        const parentInfo = selectedDisplaySlotFolderId
	          ? findNode(stateTree, selectedDisplaySlotFolderId)
	          : (selectedId ? findNode(stateTree, selectedId) : null);
	        let container = stateTree;
	        if (parentInfo) {
	          if (parentInfo.node.type === 'folder') {
	            parentInfo.node.children = Array.isArray(parentInfo.node.children) ? parentInfo.node.children : [];
	            container = parentInfo.node.children;
	          } else if (parentInfo.parent && parentInfo.parent.type === 'folder') {
	            parentInfo.parent.children = Array.isArray(parentInfo.parent.children) ? parentInfo.parent.children : [];
	            container = parentInfo.parent.children;
	          }
	        }

	        pageId = crypto && crypto.randomUUID ? crypto.randomUUID().replace(/-/g, '') : String(Date.now() + 1);
	        container.push({ id: pageId, type: 'page', title: cleanTitle, file: null, file_prev: null, segment: null, children: [] });
	      });

	      renderTree();
	      updateHistoryButtons();
	      setStatus('Creating folder + page...', 'info');

	      try {
	        const page = await fetchJson('/api/create_page_with_folder', {
	          method: 'POST',
	          headers: { 'Content-Type': 'application/json' },
	          body: JSON.stringify({ title: cleanTitle, parent_dir: parentDir })
	        });
	        const pageFound = findNode(stateTree, pageId);
	        if (pageFound && pageFound.node && pageFound.node.type === 'page') {
	          pageFound.node.file = page.file || pageFound.node.file;
	          pageFound.node.file_prev = null;
	        }
	        renderTree();
	        await loadSource();
	        setStatus('‚úÖ Page + folder created on disk.', 'success');
	        scheduleNavOnly('create.page_with_folder');
	      } catch (e) {
	        setStatus(e.message || '‚õîÔ∏è Create page + folder failed.', 'error');
	      }
	    }

    function renameSelected() {
      if (!selectedId) return setStatus('‚ö†Ô∏è Select a node first.', 'info');
      const rowTitle = document.querySelector(`#tree li[data-id="${selectedId}"] .node-title`);
      if (!rowTitle) return setStatus('‚ö†Ô∏è Selected node not visible (expand parent folders).', 'info');
      beginInlineEdit(selectedId, 'title', rowTitle);
    }

    function isProtectedTitle(title) {
      const upper = String(title || '').trim().toUpperCase();
      return upper === 'HOME' || upper === 'JOURNAL';
    }

    async function normalizeTreeNames() {
      if (!Array.isArray(stateTree) || !stateTree.length) {
        setStatus('No doc tree loaded to normalize.', 'info');
        return;
      }
      const ok = await showConfirm(
        'This will rename files and folders on disk based on the YAML nav titles (keys stay the same). HOME and JOURNAL are skipped. Continue?',
        { title: 'Normalize Files', okText: 'Rename Files', cancelText: 'Cancel' }
      );
      if (!ok) return;

      const beforeTree = deepClone(stateTree);

      const folderPlans = [];
      const pagePlans = [];
      const planErrors = [];
      const plannedDirOlds = new Set();
      const plannedDirNews = new Set();

      const planWalk = (nodes, depth, parentSegments) => {
        for (const node of (nodes || [])) {
          if (!node) continue;
          if (node.type === 'folder') {
            if (isProtectedTitle(node.title)) continue;
            const seg = formatNameByDepth(node.title, depth, 'section');
            const oldDir = folderDirForId(node.id);
            if (seg && node.segment !== seg) {
              folderPlans.push({ id: node.id, oldDir, newSeg: seg, depth: parentSegments.length });
            }
            const nextSegments = parentSegments.concat(seg || node.segment || '');
            planWalk(node.children || [], depth + 1, nextSegments);
          } else if (node.type === 'page') {
            if (isProtectedTitle(node.title)) continue;
            if (!node.file) continue;
            const base = node.is_overview
              ? overviewBasenameForNode(node)
              : `${formatNameByDepth(node.title, depth, 'page')}${fileExtForNode(node)}`;
            const currentRel = String(node.file || '').replace(/^\.\//, '');
            const slashAt = currentRel.lastIndexOf('/');
            const currentDir = slashAt >= 0 ? currentRel.slice(0, slashAt) : '';
            const currentDirParts = currentDir ? currentDir.split('/').filter(Boolean) : [];
            const parentDir = parentSegments.join('/');
            let targetDir = parentDir;
            if (currentDirParts.length) {
              const tail = currentDirParts.length > parentSegments.length
                ? currentDirParts.slice(parentSegments.length)
                : [];
              targetDir = parentDir && tail.length ? `${parentDir}/${tail.join('/')}` : (parentDir || currentDir);
            }
            const newRel = targetDir ? `${targetDir}/${base}` : base;
            const newBase = newRel.split('/').pop() || base;
            const oldBase = currentRel.split('/').pop() || '';
            if (newRel && currentRel && newRel !== currentRel) {
              pagePlans.push({
                id: node.id,
                targetDir,
                oldBase,
                newBase,
                currentRel,
                newRel,
                needsRename: !!(newBase && oldBase && newBase !== oldBase)
              });
            }
          }
        }
      };

      planWalk(stateTree, 1, []);

      for (const plan of folderPlans) {
        if (!plan.oldDir || !plan.newSeg) continue;
        const parentDir = plan.oldDir.split('/').slice(0, -1).join('/');
        const newDir = parentDir ? `${parentDir}/${plan.newSeg}` : plan.newSeg;
        if (plannedDirNews.has(newDir)) {
          planErrors.push({ type: 'duplicate_target', target: newDir });
        }
        plannedDirOlds.add(plan.oldDir);
        plannedDirNews.add(newDir);
      }
      for (const plan of pagePlans) {
        const dir = plan.targetDir || '';
        const newFile = dir ? `${dir}/${plan.newBase}` : plan.newBase;
        if (plannedDirNews.has(dir) || plannedDirOlds.has(dir)) {
          // ok: parent renamed in same operation
        }
        if (!plan.newBase || plan.newBase === plan.oldBase) continue;
        if (plannedDirNews.has(newFile) || plannedDirOlds.has(newFile)) {
          planErrors.push({ type: 'duplicate_target', target: newFile });
        }
        plannedDirNews.add(newFile);
      }

      if (planErrors.length) {
        showSyncErrors('Normalize blocked: duplicate targets.', planErrors);
        setStatus('Normalize blocked: duplicate targets.', 'error');
        return;
      }

      try {
        const preflight = await fetchJson('/api/preflight_renames', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            dirs: folderPlans.map(p => ({ dir: p.oldDir, new_segment: p.newSeg })),
            files: pagePlans.map(p => ({
              old_file: p.currentRel,
              new_basename: p.newBase,
              dir_after: p.targetDir || ''
            }))
          })
        });
        const preErrors = preflight && Array.isArray(preflight.errors) ? preflight.errors : [];
        if (preErrors.length) {
          showSyncErrors('Normalize blocked: preflight failed.', preErrors);
          setStatus('Normalize blocked: preflight failed.', 'error');
          return;
        }
      } catch (e) {
        const msg = e && e.message ? e.message : 'Normalize failed (preflight).';
        const details = e && e.data ? [e.data] : [{ error: msg }];
        showSyncErrors(msg, details);
        setStatus(msg, 'error');
        return;
      }

      folderPlans.sort((a, b) => b.depth - a.depth);
      for (const plan of folderPlans) {
        if (!plan.oldDir || !plan.newSeg) continue;
        try {
          const data = await fetchJson('/api/rename_dir', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ dir: plan.oldDir, new_segment: plan.newSeg })
          });
          const nodeInfo = findNode(stateTree, plan.id);
          if (nodeInfo && nodeInfo.node) {
            nodeInfo.node.segment = data.segment || plan.newSeg;
          }
        } catch (e) {
          const msg = e && e.message ? e.message : 'Normalize failed (rename folder).';
          const details = e && e.data ? [e.data] : [{ error: msg, dir: plan.oldDir, new_segment: plan.newSeg }];
          showSyncErrors(msg, details);
          setStatus(msg, 'error');
          await loadState({ reset: true, silentStatus: true });
          await loadSource();
          return;
        }
      }

      for (const plan of pagePlans) {
        const dir = plan.targetDir || '';
        const oldFile = dir ? `${dir}/${plan.oldBase}` : plan.oldBase;
        const nodeInfo = findNode(stateTree, plan.id);
        if (!nodeInfo || !nodeInfo.node) continue;
        if (!plan.needsRename) {
          // Folder rename only: update path in state without renaming on disk.
          nodeInfo.node.file = plan.newRel || nodeInfo.node.file;
          nodeInfo.node.file_prev = null;
          continue;
        }
        try {
          const data = await fetchJson('/api/rename_file', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ old_file: oldFile, new_basename: plan.newBase })
          });
          nodeInfo.node.file = data.file || (dir ? `${dir}/${plan.newBase}` : plan.newBase);
          nodeInfo.node.file_prev = null;
        } catch (e) {
          const msg = e && e.message ? e.message : 'Normalize failed (rename file).';
          const details = e && e.data ? [e.data] : [{ error: msg, file: oldFile, new_basename: plan.newBase }];
          showSyncErrors(msg, details);
          setStatus(msg, 'error');
          await loadState({ reset: true, silentStatus: true });
          await loadSource();
          return;
        }
      }

      applyFilePrevFromCurrent(stateTree, buildFileMap(beforeTree));
      renderTree();
      updateHistoryButtons();
      const sectionChanges = [];
      for (const plan of folderPlans) {
        if (!plan.oldDir || !plan.newSeg) continue;
        const parentDir = plan.oldDir.split('/').slice(0, -1).join('/');
        const newDir = parentDir ? `${parentDir}/${plan.newSeg}` : plan.newSeg;
        if (newDir && plan.oldDir && newDir !== plan.oldDir) {
          sectionChanges.push(`section ${plan.oldDir} -> ${newDir}`);
        }
      }
      const pageChanges = [];
      for (const plan of pagePlans) {
        if (!plan.currentRel || !plan.newRel) continue;
        if (plan.currentRel === plan.newRel) continue;
        pageChanges.push(`page ${plan.currentRel} -> ${plan.newRel}`);
      }
      const changes = sectionChanges.concat(pageChanges);
      const maxDetails = 200;
      const detailLines = changes.slice(0, maxDetails);
      if (changes.length > maxDetails) {
        detailLines.push(`... and ${changes.length - maxDetails} more`);
      }
      const sectionCount = sectionChanges.length;
      const pageCount = pageChanges.length;
      setStatus(`‚úÖ Normalized ${sectionCount} section(s), ${pageCount} page(s).`, 'success');
      showInfoDetails(`Normalize changes (${changes.length})`, detailLines);
      scheduleNavOnly('normalize.names');
    }

    function beginInlineEdit(id, field, hostEl) {
      if (!id || !hostEl) return;
      const info = findNode(stateTree, id);
      if (!info) return setStatus('‚ö†Ô∏è Node not found.', 'error');

      if (activeInlineEdit && activeInlineEdit.id === id && activeInlineEdit.field === field) return;
      if (activeInlineEdit) cancelInlineEdit();

      const li = hostEl.closest('li.node');
      if (!li) return;

      const originalValue =
        field === 'file' ? (info.node.file || '') :
          field === 'segment' ? (info.node.segment || '') :
            (info.node.title || '');
      const originalDir = (() => {
        if (field !== 'file') return '';
        const p = String(originalValue || '').replace(/^\.\//, '');
        const idx = p.lastIndexOf('/');
        return idx >= 0 ? p.slice(0, idx + 1) : '';
      })();
      const startValue =
        field === 'file' ? (() => {
          const p = String(originalValue || '').replace(/^\.\//, '');
          const idx = p.lastIndexOf('/');
          return idx >= 0 ? p.slice(idx + 1) : p;
        })() :
          field === 'segment' ? originalValue :
            displayTitleForNode(info.node);

      const input = document.createElement('input');
      input.type = 'text';
      input.className = 'inline-edit';
      input.value = startValue;
      input.spellcheck = false;
      input.draggable = false;

      const prevText = hostEl.textContent || '';
      hostEl.textContent = '';
      hostEl.appendChild(input);

      const prevDraggable = li.draggable;
      li.draggable = false;
      li.classList.add('is-editing');

      activeInlineEdit = { id, field, hostEl, input, prevText, prevDraggable, originalValue, originalDir };

      const finish = (mode) => {
        if (!activeInlineEdit) return;
        const current = activeInlineEdit;
        if (current.input) current.input.removeEventListener('keydown', onKeyDown);
        if (current.input) current.input.removeEventListener('blur', onBlur);
        li.draggable = current.prevDraggable;
        li.classList.remove('is-editing');
        const value = (current.input && current.input.value ? current.input.value : '').trim();
        activeInlineEdit = null;

        if (mode === 'cancel') {
          current.hostEl.textContent = current.prevText;
          return;
        }

        if (current.field === 'title') {
          if (!value) {
            current.hostEl.textContent = current.prevText;
            return;
          }
          if (value === String(current.originalValue || '')) {
            current.hostEl.textContent = current.prevText;
            return;
          }
          withHistory('edit.title', () => {
            const nodeInfo = findNode(stateTree, current.id);
            if (nodeInfo) nodeInfo.node.title = value;
          });
          renderTree();
          updateHistoryButtons();
          setStatus('Renamed.', 'success');
          scheduleNavOnly('rename.title');
          return;
        }

        if (current.field === 'segment') {
          if (value.includes('/') || value.includes('\\')) {
            setStatus('Folder name cannot contain slashes.', 'error');
            current.hostEl.textContent = current.prevText;
            return;
          }
          const oldDir = folderDirForId(current.id);
          const newSeg = value.trim();
          if (newSeg === String(current.originalValue || '').trim()) {
            current.hostEl.textContent = current.prevText;
            return;
          }
          (async () => {
            setStatus('Renaming folder...', 'info');
            try {
              const data = await fetchJson('/api/rename_dir', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ dir: oldDir, new_segment: newSeg })
              });
              const newDir = data.dir || oldDir;
              withHistory('edit.segment', () => {
                const nodeInfo = findNode(stateTree, current.id);
                if (!nodeInfo) return;
                nodeInfo.node.segment = data.segment || newSeg;
                updateDescendantPagePaths(current.id, oldDir, newDir);
              });
              renderTree();
              updateHistoryButtons();
              await loadSource();
              setStatus('Folder renamed on disk.', 'success');
              scheduleNavOnly('rename.segment');
            } catch (e) {
              setStatus(e.message || 'Rename folder failed.', 'error');
              renderTree();
            }
          })();
          return;
        }

        if (current.field === 'file') {
          if (value.includes('/') || value.includes('\\')) {
            setStatus('Filename only (no directories).', 'error');
            current.hostEl.textContent = current.prevText;
            return;
          }
          const oldFile = String(current.originalValue || '').replace(/^\.\//, '').trim();
          const newBase = value.trim();
          const oldBase = oldFile.split('/').pop() || '';
          if (newBase === oldBase) {
            current.hostEl.textContent = current.prevText;
            return;
          }
          if (!oldFile) {
            setStatus('Cannot rename: missing old file path.', 'error');
            return;
          }
          (async () => {
            setStatus('Renaming file...', 'info');
            try {
              const data = await fetchJson('/api/rename_file', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ old_file: oldFile, new_basename: newBase })
              });
              withHistory('edit.file', () => {
                const nodeInfo = findNode(stateTree, current.id);
                if (!nodeInfo) return;
                nodeInfo.node.file = data.file || nodeInfo.node.file;
                nodeInfo.node.file_prev = null;
              });
              renderTree();
              updateHistoryButtons();
              await loadSource();
              setStatus('File renamed on disk.', 'success');
              scheduleNavOnly('rename.file');
            } catch (e) {
              setStatus(e.message || 'Rename file failed.', 'error');
              renderTree();
            }
          })();
          return;
        }
      };

      const onKeyDown = (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          finish('commit');
        } else if (e.key === 'Escape') {
          e.preventDefault();
          finish('cancel');
        }
      };
      const onBlur = () => finish('commit');

      input.addEventListener('keydown', onKeyDown);
      input.addEventListener('blur', onBlur);

      requestAnimationFrame(() => {
        input.focus();
        input.select();
      });
    }

    function cancelInlineEdit() {
      if (!activeInlineEdit) return;
      const current = activeInlineEdit;
      const li = current.hostEl.closest('li.node');
      if (current.input) current.input.remove();
      if (li) {
        li.draggable = current.prevDraggable;
        li.classList.remove('is-editing');
      }
      current.hostEl.textContent = current.prevText;
      activeInlineEdit = null;
    }

    function updateDescendantPagePaths(folderId, oldDir, newDir) {
      const info = findNode(stateTree, folderId);
      if (!info || !info.node || info.node.type !== 'folder') return;
      const oldPrefix = oldDir ? `${oldDir.replace(/\\/g, '/')}/` : '';
      const newPrefix = newDir ? `${newDir.replace(/\\/g, '/')}/` : '';
      const walk = (node) => {
        if (!node) return;
        if (node.type === 'page') {
          if (node.file && oldPrefix && node.file.startsWith(oldPrefix)) {
            node.file = newPrefix + node.file.slice(oldPrefix.length);
          }
          if (node.file_prev && oldPrefix && node.file_prev.startsWith(oldPrefix)) {
            node.file_prev = newPrefix + node.file_prev.slice(oldPrefix.length);
          }
          return;
        }
        for (const c of (node.children || [])) walk(c);
      };
      for (const c of (info.node.children || [])) walk(c);
    }

    async function deleteSelected() {
      if ((!selectedId || !findNode(stateTree, selectedId)) && (!selectedIds || !selectedIds.size)) {
        return setStatus('‚ö†Ô∏è Select a node first.', 'info');
      }
      const ids = selectedIds && selectedIds.size ? Array.from(selectedIds) : [selectedId];
      const folderCheck = classifyFoldersForDelete(ids);
      if (folderCheck.blocking.length) {
        const first = folderCheck.blocking[0];
        return setStatus(`‚ö†Ô∏è Cannot delete non-empty folder "${first.title}". Move its pages first.`, 'info');
      }

      const filesToDelete = collectFilesForIds(ids);
      const dirsToDelete = folderCheck.emptyDirs;
      const hasFiles = filesToDelete.length > 0;
      const hasDirs = dirsToDelete.length > 0;
      const navOnly = dragMode === 'nav_only';
      const overviewFiles = (() => {
        const out = new Set();
        for (const id of ids) {
          const found = findNode(stateTree, id);
          if (!found || !found.node || found.node.type !== 'folder') continue;
          const children = Array.isArray(found.node.children) ? found.node.children : [];
          const overview = children.find(c => c && c.type === 'page' && c.is_overview && c.file);
          if (overview && overview.file) out.add(String(overview.file).replace(/^\.\//, '').trim());
        }
        return out;
      })();
      const nonOverviewFiles = filesToDelete.filter(f => !overviewFiles.has(f));
      const emptyOnly = hasDirs && nonOverviewFiles.length === 0;
      const skipEmptyDeleteConfirm = skipEmptyDeleteConfirmSession;

      const summary = [
        `Delete ${ids.length} item(s) from the tree`,
        hasFiles ? `delete ${filesToDelete.length} page file(s) on disk` : null,
        hasDirs ? `delete ${dirsToDelete.length} empty folder(s) on disk` : null,
      ].filter(Boolean).join(', ') + '. Continue?';
      if (emptyOnly && !navOnly) {
        if (!skipEmptyDeleteConfirm) {
          const res = await showChoice({
            title: 'Delete',
            message: summary,
            cancelValue: false,
            input: {
              type: 'checkbox',
              value: false,
            label: 'Do not ask again for empty-folder deletes (this session)'
            },
            buttons: [
              { label: 'Delete', value: true, primary: true },
              { label: 'Cancel', value: false, ghost: true }
            ]
          });
          if (!res || !res.value) return;
          if (res.input) skipEmptyDeleteConfirmSession = true;
        } else {
          setStatus('‚ÑπÔ∏è Empty-folder delete (sync files), confirmation skipped.', 'info');
        }
      } else {
        const ok = await showConfirm(summary, {
          title: 'Delete',
          okText: 'Delete',
          cancelText: 'Cancel'
        });
        if (!ok) return;
      }
      let removed = null;
      withHistory('delete', () => {
        const ctxs = detachManyWithContext(ids);
        removed = ctxs.length ? { count: ctxs.length } : null;
      });
      clearSelection();
      renderTree();
      updateHistoryButtons();
      setStatus(removed ? `Deleted ${removed.count || 1}.` : 'Not found.', removed ? 'success' : 'info');
      scheduleNavOnly('delete.tree');

      if (!navOnly) {
        let fileResult = { deleted: [], errors: [] };
        if (hasFiles) fileResult = await deleteFilesOnDisk(filesToDelete, { deleteAssets: true });
        if (hasDirs) {
          if (fileResult.errors && fileResult.errors.length) {
            setStatus('‚ö†Ô∏è Skipped deleting folders because some files failed to delete.', 'info');
          } else {
            await deleteDirsOnDisk(dirsToDelete);
          }
        }
        if (hasFiles || hasDirs) scheduleNavOnly('delete.disk');
      } else if (hasFiles || hasDirs) {
        setStatus('‚ö†Ô∏è Nav-only mode: disk folders/files unchanged. Clean manually if needed.', 'info');
      }
    }

	    function classifyFoldersForDelete(ids) {
	      const blocking = [];
	      const emptyDirs = [];
	      const seenDirs = new Set();

	      function hasNonOverviewPage(folder) {
	        if (!folder || folder.type !== 'folder') return false;
	        const children = Array.isArray(folder.children) ? folder.children : [];
	        const overview = children.find(c => c && c.type === 'page' && c.is_overview) || null;
	        for (const c of children) {
	          if (!c) continue;
	          if (c.type === 'page') {
	            if (overview && c === overview) continue;
	            return true;
	          }
	          if (c.type === 'folder') {
	            if (hasNonOverviewPage(c)) return true;
	          }
	        }
	        return false;
	      }

	      for (const id of (ids || [])) {
	        const found = findNode(stateTree, id);
	        if (!found || !found.node) continue;
	        if (found.node.type !== 'folder') continue;
	        if (hasNonOverviewPage(found.node)) {
	          blocking.push({ id, title: found.node.title || id });
	          continue;
	        }
	        const dir = folderDirForId(id);
        if (dir && !seenDirs.has(dir)) {
          seenDirs.add(dir);
          emptyDirs.push(dir);
        }
      }
      return { blocking, emptyDirs };
    }

    function folderDirForId(id) {
      if (!id) return '';
      const info = findNode(stateTree, id);
      if (!info || !info.node || info.node.type !== 'folder') return '';
      const segs = [];
      const selfSeg = (info.node.segment || '').trim();
      if (selfSeg) segs.push(selfSeg);
      let p = info.parent;
      while (p) {
        if (p.type === 'folder' && p.segment) segs.push(String(p.segment).trim());
        const parentInfo = findNode(stateTree, p.id);
        p = parentInfo ? parentInfo.parent : null;
      }
      return segs.reverse().filter(Boolean).join('/');
    }

    function collectFilesForIds(ids) {
      const out = [];
      const seen = new Set();
      function walk(node) {
        if (!node) return;
        if (node.type === 'page') {
          if (node.file) {
            const rel = String(node.file).replace(/^\.\//, '').trim();
            if (rel && !seen.has(rel)) {
              seen.add(rel);
              out.push(rel);
            }
          }
          return;
        }
        for (const c of (node.children || [])) walk(c);
      }
      for (const id of (ids || [])) {
        const found = findNode(stateTree, id);
        if (!found) continue;
        walk(found.node);
      }
      return out;
    }

    async function deleteFilesOnDisk(files, options) {
      const opts = options || {};
      const deleteAssets = !!opts.deleteAssets;
      setStatus('üóëÔ∏è Deleting files...', 'info');
      try {
        const data = await fetchJson('/api/delete_files', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ files, delete_assets: deleteAssets })
        });
        const deleted = Array.isArray(data.deleted) ? data.deleted : [];
        const errors = Array.isArray(data.errors) ? data.errors : [];
        const list = deleted.map(item => item && item.path ? item.path : '').filter(Boolean);
        const head = list[0] ? ` ${list[0]}` : '';
        const more = list.length > 1 ? ` +${list.length - 1}` : '';
        const msg = `‚úÖ Deleted ${deleted.length} item(s) from disk.${head}${more}${errors.length ? ` errors:${errors.length}` : ''}`;
        setStatus(msg, errors.length ? 'error' : 'success');
        await loadSource();
        return { deleted, errors };
      } catch (e) {
        setStatus(e.message || '‚õîÔ∏è Delete files failed.', 'error');
        return { deleted: [], errors: [{ error: e.message || 'Delete files failed.' }] };
      }
    }

    async function deleteDirsOnDisk(dirs) {
      if (!Array.isArray(dirs) || !dirs.length) return;
      setStatus('üóëÔ∏è Deleting empty folders...', 'info');
      try {
        const data = await fetchJson('/api/delete_dirs', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ dirs })
        });
        const deleted = Array.isArray(data.deleted) ? data.deleted : [];
        const errors = Array.isArray(data.errors) ? data.errors : [];
        const list = deleted.map(item => item && item.path ? item.path : '').filter(Boolean);
        const head = list[0] ? ` ${list[0]}` : '';
        const more = list.length > 1 ? ` +${list.length - 1}` : '';
        const msg = `‚úÖ Deleted ${deleted.length} empty folder(s).${head}${more}${errors.length ? ` errors:${errors.length}` : ''}`;
        setStatus(msg, errors.length ? 'error' : 'success');
        await loadSource();
      } catch (e) {
        setStatus(e.message || '‚õîÔ∏è Delete folders failed.', 'error');
      }
    }
  </script>
</body>

</html>
